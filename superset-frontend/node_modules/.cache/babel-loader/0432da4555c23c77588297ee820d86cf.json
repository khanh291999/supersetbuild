{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport { Dropdown } from 'src/components/Dropdown';\nimport { EditableTabs } from 'src/components/Tabs';\nimport { Menu } from 'src/common/components';\nimport { connect } from 'react-redux';\nimport { bindActionCreators } from 'redux';\nimport URI from 'urijs';\nimport { styled, t } from '@superset-ui/core';\nimport { isFeatureEnabled, FeatureFlag } from 'src/featureFlags';\nimport { areArraysShallowEqual } from 'src/reduxUtils';\nimport { Tooltip } from 'src/components/Tooltip';\nimport { detectOS } from 'src/utils/common';\nimport * as Actions from 'src/SqlLab/actions/sqlLab';\nimport SqlEditor from '../SqlEditor';\nimport TabStatusIcon from '../TabStatusIcon';import { jsx as ___EmotionJSX } from \"@emotion/react\";\n\nconst propTypes = {\n  actions: PropTypes.object.isRequired,\n  defaultDbId: PropTypes.number,\n  displayLimit: PropTypes.number,\n  defaultQueryLimit: PropTypes.number.isRequired,\n  maxRow: PropTypes.number.isRequired,\n  databases: PropTypes.object.isRequired,\n  queries: PropTypes.object.isRequired,\n  queryEditors: PropTypes.array,\n  requestedQuery: PropTypes.object,\n  tabHistory: PropTypes.array.isRequired,\n  tables: PropTypes.array.isRequired,\n  offline: PropTypes.bool,\n  saveQueryWarning: PropTypes.string,\n  scheduleQueryWarning: PropTypes.string };\n\nconst defaultProps = {\n  queryEditors: [],\n  offline: false,\n  requestedQuery: null,\n  saveQueryWarning: null,\n  scheduleQueryWarning: null };\n\n\nlet queryCount = 1;\n\nconst TabTitleWrapper = styled.div`\n  display: flex;\n  align-items: center;\n`;\n\nconst TabTitle = styled.span`\n  margin-right: ${({ theme }) => theme.gridUnit * 2}px;\n  text-transform: none;\n`;\n\n// Get the user's OS\nconst userOS = detectOS();\n\nclass TabbedSqlEditors extends React.PureComponent {\n  constructor(props) {\n    super(props);\n    const sqlLabUrl = '/superset/sqllab';\n    this.state = {\n      sqlLabUrl,\n      queriesArray: [],\n      dataPreviewQueries: [] };\n\n    this.removeQueryEditor = this.removeQueryEditor.bind(this);\n    this.renameTab = this.renameTab.bind(this);\n    this.toggleLeftBar = this.toggleLeftBar.bind(this);\n    this.removeAllOtherQueryEditors = this.removeAllOtherQueryEditors.bind(\n    this);\n\n    this.duplicateQueryEditor = this.duplicateQueryEditor.bind(this);\n    this.handleSelect = this.handleSelect.bind(this);\n    this.handleEdit = this.handleEdit.bind(this);\n  }\n\n  componentDidMount() {\n    // migrate query editor and associated tables state to server\n    if (isFeatureEnabled(FeatureFlag.SQLLAB_BACKEND_PERSISTENCE)) {\n      const localStorageTables = this.props.tables.filter(\n      (table) => table.inLocalStorage);\n\n      const localStorageQueries = Object.values(this.props.queries).filter(\n      (query) => query.inLocalStorage);\n\n      this.props.queryEditors.\n      filter((qe) => qe.inLocalStorage).\n      forEach((qe) => {\n        // get all queries associated with the query editor\n        const queries = localStorageQueries.filter(\n        (query) => query.sqlEditorId === qe.id);\n\n        const tables = localStorageTables.filter(\n        (table) => table.queryEditorId === qe.id);\n\n        this.props.actions.migrateQueryEditorFromLocalStorage(\n        qe,\n        tables,\n        queries);\n\n      });\n    }\n\n    // merge post form data with GET search params\n    // Hack: this data should be comming from getInitialState\n    // but for some reason this data isn't being passed properly through\n    // the reducer.\n    const appContainer = document.getElementById('app');\n    const bootstrapData = JSON.parse(\n    (appContainer == null ? void 0 : appContainer.getAttribute('data-bootstrap')) || '{}');\n\n    const query = {\n      ...bootstrapData.requested_query,\n      ...URI(window.location).search(true) };\n\n\n    // Popping a new tab based on the querystring\n    if (\n    query.id ||\n    query.sql ||\n    query.savedQueryId ||\n    query.datasourceKey ||\n    query.queryId)\n    {\n      if (query.id) {\n        this.props.actions.popStoredQuery(query.id);\n      } else if (query.savedQueryId) {\n        this.props.actions.popSavedQuery(query.savedQueryId);\n      } else if (query.queryId) {\n        this.props.actions.popQuery(query.queryId);\n      } else if (query.datasourceKey) {\n        this.props.actions.popDatasourceQuery(query.datasourceKey, query.sql);\n      } else if (query.sql) {\n        let dbId = query.dbid;\n        if (dbId) {\n          dbId = parseInt(dbId, 10);\n        } else {\n          const { databases } = this.props;\n          const dbName = query.dbname;\n          if (dbName) {\n            Object.keys(databases).forEach((db) => {\n              if (databases[db].database_name === dbName) {\n                dbId = databases[db].id;\n              }\n            });\n          }\n        }\n        const newQueryEditor = {\n          title: query.title,\n          dbId,\n          schema: query.schema,\n          autorun: query.autorun,\n          sql: query.sql };\n\n        this.props.actions.addQueryEditor(newQueryEditor);\n      }\n      this.popNewTab();\n    } else if (query.new || this.props.queryEditors.length === 0) {\n      this.newQueryEditor();\n\n      if (query.new) {\n        window.history.replaceState({}, document.title, this.state.sqlLabUrl);\n      }\n    } else {\n      const qe = this.activeQueryEditor();\n      const latestQuery = this.props.queries[qe.latestQueryId];\n      if (\n      isFeatureEnabled(FeatureFlag.SQLLAB_BACKEND_PERSISTENCE) &&\n      latestQuery &&\n      latestQuery.resultsKey)\n      {\n        // when results are not stored in localStorage they need to be\n        // fetched from the results backend (if configured)\n        this.props.actions.fetchQueryResults(\n        latestQuery,\n        this.props.displayLimit);\n\n      }\n    }\n  }\n\n  UNSAFE_componentWillReceiveProps(nextProps) {\n    const nextActiveQeId =\n    nextProps.tabHistory[nextProps.tabHistory.length - 1];\n    const queriesArray = Object.values(nextProps.queries).filter(\n    (query) => query.sqlEditorId === nextActiveQeId);\n\n    if (!areArraysShallowEqual(queriesArray, this.state.queriesArray)) {\n      this.setState({ queriesArray });\n    }\n\n    const dataPreviewQueries = [];\n    nextProps.tables.forEach((table) => {\n      const queryId = table.dataPreviewQueryId;\n      if (\n      queryId &&\n      nextProps.queries[queryId] &&\n      table.queryEditorId === nextActiveQeId)\n      {\n        dataPreviewQueries.push({\n          ...nextProps.queries[queryId],\n          tableName: table.name });\n\n      }\n    });\n    if (\n    !areArraysShallowEqual(dataPreviewQueries, this.state.dataPreviewQueries))\n    {\n      this.setState({ dataPreviewQueries });\n    }\n  }\n\n  popNewTab() {\n    queryCount += 1;\n    // Clean the url in browser history\n    window.history.replaceState({}, document.title, this.state.sqlLabUrl);\n  }\n\n  renameTab(qe) {\n    /* eslint no-alert: 0 */\n    const newTitle = prompt(t('Enter a new title for the tab'));\n    if (newTitle) {\n      this.props.actions.queryEditorSetTitle(qe, newTitle);\n    }\n  }\n\n  activeQueryEditor() {\n    if (this.props.tabHistory.length === 0) {\n      return this.props.queryEditors[0];\n    }\n    const qeid = this.props.tabHistory[this.props.tabHistory.length - 1];\n    return this.props.queryEditors.find((qe) => qe.id === qeid) || null;\n  }\n\n  newQueryEditor() {\n    queryCount += 1;\n    const activeQueryEditor = this.activeQueryEditor();\n    const firstDbId = Math.min(\n    ...Object.values(this.props.databases).map((database) => database.id));\n\n    const warning = isFeatureEnabled(FeatureFlag.SQLLAB_BACKEND_PERSISTENCE) ?\n    '' :\n    `${t(\n    '-- Note: Unless you save your query, these tabs will NOT persist if you clear your cookies or change browsers.')\n    }\\n\\n`;\n    const qe = {\n      title: t('Untitled Query %s', queryCount),\n      dbId:\n      activeQueryEditor && activeQueryEditor.dbId ?\n      activeQueryEditor.dbId :\n      this.props.defaultDbId || firstDbId,\n      schema: activeQueryEditor ? activeQueryEditor.schema : null,\n      autorun: false,\n      sql: `${warning}SELECT ...`,\n      queryLimit: this.props.defaultQueryLimit };\n\n    this.props.actions.addQueryEditor(qe);\n  }\n\n  handleSelect(key) {\n    const qeid = this.props.tabHistory[this.props.tabHistory.length - 1];\n    if (key !== qeid) {\n      const queryEditor = this.props.queryEditors.find((qe) => qe.id === key);\n      this.props.actions.switchQueryEditor(\n      queryEditor,\n      this.props.displayLimit);\n\n    }\n  }\n\n  handleEdit(key, action) {\n    if (action === 'remove') {\n      const qe = this.props.queryEditors.find((qe) => qe.id === key);\n      this.removeQueryEditor(qe);\n    }\n    if (action === 'add') {\n      this.newQueryEditor();\n    }\n  }\n\n  removeQueryEditor(qe) {\n    this.props.actions.removeQueryEditor(qe);\n  }\n\n  removeAllOtherQueryEditors(cqe) {\n    this.props.queryEditors.forEach(\n    (qe) => qe !== cqe && this.removeQueryEditor(qe));\n\n  }\n\n  duplicateQueryEditor(qe) {\n    this.props.actions.cloneQueryToNewTab(qe, false);\n  }\n\n  toggleLeftBar(qe) {\n    this.props.actions.toggleLeftBar(qe);\n  }\n\n  render() {\n    const editors = this.props.queryEditors.map((qe) => {\n      let latestQuery;\n      if (qe.latestQueryId) {\n        latestQuery = this.props.queries[qe.latestQueryId];\n      }\n      let database;\n      if (qe.dbId) {\n        database = this.props.databases[qe.dbId];\n      }\n      const state = latestQuery ? latestQuery.state : '';\n\n      const menu =\n      ___EmotionJSX(Menu, { style: { width: 176 } },\n      ___EmotionJSX(Menu.Item, {\n        className: \"close-btn\",\n        key: \"1\",\n        onClick: () => this.removeQueryEditor(qe) },\n\n\n      ___EmotionJSX(\"div\", { className: \"icon-container\" },\n      ___EmotionJSX(\"i\", { className: \"fa fa-close\" })),\n\n      t('Close tab')),\n\n      ___EmotionJSX(Menu.Item, { key: \"2\", onClick: () => this.renameTab(qe) },\n      ___EmotionJSX(\"div\", { className: \"icon-container\" },\n      ___EmotionJSX(\"i\", { className: \"fa fa-i-cursor\" })),\n\n      t('Rename tab')),\n\n      ___EmotionJSX(Menu.Item, { key: \"3\", onClick: () => this.toggleLeftBar(qe) },\n      ___EmotionJSX(\"div\", { className: \"icon-container\" },\n      ___EmotionJSX(\"i\", { className: \"fa fa-cogs\" })),\n\n      qe.hideLeftBar ? t('Expand tool bar') : t('Hide tool bar')),\n\n      ___EmotionJSX(Menu.Item, {\n        key: \"4\",\n        onClick: () => this.removeAllOtherQueryEditors(qe) },\n\n      ___EmotionJSX(\"div\", { className: \"icon-container\" },\n      ___EmotionJSX(\"i\", { className: \"fa fa-times-circle-o\" })),\n\n      t('Close all other tabs')),\n\n      ___EmotionJSX(Menu.Item, { key: \"5\", onClick: () => this.duplicateQueryEditor(qe) },\n      ___EmotionJSX(\"div\", { className: \"icon-container\" },\n      ___EmotionJSX(\"i\", { className: \"fa fa-files-o\" })),\n\n      t('Duplicate tab')));\n\n\n\n      const tabHeader =\n      ___EmotionJSX(TabTitleWrapper, null,\n      ___EmotionJSX(\"div\", null,\n      ___EmotionJSX(Dropdown, { overlay: menu, trigger: ['click'] })),\n\n      ___EmotionJSX(TabTitle, null, qe.title), \" \", ___EmotionJSX(TabStatusIcon, { tabState: state }), ' ');\n\n\n      return (\n        ___EmotionJSX(EditableTabs.TabPane, {\n          key: qe.id,\n          tab: tabHeader\n          // for tests - key prop isn't handled by enzyme well bcs it's a react keyword\n          , \"data-key\": qe.id },\n\n        ___EmotionJSX(SqlEditor, {\n          tables: this.props.tables.filter((xt) => xt.queryEditorId === qe.id),\n          queryEditorId: qe.id,\n          editorQueries: this.state.queriesArray,\n          dataPreviewQueries: this.state.dataPreviewQueries,\n          latestQuery: latestQuery,\n          database: database,\n          actions: this.props.actions,\n          hideLeftBar: qe.hideLeftBar,\n          defaultQueryLimit: this.props.defaultQueryLimit,\n          maxRow: this.props.maxRow,\n          displayLimit: this.props.displayLimit,\n          saveQueryWarning: this.props.saveQueryWarning,\n          scheduleQueryWarning: this.props.scheduleQueryWarning })));\n\n\n\n    });\n\n    return (\n      ___EmotionJSX(EditableTabs, {\n        activeKey: this.props.tabHistory[this.props.tabHistory.length - 1],\n        id: \"a11y-query-editor-tabs\",\n        className: \"SqlEditorTabs\",\n\n        onChange: this.handleSelect,\n        fullWidth: false,\n        hideAdd: this.props.offline,\n        onEdit: this.handleEdit,\n        addIcon:\n        ___EmotionJSX(Tooltip, {\n          id: \"add-tab\",\n          placement: \"bottom\",\n          title:\n          userOS === 'Windows' ?\n          t('New tab (Ctrl + q)') :\n          t('New tab (Ctrl + t)') },\n\n\n        ___EmotionJSX(\"i\", { className: \"fa fa-plus-circle\" })) },\n\n\n\n      editors));\n\n\n  }}\n\nTabbedSqlEditors.propTypes = propTypes;\nTabbedSqlEditors.defaultProps = defaultProps;\n\nfunction mapStateToProps({ sqlLab, common, requestedQuery }) {\n  return {\n    databases: sqlLab.databases,\n    queryEditors: sqlLab.queryEditors,\n    queries: sqlLab.queries,\n    tabHistory: sqlLab.tabHistory,\n    tables: sqlLab.tables,\n    defaultDbId: sqlLab.defaultDbId,\n    displayLimit: common.conf.DISPLAY_MAX_ROW,\n    offline: sqlLab.offline,\n    defaultQueryLimit: common.conf.DEFAULT_SQLLAB_LIMIT,\n    maxRow: common.conf.SQL_MAX_ROW,\n    saveQueryWarning: common.conf.SQLLAB_SAVE_WARNING_MESSAGE,\n    scheduleQueryWarning: common.conf.SQLLAB_SCHEDULE_WARNING_MESSAGE,\n    requestedQuery };\n\n}\nfunction mapDispatchToProps(dispatch) {\n  return {\n    actions: bindActionCreators(Actions, dispatch) };\n\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(TabbedSqlEditors);","map":null,"metadata":{},"sourceType":"module"}