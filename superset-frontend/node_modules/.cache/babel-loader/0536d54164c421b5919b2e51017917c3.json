{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport rison from 'rison';\nimport { useState, useEffect, useCallback } from 'react';\nimport { makeApi, SupersetClient, t } from '@superset-ui/core';\nimport { createErrorHandler, getAlreadyExists, getPasswordsNeeded, hasTerminalValidation } from 'src/views/CRUD/utils';\nimport copyTextToClipboard from 'src/utils/copy';\nimport { getClientErrorObject } from 'src/utils/getClientErrorObject';\nimport SupersetText from 'src/utils/textUtils';\nconst parsedErrorMessage = (errorMessage) => {\n  if (typeof errorMessage === 'string') {\n    return errorMessage;\n  }\n  return Object.entries(errorMessage).\n  map(([key, value]) => {\n    if (Array.isArray(value)) {\n      return `(${key}) ${value.join(', ')}`;\n    }\n    return `(${key}) ${value}`;\n  }).\n  join('\\n');\n};\nexport function useListViewResource(resource, resourceLabel, // resourceLabel for translations\nhandleErrorMsg, infoEnable = true, defaultCollectionValue = [], baseFilters, // must be memoized\ninitialLoadingState = true) {\n  const [state, setState] = useState({\n    count: 0,\n    collection: defaultCollectionValue,\n    loading: initialLoadingState,\n    lastFetchDataConfig: null,\n    permissions: [],\n    bulkSelectEnabled: false });\n\n  function updateState(update) {\n    setState((currentState) => ({ ...currentState, ...update }));\n  }\n  function toggleBulkSelect() {\n    updateState({ bulkSelectEnabled: !state.bulkSelectEnabled });\n  }\n  useEffect(() => {\n    if (!infoEnable)\n    return;\n    SupersetClient.get({\n      endpoint: `/api/v1/${resource}/_info?q=${rison.encode({\n        keys: ['permissions'] })\n      }` }).\n    then(({ json: infoJson = {} }) => {\n      updateState({\n        permissions: infoJson.permissions });\n\n    }, createErrorHandler((errMsg) => handleErrorMsg(t('An error occurred while fetching %s info: %s', resourceLabel, errMsg))));\n  }, []);\n  function hasPerm(perm) {\n    if (!state.permissions.length) {\n      return false;\n    }\n    return Boolean(state.permissions.find((p) => p === perm));\n  }\n  const fetchData = useCallback(({ pageIndex, pageSize, sortBy, filters: filterValues }) => {\n    // set loading state, cache the last config for refreshing data.\n    updateState({\n      lastFetchDataConfig: {\n        filters: filterValues,\n        pageIndex,\n        pageSize,\n        sortBy },\n\n      loading: true });\n\n    const filterExps = (baseFilters || []).\n    concat(filterValues).\n    map(({ id, operator: opr, value }) => ({\n      col: id,\n      opr,\n      value: value && typeof value === 'object' && 'value' in value ?\n      value.value :\n      value }));\n\n    const queryParams = rison.encode({\n      order_column: sortBy[0].id,\n      order_direction: sortBy[0].desc ? 'desc' : 'asc',\n      page: pageIndex,\n      page_size: pageSize,\n      ...(filterExps.length ? { filters: filterExps } : {}) });\n\n    return SupersetClient.get({\n      endpoint: `/api/v1/${resource}/?q=${queryParams}` }).\n\n    then(({ json = {} }) => {\n      updateState({\n        collection: json.result,\n        count: json.count,\n        lastFetched: new Date().toISOString() });\n\n    }, createErrorHandler((errMsg) => handleErrorMsg(t('An error occurred while fetching %ss: %s', resourceLabel, errMsg)))).\n    finally(() => {\n      updateState({ loading: false });\n    });\n  }, [baseFilters]);\n  return {\n    state: {\n      loading: state.loading,\n      resourceCount: state.count,\n      resourceCollection: state.collection,\n      bulkSelectEnabled: state.bulkSelectEnabled,\n      lastFetched: state.lastFetched },\n\n    setResourceCollection: (update) => updateState({\n      collection: update }),\n\n    hasPerm,\n    fetchData,\n    toggleBulkSelect,\n    refreshData: (provideConfig) => {\n      if (state.lastFetchDataConfig) {\n        return fetchData(state.lastFetchDataConfig);\n      }\n      if (provideConfig) {\n        return fetchData(provideConfig);\n      }\n      return null;\n    } };\n\n}\nexport function useSingleViewResource(resourceName, resourceLabel, // resourceLabel for translations\nhandleErrorMsg) {\n  const [state, setState] = useState({\n    loading: false,\n    resource: null,\n    error: null });\n\n  function updateState(update) {\n    setState((currentState) => ({ ...currentState, ...update }));\n  }\n  const fetchResource = useCallback((resourceID) => {\n    // Set loading state\n    updateState({\n      loading: true });\n\n    return SupersetClient.get({\n      endpoint: `/api/v1/${resourceName}/${resourceID}` }).\n\n    then(({ json = {} }) => {\n      updateState({\n        resource: json.result,\n        error: null });\n\n      return json.result;\n    }, createErrorHandler((errMsg) => {\n      handleErrorMsg(t('An error occurred while fetching %ss: %s', resourceLabel, parsedErrorMessage(errMsg)));\n      updateState({\n        error: errMsg });\n\n    })).\n    finally(() => {\n      updateState({ loading: false });\n    });\n  }, [handleErrorMsg, resourceName, resourceLabel]);\n  const createResource = useCallback((resource, hideToast = false) => {\n    // Set loading state\n    updateState({\n      loading: true });\n\n    return SupersetClient.post({\n      endpoint: `/api/v1/${resourceName}/`,\n      body: JSON.stringify(resource),\n      headers: { 'Content-Type': 'application/json' } }).\n\n    then(({ json = {} }) => {\n      updateState({\n        resource: { id: json.id, ...json.result },\n        error: null });\n\n      return json.id;\n    }, createErrorHandler((errMsg) => {\n      // we did not want toasts for db-connection-ui but did not want to disable it everywhere\n      if (!hideToast) {\n        handleErrorMsg(t('An error occurred while creating %ss: %s', resourceLabel, parsedErrorMessage(errMsg)));\n      }\n      updateState({\n        error: errMsg });\n\n    })).\n    finally(() => {\n      updateState({ loading: false });\n    });\n  }, [handleErrorMsg, resourceName, resourceLabel]);\n  const updateResource = useCallback((resourceID, resource, hideToast = false) => {\n    // Set loading state\n    updateState({\n      loading: true });\n\n    return SupersetClient.put({\n      endpoint: `/api/v1/${resourceName}/${resourceID}`,\n      body: JSON.stringify(resource),\n      headers: { 'Content-Type': 'application/json' } }).\n\n    then(({ json = {} }) => {\n      updateState({\n        resource: { ...json.result, id: json.id },\n        error: null });\n\n      return json.result;\n    }, createErrorHandler((errMsg) => {\n      if (!hideToast) {\n        handleErrorMsg(t('An error occurred while fetching %ss: %s', resourceLabel, JSON.stringify(errMsg)));\n      }\n      updateState({\n        error: errMsg });\n\n      return errMsg;\n    })).\n    finally(() => {\n      updateState({ loading: false });\n    });\n  }, [handleErrorMsg, resourceName, resourceLabel]);\n  const clearError = () => updateState({\n    error: null });\n\n  return {\n    state,\n    setResource: (update) => updateState({\n      resource: update }),\n\n    fetchResource,\n    createResource,\n    updateResource,\n    clearError };\n\n}\nexport function useImportResource(resourceName, resourceLabel, // resourceLabel for translations\nhandleErrorMsg) {\n  const [state, setState] = useState({\n    loading: false,\n    passwordsNeeded: [],\n    alreadyExists: [] });\n\n  function updateState(update) {\n    setState((currentState) => ({ ...currentState, ...update }));\n  }\n  const importResource = useCallback((bundle, databasePasswords = {}, overwrite = false) => {\n    // Set loading state\n    updateState({\n      loading: true });\n\n    const formData = new FormData();\n    formData.append('formData', bundle);\n    /* The import bundle never contains database passwords; if required\n     * they should be provided by the user during import.\n     */\n    if (databasePasswords) {\n      formData.append('passwords', JSON.stringify(databasePasswords));\n    }\n    /* If the imported model already exists the user needs to confirm\n     * that they want to overwrite it.\n     */\n    if (overwrite) {\n      formData.append('overwrite', 'true');\n    }\n    return SupersetClient.post({\n      endpoint: `/api/v1/${resourceName}/import/`,\n      body: formData,\n      headers: { Accept: 'application/json' } }).\n\n    then(() => true).\n    catch((response) => getClientErrorObject(response).then((error) => {\n      if (!error.errors) {\n        handleErrorMsg(t('An error occurred while importing %s: %s', resourceLabel, error.message || error.error));\n        return false;\n      }\n      if (hasTerminalValidation(error.errors)) {\n        handleErrorMsg(t('An error occurred while importing %s: %s', resourceLabel, error.errors.map((payload) => payload.message).join('\\n')));\n      } else\n      {\n        updateState({\n          passwordsNeeded: getPasswordsNeeded(error.errors),\n          alreadyExists: getAlreadyExists(error.errors) });\n\n      }\n      return false;\n    })).\n    finally(() => {\n      updateState({ loading: false });\n    });\n  }, []);\n  return { state, importResource };\n}\nvar FavStarClassName;\n(function (FavStarClassName) {\n  FavStarClassName[\"CHART\"] = \"slice\";\n  FavStarClassName[\"DASHBOARD\"] = \"Dashboard\";\n})(FavStarClassName || (FavStarClassName = {}));\nconst favoriteApis = {\n  chart: makeApi({\n    requestType: 'rison',\n    method: 'GET',\n    endpoint: '/api/v1/chart/favorite_status/' }),\n\n  dashboard: makeApi({\n    requestType: 'rison',\n    method: 'GET',\n    endpoint: '/api/v1/dashboard/favorite_status/' }) };\n\n\nexport function useFavoriteStatus(type, ids, handleErrorMsg) {\n  const [favoriteStatus, setFavoriteStatus] = useState({});\n  const updateFavoriteStatus = (update) => setFavoriteStatus((currentState) => ({ ...currentState, ...update }));\n  useEffect(() => {\n    if (!ids.length) {\n      return;\n    }\n    favoriteApis[type](ids).then(({ result }) => {\n      const update = result.reduce((acc, element) => {\n        acc[element.id] = element.value;\n        return acc;\n      }, {});\n      updateFavoriteStatus(update);\n    }, createErrorHandler((errMsg) => handleErrorMsg(t('There was an error fetching the favorite status: %s', errMsg))));\n  }, [ids, type, handleErrorMsg]);\n  const saveFaveStar = useCallback((id, isStarred) => {\n    const urlSuffix = isStarred ? 'unselect' : 'select';\n    SupersetClient.get({\n      endpoint: `/superset/favstar/${type === 'chart' ? FavStarClassName.CHART : FavStarClassName.DASHBOARD}/${id}/${urlSuffix}/` }).\n    then(({ json }) => {\n      updateFavoriteStatus({\n        [id]: (json == null ? void 0 : json.count) > 0 });\n\n    }, createErrorHandler((errMsg) => handleErrorMsg(t('There was an error saving the favorite status: %s', errMsg))));\n  }, [type]);\n  return [saveFaveStar, favoriteStatus];\n}\nexport const useChartEditModal = (setCharts, charts) => {\n  const [sliceCurrentlyEditing, setSliceCurrentlyEditing] = useState(null);\n  function openChartEditModal(chart) {\n    setSliceCurrentlyEditing({\n      slice_id: chart.id,\n      slice_name: chart.slice_name,\n      description: chart.description,\n      cache_timeout: chart.cache_timeout,\n      certified_by: chart.certified_by,\n      certification_details: chart.certification_details });\n\n  }\n  function closeChartEditModal() {\n    setSliceCurrentlyEditing(null);\n  }\n  function handleChartUpdated(edits) {\n    // update the chart in our state with the edited info\n    const newCharts = charts.map((chart) => chart.id === edits.id ? { ...chart, ...edits } : chart);\n    setCharts(newCharts);\n  }\n  return {\n    sliceCurrentlyEditing,\n    handleChartUpdated,\n    openChartEditModal,\n    closeChartEditModal };\n\n};\nexport const copyQueryLink = (id, addDangerToast, addSuccessToast) => {\n  copyTextToClipboard(`${window.location.origin}/superset/sqllab?savedQueryId=${id}`).\n  then(() => {\n    addSuccessToast(t('Link Copied!'));\n  }).\n  catch(() => {\n    addDangerToast(t('Sorry, your browser does not support copying.'));\n  });\n};\nexport const getDatabaseImages = () => SupersetText.DB_IMAGES;\nexport const getConnectionAlert = () => SupersetText.DB_CONNECTION_ALERTS;\nexport const getDatabaseDocumentationLinks = () => SupersetText.DB_CONNECTION_DOC_LINKS;\nexport const testDatabaseConnection = (connection, handleErrorMsg, addSuccessToast) => {\n  SupersetClient.post({\n    endpoint: 'api/v1/database/test_connection',\n    body: JSON.stringify(connection),\n    headers: { 'Content-Type': 'application/json' } }).\n  then(() => {\n    addSuccessToast(t('Connection looks good!'));\n  }, createErrorHandler((errMsg) => {\n    handleErrorMsg(t(`${t('ERROR: ')}${parsedErrorMessage(errMsg)}`));\n  }));\n};\nexport function useAvailableDatabases() {\n  const [availableDbs, setAvailableDbs] = useState(null);\n  const getAvailable = useCallback(() => {\n    SupersetClient.get({\n      endpoint: `/api/v1/database/available/` }).\n    then(({ json }) => {\n      setAvailableDbs(json);\n    });\n  }, [setAvailableDbs]);\n  return [availableDbs, getAvailable];\n}\nexport function useDatabaseValidation() {\n  const [validationErrors, setValidationErrors] = useState(null);\n  const getValidation = useCallback((database, onCreate = false) => {\n    SupersetClient.post({\n      endpoint: '/api/v1/database/validate_parameters',\n      body: JSON.stringify(database),\n      headers: { 'Content-Type': 'application/json' } }).\n\n    then(() => {\n      setValidationErrors(null);\n    }).\n    catch((e) => {\n      if (typeof e.json === 'function') {\n        e.json().then(({ errors = [] }) => {\n          const parsedErrors = errors.\n          filter((error) => {\n            const skipValidationError = ![\n            'CONNECTION_MISSING_PARAMETERS_ERROR',\n            'CONNECTION_ACCESS_DENIED_ERROR'].\n            includes(error.error_type);\n            return skipValidationError || onCreate;\n          }).\n          reduce((obj, { error_type, extra, message }) => {\n            if (extra.catalog) {\n              if (extra.catalog.name) {\n                return {\n                  ...obj,\n                  error_type,\n                  [extra.catalog.idx]: {\n                    name: message } };\n\n\n              }\n              if (extra.catalog.url) {\n                return {\n                  ...obj,\n                  error_type,\n                  [extra.catalog.idx]: {\n                    url: message } };\n\n\n              }\n              return {\n                ...obj,\n                error_type,\n                [extra.catalog.idx]: {\n                  name: message,\n                  url: message } };\n\n\n            }\n            // if extra.invalid doesn't exist then the\n            // error can't be mapped to a parameter\n            // so leave it alone\n            if (extra.invalid) {\n              return {\n                ...obj,\n                [extra.invalid[0]]: message,\n                error_type };\n\n            }\n            if (extra.missing) {\n              return {\n                ...obj,\n                error_type,\n                ...Object.assign({}, ...extra.missing.map((field) => ({\n                  [field]: 'This is a required field' }))) };\n\n\n            }\n            return obj;\n          }, {});\n          setValidationErrors(parsedErrors);\n        });\n      } else\n      {\n        // eslint-disable-next-line no-console\n        console.error(e);\n      }\n    });\n  }, [setValidationErrors]);\n  return [validationErrors, getValidation, setValidationErrors];\n}","map":null,"metadata":{},"sourceType":"module"}