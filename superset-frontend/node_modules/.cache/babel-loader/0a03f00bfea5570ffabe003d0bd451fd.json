{"ast":null,"code":"import _URLSearchParams from \"@babel/runtime-corejs3/core-js-stable/url-search-params\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { t, FeatureFlag, isFeatureEnabled } from '@superset-ui/core';\nimport React, { useEffect, useState, useReducer } from 'react';\nimport Tabs from 'src/components/Tabs';\nimport { Select } from 'src/common/components';\nimport Alert from 'src/components/Alert';\nimport Modal from 'src/components/Modal';\nimport Button from 'src/components/Button';\nimport IconButton from 'src/components/IconButton';\nimport InfoTooltip from 'src/components/InfoTooltip';\nimport withToasts from 'src/components/MessageToasts/withToasts';\nimport { testDatabaseConnection, useSingleViewResource, useAvailableDatabases, useDatabaseValidation, getDatabaseImages, getConnectionAlert } from 'src/views/CRUD/hooks';\nimport { useCommonConf } from 'src/views/CRUD/data/database/state';\nimport { CONFIGURATION_METHOD } from 'src/views/CRUD/data/database/types';\nimport Loading from 'src/components/Loading';\nimport ExtraOptions from './ExtraOptions';\nimport SqlAlchemyForm from './SqlAlchemyForm';\nimport DatabaseConnectionForm from './DatabaseConnectionForm';\nimport { antDErrorAlertStyles, antDAlertStyles, StyledAlertMargin, antDModalNoPaddingStyles, antDModalStyles, antDTabsStyles, buttonLinkStyles, alchemyButtonLinkStyles, TabHeader, formHelperStyles, formStyles, StyledAlignment, SelectDatabaseStyles, infoTooltip, StyledFooterButton, StyledStickyHeader } from './styles';\nimport ModalHeader, { DOCUMENTATION_LINK } from './ModalHeader';import { jsx as ___EmotionJSX } from \"@emotion/react\";\nconst engineSpecificAlertMapping = {\n  gsheets: {\n    message: 'Why do I need to create a database?',\n    description: 'To begin using your Google Sheets, you need to create a database first. ' +\n    'Databases are used as a way to identify ' +\n    'your data so that it can be queried and visualized. This ' +\n    'database will hold all of your individual Google Sheets ' +\n    'you choose to connect here.' } };\n\n\nconst errorAlertMapping = {\n  CONNECTION_MISSING_PARAMETERS_ERROR: {\n    message: 'Missing Required Fields',\n    description: 'Please complete all required fields.' },\n\n  CONNECTION_INVALID_HOSTNAME_ERROR: {\n    message: 'Could not verify the host',\n    description: 'The host is invalid. Please verify that this field is entered correctly.' },\n\n  CONNECTION_PORT_CLOSED_ERROR: {\n    message: 'Port is closed',\n    description: 'Please verify that port is open to connect.' },\n\n  CONNECTION_INVALID_PORT_ERROR: {\n    message: 'Invalid Port Number',\n    description: 'The port must be a whole number less than or equal to 65535.' },\n\n  CONNECTION_ACCESS_DENIED_ERROR: {\n    message: 'Invalid account information',\n    description: 'Either the username or password is incorrect.' },\n\n  CONNECTION_INVALID_PASSWORD_ERROR: {\n    message: 'Invalid account information',\n    description: 'Either the username or password is incorrect.' },\n\n  INVALID_PAYLOAD_SCHEMA_ERROR: {\n    message: 'Incorrect Fields',\n    description: 'Please make sure all fields are filled out correctly' },\n\n  TABLE_DOES_NOT_EXIST_ERROR: {\n    message: 'URL could not be identified',\n    description: 'The URL could not be identified. Please check for typos and make sure that \"Type of google sheet allowed\" selection matches the input' } };\n\n\nvar ActionType;\n(function (ActionType) {\n  ActionType[ActionType[\"configMethodChange\"] = 0] = \"configMethodChange\";\n  ActionType[ActionType[\"dbSelected\"] = 1] = \"dbSelected\";\n  ActionType[ActionType[\"editorChange\"] = 2] = \"editorChange\";\n  ActionType[ActionType[\"fetched\"] = 3] = \"fetched\";\n  ActionType[ActionType[\"inputChange\"] = 4] = \"inputChange\";\n  ActionType[ActionType[\"parametersChange\"] = 5] = \"parametersChange\";\n  ActionType[ActionType[\"reset\"] = 6] = \"reset\";\n  ActionType[ActionType[\"textChange\"] = 7] = \"textChange\";\n  ActionType[ActionType[\"extraInputChange\"] = 8] = \"extraInputChange\";\n  ActionType[ActionType[\"extraEditorChange\"] = 9] = \"extraEditorChange\";\n  ActionType[ActionType[\"addTableCatalogSheet\"] = 10] = \"addTableCatalogSheet\";\n  ActionType[ActionType[\"removeTableCatalogSheet\"] = 11] = \"removeTableCatalogSheet\";\n  ActionType[ActionType[\"queryChange\"] = 12] = \"queryChange\";\n})(ActionType || (ActionType = {}));\nfunction dbReducer(state, action) {var _action$payload$type, _trimmedState$catalog2, _action$payload, _action$payload$param;\n  const trimmedState = {\n    ...(state || {}) };\n\n  let query = {};\n  let query_input = '';\n  let deserializeExtraJSON = {};\n  let extra_json;\n  switch (action.type) {\n    case ActionType.extraEditorChange:\n      return {\n        ...trimmedState,\n        extra_json: {\n          ...trimmedState.extra_json,\n          [action.payload.name]: action.payload.json } };\n\n\n    case ActionType.extraInputChange:\n      if (action.payload.name === 'schema_cache_timeout' ||\n      action.payload.name === 'table_cache_timeout') {var _trimmedState$extra_j;\n        return {\n          ...trimmedState,\n          extra_json: {\n            ...trimmedState.extra_json,\n            metadata_cache_timeout: {\n              ...((_trimmedState$extra_j = trimmedState.extra_json) == null ? void 0 : _trimmedState$extra_j.metadata_cache_timeout),\n              [action.payload.name]: action.payload.value } } };\n\n\n\n      }\n      if (action.payload.name === 'schemas_allowed_for_csv_upload') {\n        return {\n          ...trimmedState,\n          extra_json: {\n            ...trimmedState.extra_json,\n            schemas_allowed_for_csv_upload: (action.payload.value || '').split(',') } };\n\n\n      }\n      return {\n        ...trimmedState,\n        extra_json: {\n          ...trimmedState.extra_json,\n          [action.payload.name]: action.payload.type === 'checkbox' ?\n          action.payload.checked :\n          action.payload.value } };\n\n\n    case ActionType.inputChange:\n      if (action.payload.type === 'checkbox') {\n        return {\n          ...trimmedState,\n          [action.payload.name]: action.payload.checked };\n\n      }\n      return {\n        ...trimmedState,\n        [action.payload.name]: action.payload.value };\n\n    case ActionType.parametersChange:\n      if (trimmedState.catalog !== undefined && (_action$payload$type =\n      action.payload.type) != null && _action$payload$type.startsWith('catalog')) {var _action$payload$type2, _trimmedState$catalog;\n        // Formatting wrapping google sheets table catalog\n        const idx = (_action$payload$type2 = action.payload.type) == null ? void 0 : _action$payload$type2.split('-')[1];\n        const catalogToUpdate = (trimmedState == null ? void 0 : trimmedState.catalog[idx]) || {};\n        catalogToUpdate[action.payload.name] = action.payload.value;\n        const paramatersCatalog = {};\n        // eslint-disable-next-line array-callback-return\n        (_trimmedState$catalog = trimmedState.catalog) == null ? void 0 : _trimmedState$catalog.map((item) => {\n          paramatersCatalog[item.name] = item.value;\n        });\n        return {\n          ...trimmedState,\n          parameters: {\n            ...trimmedState.parameters,\n            catalog: paramatersCatalog } };\n\n\n      }\n      return {\n        ...trimmedState,\n        parameters: {\n          ...trimmedState.parameters,\n          [action.payload.name]: action.payload.value } };\n\n\n    case ActionType.addTableCatalogSheet:\n      if (trimmedState.catalog !== undefined) {\n        return {\n          ...trimmedState,\n          catalog: [...trimmedState.catalog, { name: '', value: '' }] };\n\n      }\n      return {\n        ...trimmedState,\n        catalog: [{ name: '', value: '' }] };\n\n    case ActionType.removeTableCatalogSheet:\n      (_trimmedState$catalog2 = trimmedState.catalog) == null ? void 0 : _trimmedState$catalog2.splice(action.payload.indexToDelete, 1);\n      return {\n        ...trimmedState };\n\n    case ActionType.editorChange:\n      return {\n        ...trimmedState,\n        [action.payload.name]: action.payload.json };\n\n    case ActionType.queryChange:\n      return {\n        ...trimmedState,\n        parameters: {\n          ...trimmedState.parameters,\n          query: Object.fromEntries(new _URLSearchParams(action.payload.value)) },\n\n        query_input: action.payload.value };\n\n    case ActionType.textChange:\n      return {\n        ...trimmedState,\n        [action.payload.name]: action.payload.value };\n\n    case ActionType.fetched:\n      // convert all the keys in this payload into strings\n      if (action.payload.extra) {var _extra_json, _extra_json2, _extra_json3;\n        extra_json = {\n          ...JSON.parse(action.payload.extra || '') };\n\n        deserializeExtraJSON = {\n          ...JSON.parse(action.payload.extra || ''),\n          metadata_params: JSON.stringify((_extra_json = extra_json) == null ? void 0 : _extra_json.metadata_params),\n          engine_params: JSON.stringify((_extra_json2 = extra_json) == null ? void 0 : _extra_json2.engine_params),\n          schemas_allowed_for_csv_upload: (_extra_json3 = extra_json) == null ? void 0 : _extra_json3.schemas_allowed_for_csv_upload };\n\n      }\n      // convert query to a string and store in query_input\n      query = ((_action$payload = action.payload) == null ? void 0 : (_action$payload$param = _action$payload.parameters) == null ? void 0 : _action$payload$param.query) || {};\n      query_input = Object.entries(query).\n      map(([key, value]) => `${key}=${value}`).\n      join('&');\n      if (action.payload.encrypted_extra &&\n      action.payload.configuration_method ===\n      CONFIGURATION_METHOD.DYNAMIC_FORM) {var _extra_json4, _extra_json4$engine_p;\n        const engineParamsCatalog = Object.keys(((_extra_json4 = extra_json) == null ? void 0 : (_extra_json4$engine_p = _extra_json4.engine_params) == null ? void 0 : _extra_json4$engine_p.catalog) || {}).map((e) => {var _extra_json5, _extra_json5$engine_p;return {\n            name: e,\n            value: (_extra_json5 = extra_json) == null ? void 0 : (_extra_json5$engine_p = _extra_json5.engine_params) == null ? void 0 : _extra_json5$engine_p.catalog[e] };});\n\n        return {\n          ...action.payload,\n          engine: action.payload.backend || trimmedState.engine,\n          configuration_method: action.payload.configuration_method,\n          extra_json: deserializeExtraJSON,\n          catalog: engineParamsCatalog,\n          parameters: action.payload.parameters,\n          query_input };\n\n      }\n      return {\n        ...action.payload,\n        encrypted_extra: action.payload.encrypted_extra || '',\n        engine: action.payload.backend || trimmedState.engine,\n        configuration_method: action.payload.configuration_method,\n        extra_json: deserializeExtraJSON,\n        parameters: action.payload.parameters,\n        query_input };\n\n    case ActionType.dbSelected:\n      return {\n        ...action.payload };\n\n    case ActionType.configMethodChange:\n      return {\n        ...action.payload };\n\n    case ActionType.reset:\n    default:\n      return null;}\n\n}\nconst DEFAULT_TAB_KEY = '1';\nconst serializeExtra = (extraJson) => JSON.stringify({\n  ...extraJson,\n  metadata_params: JSON.parse((extraJson == null ? void 0 : extraJson.metadata_params) || '{}'),\n  engine_params: JSON.parse((extraJson == null ? void 0 : extraJson.engine_params) || '{}'),\n  schemas_allowed_for_csv_upload: ((extraJson == null ? void 0 : extraJson.schemas_allowed_for_csv_upload) || []).filter((schema) => schema !== '') });\n\nconst DatabaseModal = ({ addDangerToast, addSuccessToast, onDatabaseAdd, onHide, show, databaseId }) => {var _availableDbs$databas3;\n  const [db, setDB] = useReducer(dbReducer, null);\n  const [tabKey, setTabKey] = useState(DEFAULT_TAB_KEY);\n  const [availableDbs, getAvailableDbs] = useAvailableDatabases();\n  const [validationErrors, getValidation, setValidationErrors] = useDatabaseValidation();\n  const [hasConnectedDb, setHasConnectedDb] = useState(false);\n  const [dbName, setDbName] = useState('');\n  const [editNewDb, setEditNewDb] = useState(false);\n  const [isLoading, setLoading] = useState(false);\n  const conf = useCommonConf();\n  const dbImages = getDatabaseImages();\n  const connectionAlert = getConnectionAlert();\n  const isEditMode = !!databaseId;\n  const sslForced = isFeatureEnabled(FeatureFlag.FORCE_DATABASE_CONNECTIONS_SSL);\n  const hasAlert = connectionAlert || !!(db != null && db.engine && engineSpecificAlertMapping[db.engine]);\n  const useSqlAlchemyForm = (db == null ? void 0 : db.configuration_method) === CONFIGURATION_METHOD.SQLALCHEMY_URI;\n  const useTabLayout = isEditMode || useSqlAlchemyForm;\n  // Database fetch logic\n  const { state: { loading: dbLoading, resource: dbFetched, error: dbErrors }, fetchResource, createResource, updateResource, clearError } = useSingleViewResource('database', t('database'), addDangerToast);\n  const isDynamic = (engine) => {var _availableDbs$databas, _availableDbs$databas2;return (availableDbs == null ? void 0 : (_availableDbs$databas = availableDbs.databases) == null ? void 0 : (_availableDbs$databas2 = _availableDbs$databas.find((DB) => DB.backend === engine || DB.engine === engine)) == null ? void 0 : _availableDbs$databas2.parameters) !== undefined;};\n  const showDBError = validationErrors || dbErrors;\n  const isEmpty = (data) => data && Object.keys(data).length === 0;\n  const dbModel = (availableDbs == null ? void 0 : (_availableDbs$databas3 = availableDbs.databases) == null ? void 0 : _availableDbs$databas3.find((available) =>\n  // TODO: we need a centralized engine in one place\n  available.engine === (isEditMode ? db == null ? void 0 : db.backend : db == null ? void 0 : db.engine))) || {};\n  // Test Connection logic\n  const testConnection = () => {var _db$database_name;\n    if (!(db != null && db.sqlalchemy_uri)) {\n      addDangerToast(t('Please enter a SQLAlchemy URI to test'));\n      return;\n    }\n    const connection = {\n      sqlalchemy_uri: (db == null ? void 0 : db.sqlalchemy_uri) || '',\n      database_name: (db == null ? void 0 : (_db$database_name = db.database_name) == null ? void 0 : _db$database_name.trim()) || undefined,\n      impersonate_user: (db == null ? void 0 : db.impersonate_user) || undefined,\n      extra: serializeExtra(db == null ? void 0 : db.extra_json) || undefined,\n      encrypted_extra: (db == null ? void 0 : db.encrypted_extra) || '',\n      server_cert: (db == null ? void 0 : db.server_cert) || undefined };\n\n    testDatabaseConnection(connection, addDangerToast, addSuccessToast);\n  };\n  const onClose = () => {\n    setDB({ type: ActionType.reset });\n    setHasConnectedDb(false);\n    setValidationErrors(null); // reset validation errors on close\n    clearError();\n    setEditNewDb(false);\n    onHide();\n  };\n  const onSave = async () => {var _dbToUpdate$parameter5;\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const { id, ...update } = db || {};\n    // Clone DB object\n    const dbToUpdate = JSON.parse(JSON.stringify(update));\n    if (dbToUpdate.configuration_method === CONFIGURATION_METHOD.DYNAMIC_FORM) {\n      // Validate DB before saving\n      await getValidation(dbToUpdate, true);\n      if (validationErrors && !isEmpty(validationErrors)) {\n        return;\n      }\n      const parameters_schema = isEditMode ?\n      dbToUpdate.parameters_schema.properties :\n      dbModel == null ? void 0 : dbModel.parameters.properties;\n      const additionalEncryptedExtra = JSON.parse(dbToUpdate.encrypted_extra || '{}');\n      const paramConfigArray = Object.keys(parameters_schema || {});\n      paramConfigArray.forEach((paramConfig) => {var _dbToUpdate$parameter;\n        /*\n         * Parameters that are annotated with the `x-encrypted-extra` properties should be moved to\n         * `encrypted_extra`, so that they are stored encrypted in the backend when the database is\n         * created or edited.\n         */\n        if (parameters_schema[paramConfig]['x-encrypted-extra'] && (_dbToUpdate$parameter =\n        dbToUpdate.parameters) != null && _dbToUpdate$parameter[paramConfig]) {var _dbToUpdate$parameter2;\n          if (typeof ((_dbToUpdate$parameter2 = dbToUpdate.parameters) == null ? void 0 : _dbToUpdate$parameter2[paramConfig]) === 'object') {var _dbToUpdate$parameter3;\n            // add new encrypted extra to encrypted_extra object\n            additionalEncryptedExtra[paramConfig] = (_dbToUpdate$parameter3 =\n            dbToUpdate.parameters) == null ? void 0 : _dbToUpdate$parameter3[paramConfig];\n            // The backend expects `encrypted_extra` as a string for historical reasons.\n            dbToUpdate.parameters[paramConfig] = JSON.stringify(dbToUpdate.parameters[paramConfig]);\n          } else\n          {var _dbToUpdate$parameter4;\n            additionalEncryptedExtra[paramConfig] = JSON.parse(((_dbToUpdate$parameter4 = dbToUpdate.parameters) == null ? void 0 : _dbToUpdate$parameter4[paramConfig]) || '{}');\n          }\n        }\n      });\n      // cast the new encrypted extra object into a string\n      dbToUpdate.encrypted_extra = JSON.stringify(additionalEncryptedExtra);\n      // this needs to be added by default to gsheets\n      if (dbToUpdate.engine === 'gsheets') {\n        dbToUpdate.impersonate_user = true;\n      }\n    }\n    if (dbToUpdate != null && (_dbToUpdate$parameter5 = dbToUpdate.parameters) != null && _dbToUpdate$parameter5.catalog) {\n      // need to stringify gsheets catalog to allow it to be seralized\n      dbToUpdate.extra_json = {\n        engine_params: JSON.stringify({\n          catalog: dbToUpdate.parameters.catalog }) };\n\n\n    }\n    if (dbToUpdate != null && dbToUpdate.extra_json) {\n      // convert extra_json to back to string\n      dbToUpdate.extra = serializeExtra(dbToUpdate == null ? void 0 : dbToUpdate.extra_json);\n    }\n    if (db != null && db.id) {\n      setLoading(true);\n      const result = await updateResource(db.id, dbToUpdate, dbToUpdate.configuration_method === CONFIGURATION_METHOD.DYNAMIC_FORM);\n      if (result) {\n        if (onDatabaseAdd) {\n          onDatabaseAdd();\n        }\n        if (!editNewDb) {\n          onClose();\n        }\n      }\n    } else\n    if (db) {\n      // Create\n      setLoading(true);\n      const dbId = await createResource(dbToUpdate, dbToUpdate.configuration_method === CONFIGURATION_METHOD.DYNAMIC_FORM);\n      if (dbId) {\n        setHasConnectedDb(true);\n        if (onDatabaseAdd) {\n          onDatabaseAdd();\n        }\n        if (useTabLayout) {\n          // tab layout only has one step\n          // so it should close immediately on save\n          onClose();\n        }\n      }\n    }\n    setEditNewDb(false);\n    setLoading(false);\n  };\n  const onChange = (type, payload) => {\n    setDB({ type, payload });\n  };\n  // Initialize\n  const fetchDB = () => {\n    if (isEditMode && databaseId) {\n      if (!dbLoading) {\n        fetchResource(databaseId).catch((e) => addDangerToast(t('Sorry there was an error fetching database information: %s', e.message)));\n      }\n    }\n  };\n  const setDatabaseModel = (database_name) => {\n    if (database_name === 'Other') {\n      // Allow users to connect to DB via legacy SQLA form\n      setDB({\n        type: ActionType.dbSelected,\n        payload: {\n          database_name,\n          configuration_method: CONFIGURATION_METHOD.SQLALCHEMY_URI,\n          engine: undefined } });\n\n\n    } else\n    {\n      const selectedDbModel = availableDbs == null ? void 0 : availableDbs.databases.filter((db) => db.name === database_name)[0];\n      const { engine, parameters } = selectedDbModel;\n      const isDynamic = parameters !== undefined;\n      setDB({\n        type: ActionType.dbSelected,\n        payload: {\n          database_name,\n          engine,\n          configuration_method: isDynamic ?\n          CONFIGURATION_METHOD.DYNAMIC_FORM :\n          CONFIGURATION_METHOD.SQLALCHEMY_URI,\n          paramProperties: parameters == null ? void 0 : parameters.properties } });\n\n\n    }\n    setDB({ type: ActionType.addTableCatalogSheet });\n  };\n  const renderAvailableSelector = () => {var _ref, _connectionAlert$ADD_;return ___EmotionJSX(\"div\", { className: \"available\" },\n    ___EmotionJSX(\"h4\", { className: \"available-label\" }, \"Or choose from a list of other databases we support:\"),\n\n\n    ___EmotionJSX(\"div\", { className: \"control-label\" }, \"Supported databases\"),\n    ___EmotionJSX(Select, { className: \"available-select\", onChange: setDatabaseModel, placeholder: \"Choose a database...\" }, (_ref =\n    [...((availableDbs == null ? void 0 : availableDbs.databases) || [])]) == null ? void 0 : _ref.\n    sort((a, b) => a.name.localeCompare(b.name)).\n    map((database) => ___EmotionJSX(Select.Option, { value: database.name, key: database.name },\n    database.name)),\n\n\n    ___EmotionJSX(Select.Option, { value: \"Other\", key: \"Other\" }, \"Other\")),\n\n\n\n    ___EmotionJSX(Alert, { showIcon: true, closable: false, css: (theme) => antDAlertStyles(theme), type: \"info\", message: (connectionAlert == null ? void 0 : (_connectionAlert$ADD_ = connectionAlert.ADD_DATABASE) == null ? void 0 : _connectionAlert$ADD_.message) ||\n      t('Want to add a new database?'), description: connectionAlert != null && connectionAlert.ADD_DATABASE ? ___EmotionJSX(React.Fragment, null, \"Any databases that allow connections via SQL Alchemy URIs can be added.\",\n\n      ' ',\n      ___EmotionJSX(\"a\", { href: connectionAlert == null ? void 0 : connectionAlert.ADD_DATABASE.contact_link, target: \"_blank\", rel: \"noopener noreferrer\" },\n      connectionAlert == null ? void 0 : connectionAlert.ADD_DATABASE.contact_description_link),\n      ' ',\n      connectionAlert == null ? void 0 : connectionAlert.ADD_DATABASE.description) :\n      ___EmotionJSX(React.Fragment, null, \"Any databases that allow connections via SQL Alchemy URIs can be added. Learn about how to connect a database driver\",\n\n      ' ',\n      ___EmotionJSX(\"a\", { href: DOCUMENTATION_LINK, target: \"_blank\", rel: \"noopener noreferrer\" }, \"here\"), \".\") }));};\n\n\n\n\n\n  const renderPreferredSelector = () => {var _availableDbs$databas4;return ___EmotionJSX(\"div\", { className: \"preferred\" },\n    availableDbs == null ? void 0 : (_availableDbs$databas4 = availableDbs.databases) == null ? void 0 : _availableDbs$databas4.\n    filter((db) => db.preferred).\n    map((database) => ___EmotionJSX(IconButton, { className: \"preferred-item\", onClick: () => setDatabaseModel(database.name), buttonText: database.name, icon: dbImages == null ? void 0 : dbImages[database.engine] })));};\n\n  const handleBackButtonOnFinish = () => {\n    if (dbFetched) {\n      fetchResource(dbFetched.id);\n    }\n    setEditNewDb(true);\n  };\n  const handleBackButtonOnConnect = () => {\n    if (editNewDb) {\n      setHasConnectedDb(false);\n    }\n    setDB({ type: ActionType.reset });\n  };\n  const renderModalFooter = () => {\n    if (db) {\n      // if db show back + connenct\n      if (!hasConnectedDb || editNewDb) {\n        return ___EmotionJSX(React.Fragment, null,\n        ___EmotionJSX(StyledFooterButton, { key: \"back\", onClick: handleBackButtonOnConnect }, \"Back\"),\n\n\n        ___EmotionJSX(StyledFooterButton, { key: \"submit\", buttonStyle: \"primary\", onClick: onSave }, \"Connect\"));\n\n\n\n      }\n      return ___EmotionJSX(React.Fragment, null,\n      ___EmotionJSX(StyledFooterButton, { key: \"back\", onClick: handleBackButtonOnFinish }, \"Back\"),\n\n\n      ___EmotionJSX(StyledFooterButton, { key: \"submit\", buttonStyle: \"primary\", onClick: onSave }, \"Finish\"));\n\n\n\n    }\n    return [];\n  };\n  const renderEditModalFooter = () => ___EmotionJSX(React.Fragment, null,\n  ___EmotionJSX(StyledFooterButton, { key: \"close\", onClick: onClose }, \"Close\"),\n\n\n  ___EmotionJSX(StyledFooterButton, { key: \"submit\", buttonStyle: \"primary\", onClick: onSave }, \"Finish\"));\n\n\n\n  useEffect(() => {\n    if (show) {\n      setTabKey(DEFAULT_TAB_KEY);\n      getAvailableDbs();\n      setLoading(true);\n    }\n    if (databaseId && show) {\n      fetchDB();\n    }\n  }, [show, databaseId]);\n  useEffect(() => {\n    if (dbFetched) {\n      setDB({\n        type: ActionType.fetched,\n        payload: dbFetched });\n\n      // keep a copy of the name separate for display purposes\n      // because it shouldn't change when the form is updated\n      setDbName(dbFetched.database_name);\n    }\n  }, [dbFetched]);\n  useEffect(() => {\n    if (isLoading) {\n      setLoading(false);\n    }\n  }, [availableDbs]);\n  const tabChange = (key) => {\n    setTabKey(key);\n  };\n  const renderStepTwoAlert = () => {var _connectionAlert$REGI, _engineSpecificAlertM, _connectionAlert$DEFA, _engineSpecificAlertM2, _connectionAlert$DEFA2;\n    const { hostname } = window.location;\n    let ipAlert = (connectionAlert == null ? void 0 : (_connectionAlert$REGI = connectionAlert.REGIONAL_IPS) == null ? void 0 : _connectionAlert$REGI.default) || '';\n    const regionalIPs = (connectionAlert == null ? void 0 : connectionAlert.REGIONAL_IPS) || {};\n    Object.entries(regionalIPs).forEach(([ipRegion, ipRange]) => {\n      const regex = new RegExp(ipRegion);\n      if (hostname.match(regex)) {\n        ipAlert = ipRange;\n      }\n    });\n    return (db == null ? void 0 : db.engine) && ___EmotionJSX(StyledAlertMargin, null,\n    ___EmotionJSX(Alert, { closable: false, css: (theme) => antDAlertStyles(theme), type: \"info\", showIcon: true, message: ((_engineSpecificAlertM = engineSpecificAlertMapping[db.engine]) == null ? void 0 : _engineSpecificAlertM.message) || (\n      connectionAlert == null ? void 0 : (_connectionAlert$DEFA = connectionAlert.DEFAULT) == null ? void 0 : _connectionAlert$DEFA.message), description: ((_engineSpecificAlertM2 = engineSpecificAlertMapping[db.engine]) == null ? void 0 : _engineSpecificAlertM2.description) ||\n      (connectionAlert == null ? void 0 : (_connectionAlert$DEFA2 = connectionAlert.DEFAULT) == null ? void 0 : _connectionAlert$DEFA2.description) + ipAlert }));\n\n  };\n  const errorAlert = () => {\n    if (isEmpty(dbErrors) ||\n    isEmpty(validationErrors) &&\n    !((validationErrors == null ? void 0 : validationErrors.error_type) in errorAlertMapping)) {\n      return ___EmotionJSX(React.Fragment, null);\n    }\n    if (validationErrors) {var _errorAlertMapping$va, _errorAlertMapping$va2;\n      return ___EmotionJSX(Alert, { type: \"error\", css: (theme) => antDErrorAlertStyles(theme), message: ((_errorAlertMapping$va = errorAlertMapping[validationErrors == null ? void 0 : validationErrors.error_type]) == null ? void 0 : _errorAlertMapping$va.message) || (\n        validationErrors == null ? void 0 : validationErrors.error_type), description: ((_errorAlertMapping$va2 = errorAlertMapping[validationErrors == null ? void 0 : validationErrors.error_type]) == null ? void 0 : _errorAlertMapping$va2.description) ||\n        JSON.stringify(validationErrors), showIcon: true, closable: false });\n    }\n    const message = typeof dbErrors === 'object' ? Object.values(dbErrors) : [];\n    return ___EmotionJSX(Alert, { type: \"error\", css: (theme) => antDErrorAlertStyles(theme), message: \"Database Creation Error\", description: (message == null ? void 0 : message[0]) || dbErrors });\n  };\n  const renderFinishState = () => {\n    if (!editNewDb) {\n      return ___EmotionJSX(ExtraOptions, { db: db, onInputChange: ({ target }) => onChange(ActionType.inputChange, {\n          type: target.type,\n          name: target.name,\n          checked: target.checked,\n          value: target.value }),\n        onTextChange: ({ target }) => onChange(ActionType.textChange, {\n          name: target.name,\n          value: target.value }),\n        onEditorChange: (payload) => onChange(ActionType.editorChange, payload), onExtraInputChange: ({ target }) => {\n          onChange(ActionType.extraInputChange, {\n            type: target.type,\n            name: target.name,\n            checked: target.checked,\n            value: target.value });\n\n        }, onExtraEditorChange: (payload) => onChange(ActionType.extraEditorChange, payload) });\n    }\n    return ___EmotionJSX(DatabaseConnectionForm, { isEditMode: true, sslForced: sslForced, dbModel: dbModel, db: db, onParametersChange: ({ target }) => onChange(ActionType.parametersChange, {\n        type: target.type,\n        name: target.name,\n        checked: target.checked,\n        value: target.value }),\n      onChange: ({ target }) => onChange(ActionType.textChange, {\n        name: target.name,\n        value: target.value }),\n      onQueryChange: ({ target }) => onChange(ActionType.queryChange, {\n        name: target.name,\n        value: target.value }),\n      onAddTableCatalog: () => setDB({ type: ActionType.addTableCatalogSheet }), onRemoveTableCatalog: (idx) => setDB({\n        type: ActionType.removeTableCatalogSheet,\n        payload: { indexToDelete: idx } }),\n      getValidation: () => getValidation(db), validationErrors: validationErrors });\n  };\n  return useTabLayout ? ___EmotionJSX(Modal, { css: (theme) => [\n    antDTabsStyles,\n    antDModalNoPaddingStyles,\n    antDModalStyles(theme),\n    formHelperStyles(theme),\n    formStyles(theme)],\n    name: \"database\", onHandledPrimaryAction: onSave, onHide: onClose, primaryButtonName: isEditMode ? t('Save') : t('Connect'), width: \"500px\", centered: true, show: show, title: ___EmotionJSX(\"h4\", null, isEditMode ? t('Edit database') : t('Connect a database')), footer: isEditMode ? renderEditModalFooter() : renderModalFooter() },\n  ___EmotionJSX(StyledStickyHeader, null,\n  ___EmotionJSX(TabHeader, null,\n  ___EmotionJSX(ModalHeader, { isLoading: isLoading, isEditMode: isEditMode, useSqlAlchemyForm: useSqlAlchemyForm, hasConnectedDb: hasConnectedDb, db: db, dbName: dbName, dbModel: dbModel }))),\n\n\n  ___EmotionJSX(Tabs, { defaultActiveKey: DEFAULT_TAB_KEY, activeKey: tabKey, onTabClick: tabChange, animated: { inkBar: true, tabPane: true } },\n  ___EmotionJSX(Tabs.TabPane, { tab: ___EmotionJSX(\"span\", null, t('Basic')), key: \"1\" },\n  useSqlAlchemyForm ? ___EmotionJSX(StyledAlignment, null,\n  ___EmotionJSX(SqlAlchemyForm, { db: db, onInputChange: ({ target }) => onChange(ActionType.inputChange, {\n      type: target.type,\n      name: target.name,\n      checked: target.checked,\n      value: target.value }),\n    conf: conf, testConnection: testConnection, isEditMode: isEditMode }),\n  isDynamic((db == null ? void 0 : db.backend) || (db == null ? void 0 : db.engine)) && !isEditMode && ___EmotionJSX(\"div\", { css: (theme) => infoTooltip(theme) },\n  ___EmotionJSX(Button, { buttonStyle: \"link\", onClick: () => setDB({\n      type: ActionType.configMethodChange,\n      payload: {\n        database_name: db == null ? void 0 : db.database_name,\n        configuration_method: CONFIGURATION_METHOD.DYNAMIC_FORM,\n        engine: db == null ? void 0 : db.engine } }),\n\n    css: (theme) => alchemyButtonLinkStyles(theme) }, \"Connect this database using the dynamic form instead\"),\n\n\n  ___EmotionJSX(InfoTooltip, { tooltip: t('Click this link to switch to an alternate form that exposes only the required fields needed to connect this database.'), viewBox: \"0 -6 24 24\" }))) :\n\n  ___EmotionJSX(DatabaseConnectionForm, { isEditMode: true, sslForced: sslForced, dbModel: dbModel, db: db, onParametersChange: ({ target }) => onChange(ActionType.parametersChange, {\n      type: target.type,\n      name: target.name,\n      checked: target.checked,\n      value: target.value }),\n    onChange: ({ target }) => onChange(ActionType.textChange, {\n      name: target.name,\n      value: target.value }),\n    onQueryChange: ({ target }) => onChange(ActionType.queryChange, {\n      name: target.name,\n      value: target.value }),\n    onAddTableCatalog: () => setDB({ type: ActionType.addTableCatalogSheet }), onRemoveTableCatalog: (idx) => setDB({\n      type: ActionType.removeTableCatalogSheet,\n      payload: { indexToDelete: idx } }),\n    getValidation: () => getValidation(db), validationErrors: validationErrors }),\n  !isEditMode && ___EmotionJSX(StyledAlertMargin, null,\n  ___EmotionJSX(Alert, { closable: false, css: (theme) => antDAlertStyles(theme), message: \"Additional fields may be required\", showIcon: true, description: ___EmotionJSX(React.Fragment, null, \"Select databases require additional fields to be completed in the Advanced tab to successfully connect the database. Learn what requirements your databases has\",\n\n\n    ' ',\n    ___EmotionJSX(\"a\", { href: DOCUMENTATION_LINK, target: \"_blank\", rel: \"noopener noreferrer\", className: \"additional-fields-alert-description\" }, \"here\"), \".\"),\n\n\n\n    type: \"info\" }))),\n\n\n  ___EmotionJSX(Tabs.TabPane, { tab: ___EmotionJSX(\"span\", null, t('Advanced')), key: \"2\" },\n  ___EmotionJSX(ExtraOptions, { db: db, onInputChange: ({ target }) => onChange(ActionType.inputChange, {\n      type: target.type,\n      name: target.name,\n      checked: target.checked,\n      value: target.value }),\n    onTextChange: ({ target }) => onChange(ActionType.textChange, {\n      name: target.name,\n      value: target.value }),\n    onEditorChange: (payload) => onChange(ActionType.editorChange, payload), onExtraInputChange: ({ target }) => {\n      onChange(ActionType.extraInputChange, {\n        type: target.type,\n        name: target.name,\n        checked: target.checked,\n        value: target.value });\n\n    }, onExtraEditorChange: (payload) => {\n      onChange(ActionType.extraEditorChange, payload);\n    } }),\n  showDBError && errorAlert()))) :\n\n\n  ___EmotionJSX(Modal, { css: (theme) => [\n    antDModalNoPaddingStyles,\n    antDModalStyles(theme),\n    formHelperStyles(theme),\n    formStyles(theme)],\n    name: \"database\", onHandledPrimaryAction: onSave, onHide: onClose, primaryButtonName: hasConnectedDb ? t('Finish') : t('Connect'), width: \"500px\", centered: true, show: show, title: ___EmotionJSX(\"h4\", null, t('Connect a database')), footer: renderModalFooter() },\n  hasConnectedDb ? ___EmotionJSX(React.Fragment, null,\n  ___EmotionJSX(ModalHeader, { isLoading: isLoading, isEditMode: isEditMode, useSqlAlchemyForm: useSqlAlchemyForm, hasConnectedDb: hasConnectedDb, db: db, dbName: dbName, dbModel: dbModel, editNewDb: editNewDb }),\n  renderFinishState()) :\n  ___EmotionJSX(React.Fragment, null,\n\n  !isLoading && (\n  !db ? ___EmotionJSX(SelectDatabaseStyles, null,\n  ___EmotionJSX(ModalHeader, { isLoading: isLoading, isEditMode: isEditMode, useSqlAlchemyForm: useSqlAlchemyForm, hasConnectedDb: hasConnectedDb, db: db, dbName: dbName, dbModel: dbModel }),\n  renderPreferredSelector(),\n  renderAvailableSelector()) :\n  ___EmotionJSX(React.Fragment, null,\n  ___EmotionJSX(ModalHeader, { isLoading: isLoading, isEditMode: isEditMode, useSqlAlchemyForm: useSqlAlchemyForm, hasConnectedDb: hasConnectedDb, db: db, dbName: dbName, dbModel: dbModel }),\n  hasAlert && renderStepTwoAlert(),\n  ___EmotionJSX(DatabaseConnectionForm, { db: db, sslForced: sslForced, dbModel: dbModel, onAddTableCatalog: () => {\n      setDB({ type: ActionType.addTableCatalogSheet });\n    }, onQueryChange: ({ target }) => onChange(ActionType.queryChange, {\n      name: target.name,\n      value: target.value }),\n    onRemoveTableCatalog: (idx) => {\n      setDB({\n        type: ActionType.removeTableCatalogSheet,\n        payload: { indexToDelete: idx } });\n\n    }, onParametersChange: ({ target }) => onChange(ActionType.parametersChange, {\n      type: target.type,\n      name: target.name,\n      checked: target.checked,\n      value: target.value }),\n    onChange: ({ target }) => onChange(ActionType.textChange, {\n      name: target.name,\n      value: target.value }),\n    getValidation: () => getValidation(db), validationErrors: validationErrors }),\n  ___EmotionJSX(\"div\", { css: (theme) => infoTooltip(theme) },\n  ___EmotionJSX(Button, { buttonStyle: \"link\", onClick: () => setDB({\n      type: ActionType.configMethodChange,\n      payload: {\n        engine: db.engine,\n        configuration_method: CONFIGURATION_METHOD.SQLALCHEMY_URI,\n        database_name: db.database_name } }),\n\n    css: buttonLinkStyles }, \"Connect this database with a SQLAlchemy URI string instead\"),\n\n\n  ___EmotionJSX(InfoTooltip, { tooltip: t('Click this link to switch to an alternate form that allows you to input the SQLAlchemy URL for this database manually.'), viewBox: \"0 -6 24 24\" })),\n\n\n  showDBError && errorAlert()))),\n\n\n  isLoading && ___EmotionJSX(Loading, null));\n\n};\nexport default withToasts(DatabaseModal);","map":null,"metadata":{},"sourceType":"module"}