{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { getChartMetadataRegistry, Behavior, EXTRA_FORM_DATA_APPEND_KEYS, EXTRA_FORM_DATA_OVERRIDE_KEYS, FeatureFlag } from '@superset-ui/core';\nimport extractUrlParams from 'src/dashboard/util/extractUrlParams';\nimport { isFeatureEnabled } from 'src/featureFlags';\nimport { CHART_TYPE, TAB_TYPE } from '../../util/componentTypes';\nimport { DASHBOARD_GRID_ID, DASHBOARD_ROOT_ID } from '../../util/constants';\nexport const getFormData = ({ datasetId, cascadingFilters = {}, groupby, inputRef, defaultDataMask, controlValues, filterType, sortMetric, adhoc_filters, time_range, granularity_sqla, type }) => {var _defaultDataMask$filt;\n  const otherProps = {};\n  if (datasetId) {\n    otherProps.datasource = `${datasetId}__table`;\n  }\n  if (groupby) {\n    otherProps.groupby = [groupby];\n  }\n  if (sortMetric) {\n    otherProps.sortMetric = sortMetric;\n  }\n  return {\n    ...controlValues,\n    ...otherProps,\n    adhoc_filters: adhoc_filters != null ? adhoc_filters : [],\n    extra_filters: [],\n    extra_form_data: cascadingFilters,\n    granularity_sqla,\n    metrics: ['count'],\n    row_limit: 1000,\n    showSearch: true,\n    defaultValue: defaultDataMask == null ? void 0 : (_defaultDataMask$filt = defaultDataMask.filterState) == null ? void 0 : _defaultDataMask$filt.value,\n    time_range,\n    time_range_endpoints: ['inclusive', 'exclusive'],\n    url_params: extractUrlParams('regular'),\n    inView: true,\n    viz_type: filterType,\n    inputRef,\n    type };\n\n};\nexport function mergeExtraFormData(originalExtra = {}, newExtra = {}) {\n  const mergedExtra = {};\n  EXTRA_FORM_DATA_APPEND_KEYS.forEach((key) => {\n    const mergedValues = [\n    ...(originalExtra[key] || []),\n    ...(newExtra[key] || [])];\n\n    if (mergedValues.length) {\n      mergedExtra[key] = mergedValues;\n    }\n  });\n  EXTRA_FORM_DATA_OVERRIDE_KEYS.forEach((key) => {\n    const originalValue = originalExtra[key];\n    if (originalValue !== undefined) {\n      mergedExtra[key] = originalValue;\n    }\n    const newValue = newExtra[key];\n    if (newValue !== undefined) {\n      mergedExtra[key] = newValue;\n    }\n  });\n  return mergedExtra;\n}\nexport function isCrossFilter(vizType) {var _getChartMetadataRegi, _getChartMetadataRegi2;\n  // @ts-ignore need export from superset-ui `ItemWithValue`\n  return (_getChartMetadataRegi = getChartMetadataRegistry().items[vizType]) == null ? void 0 : (_getChartMetadataRegi2 = _getChartMetadataRegi.value.behaviors) == null ? void 0 : _getChartMetadataRegi2.includes(Behavior.INTERACTIVE_CHART);\n}\nexport function getExtraFormData(dataMask, charts, filterIdsAppliedOnChart) {\n  let extraFormData = {};\n  filterIdsAppliedOnChart.forEach((key) => {var _dataMask$key$extraFo, _dataMask$key;\n    extraFormData = mergeExtraFormData(extraFormData, (_dataMask$key$extraFo = (_dataMask$key = dataMask[key]) == null ? void 0 : _dataMask$key.extraFormData) != null ? _dataMask$key$extraFo : {});\n  });\n  return extraFormData;\n}\nexport function nativeFilterGate(behaviors) {\n  return !behaviors.includes(Behavior.NATIVE_FILTER) ||\n  isFeatureEnabled(FeatureFlag.DASHBOARD_FILTERS_EXPERIMENTAL) &&\n  isFeatureEnabled(FeatureFlag.DASHBOARD_CROSS_FILTERS) &&\n  behaviors.includes(Behavior.INTERACTIVE_CHART);\n}\nconst isComponentATab = (dashboardLayout, componentId) => dashboardLayout[componentId].type === TAB_TYPE;\nconst findTabsWithChartsInScopeHelper = (dashboardLayout, chartsInScope, componentId, tabIds, tabsToHighlight) => {\n  if (dashboardLayout[componentId].type === CHART_TYPE &&\n  chartsInScope.includes(dashboardLayout[componentId].meta.chartId)) {\n    tabIds.forEach(tabsToHighlight.add, tabsToHighlight);\n  }\n  if (dashboardLayout[componentId].children.length === 0 ||\n  isComponentATab(dashboardLayout, componentId) &&\n  tabsToHighlight.has(componentId)) {\n    return;\n  }\n  dashboardLayout[componentId].children.forEach((childId) => findTabsWithChartsInScopeHelper(dashboardLayout, chartsInScope, childId, isComponentATab(dashboardLayout, childId) ? [...tabIds, childId] : tabIds, tabsToHighlight));\n};\nexport const findTabsWithChartsInScope = (dashboardLayout, chartsInScope) => {\n  const dashboardRoot = dashboardLayout[DASHBOARD_ROOT_ID];\n  const rootChildId = dashboardRoot.children[0];\n  const hasTopLevelTabs = rootChildId !== DASHBOARD_GRID_ID;\n  const tabsInScope = new Set();\n  if (hasTopLevelTabs) {var _dashboardLayout$root;\n    (_dashboardLayout$root = dashboardLayout[rootChildId].children) == null ? void 0 : _dashboardLayout$root.forEach((tabId) => findTabsWithChartsInScopeHelper(dashboardLayout, chartsInScope, tabId, [tabId], tabsInScope));\n  } else\n  {\n    Object.values(dashboardLayout).\n    filter((element) => element.type === TAB_TYPE).\n    forEach((element) => findTabsWithChartsInScopeHelper(dashboardLayout, chartsInScope, element.id, [element.id], tabsInScope));\n  }\n  return tabsInScope;\n};","map":null,"metadata":{},"sourceType":"module"}