{"ast":null,"code":"import _isString from \"lodash/isString\";\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport {\nBehavior,\nCategoricalColorNamespace,\ngetChartMetadataRegistry } from\n'@superset-ui/core';\n\nimport { chart } from 'src/chart/chartReducer';\nimport { initSliceEntities } from 'src/dashboard/reducers/sliceEntities';\nimport { getInitialState as getInitialNativeFilterState } from 'src/dashboard/reducers/nativeFilters';\nimport { applyDefaultFormData } from 'src/explore/store';\nimport { buildActiveFilters } from 'src/dashboard/util/activeDashboardFilters';\nimport findPermission, {\ncanUserEditDashboard } from\n'src/dashboard/util/findPermission';\nimport {\nDASHBOARD_FILTER_SCOPE_GLOBAL,\ndashboardFilter } from\n'src/dashboard/reducers/dashboardFilters';\nimport {\nDASHBOARD_HEADER_ID,\nGRID_DEFAULT_CHART_WIDTH,\nGRID_COLUMN_COUNT,\nDASHBOARD_ROOT_ID } from\n'src/dashboard/util/constants';\nimport {\nDASHBOARD_HEADER_TYPE,\nCHART_TYPE,\nROW_TYPE } from\n'src/dashboard/util/componentTypes';\nimport findFirstParentContainerId from 'src/dashboard/util/findFirstParentContainer';\nimport getEmptyLayout from 'src/dashboard/util/getEmptyLayout';\nimport getFilterConfigsFromFormdata from 'src/dashboard/util/getFilterConfigsFromFormdata';\nimport getLocationHash from 'src/dashboard/util/getLocationHash';\nimport newComponentFactory from 'src/dashboard/util/newComponentFactory';\nimport { TIME_RANGE } from 'src/visualizations/FilterBox/FilterBox';\nimport { URL_PARAMS } from 'src/constants';\nimport { getUrlParam } from 'src/utils/urlUtils';\nimport { FeatureFlag, isFeatureEnabled } from '../../featureFlags';\nimport extractUrlParams from '../util/extractUrlParams';\n\nexport const HYDRATE_DASHBOARD = 'HYDRATE_DASHBOARD';\n\nexport const hydrateDashboard = (dashboardData, chartData) => (\ndispatch,\ngetState) =>\n{var _metadata, _metadata2, _metadata3, _metadata4, _dashboardData$metada, _dashboardData$metada2, _metadata5, _metadata6, _metadata7, _metadata8;\n  const { user, common } = getState();\n  let { metadata } = dashboardData;\n  const regularUrlParams = extractUrlParams('regular');\n  const reservedUrlParams = extractUrlParams('reserved');\n  const editMode = reservedUrlParams.edit === 'true';\n\n  let preselectFilters = {};\n\n  chartData.forEach((chart) => {\n    // eslint-disable-next-line no-param-reassign\n    chart.slice_id = chart.form_data.slice_id;\n  });\n  try {\n    // allow request parameter overwrite dashboard metadata\n    preselectFilters =\n    getUrlParam(URL_PARAMS.preselectFilters) ||\n    JSON.parse(metadata.default_filters);\n  } catch (e) {\n    //\n  }\n\n  // Priming the color palette with user's label-color mapping provided in\n  // the dashboard's JSON metadata\n  if ((_metadata = metadata) != null && _metadata.label_colors) {\n    const namespace = metadata.color_namespace;\n    const colorMap = _isString(metadata.label_colors) ?\n    JSON.parse(metadata.label_colors) :\n    metadata.label_colors;\n    const categoricalNamespace = CategoricalColorNamespace.getNamespace(\n    namespace);\n\n\n    Object.keys(colorMap).forEach((label) => {\n      categoricalNamespace.setColor(label, colorMap[label]);\n    });\n  }\n\n  // dashboard layout\n  const { position_data } = dashboardData;\n  // new dash: position_json could be {} or null\n  const layout =\n  position_data && Object.keys(position_data).length > 0 ?\n  position_data :\n  getEmptyLayout();\n\n  // create a lookup to sync layout names with slice names\n  const chartIdToLayoutId = {};\n  Object.values(layout).forEach((layoutComponent) => {\n    if (layoutComponent.type === CHART_TYPE) {\n      chartIdToLayoutId[layoutComponent.meta.chartId] = layoutComponent.id;\n    }\n  });\n\n  // find root level chart container node for newly-added slices\n  const parentId = findFirstParentContainerId(layout);\n  const parent = layout[parentId];\n  let newSlicesContainer;\n  let newSlicesContainerWidth = 0;\n\n  const filterScopes = ((_metadata2 = metadata) == null ? void 0 : _metadata2.filter_scopes) || {};\n\n  const chartQueries = {};\n  const dashboardFilters = {};\n  const slices = {};\n  const sliceIds = new Set();\n  chartData.forEach((slice) => {\n    const key = slice.slice_id;\n    const form_data = {\n      ...slice.form_data,\n      url_params: {\n        ...slice.form_data.url_params,\n        ...regularUrlParams } };\n\n\n    chartQueries[key] = {\n      ...chart,\n      id: key,\n      form_data,\n      formData: applyDefaultFormData(form_data) };\n\n\n    slices[key] = {\n      slice_id: key,\n      slice_url: slice.slice_url,\n      slice_name: slice.slice_name,\n      form_data: slice.form_data,\n      viz_type: slice.form_data.viz_type,\n      datasource: slice.form_data.datasource,\n      description: slice.description,\n      description_markeddown: slice.description_markeddown,\n      owners: slice.owners,\n      modified: slice.modified,\n      changed_on: new Date(slice.changed_on).getTime() };\n\n\n    sliceIds.add(key);\n\n    // if there are newly added slices from explore view, fill slices into 1 or more rows\n    if (!chartIdToLayoutId[key] && layout[parentId]) {\n      if (\n      newSlicesContainerWidth === 0 ||\n      newSlicesContainerWidth + GRID_DEFAULT_CHART_WIDTH > GRID_COLUMN_COUNT)\n      {\n        newSlicesContainer = newComponentFactory(\n        ROW_TYPE,\n        (parent.parents || []).slice());\n\n        layout[newSlicesContainer.id] = newSlicesContainer;\n        parent.children.push(newSlicesContainer.id);\n        newSlicesContainerWidth = 0;\n      }\n\n      const chartHolder = newComponentFactory(\n      CHART_TYPE,\n      {\n        chartId: slice.slice_id },\n\n      (newSlicesContainer.parents || []).slice());\n\n\n      layout[chartHolder.id] = chartHolder;\n      newSlicesContainer.children.push(chartHolder.id);\n      chartIdToLayoutId[chartHolder.meta.chartId] = chartHolder.id;\n      newSlicesContainerWidth += GRID_DEFAULT_CHART_WIDTH;\n    }\n\n    // build DashboardFilters for interactive filter features\n    if (slice.form_data.viz_type === 'filter_box') {\n      const configs = getFilterConfigsFromFormdata(slice.form_data);\n      let { columns } = configs;\n      const { labels } = configs;\n      if (preselectFilters[key]) {\n        Object.keys(columns).forEach((col) => {\n          if (preselectFilters[key][col]) {\n            columns = {\n              ...columns,\n              [col]: preselectFilters[key][col] };\n\n          }\n        });\n      }\n\n      const scopesByChartId = Object.keys(columns).reduce((map, column) => {\n        const scopeSettings = {\n          ...filterScopes[key] };\n\n        const { scope, immune } = {\n          ...DASHBOARD_FILTER_SCOPE_GLOBAL,\n          ...scopeSettings[column] };\n\n\n        return {\n          ...map,\n          [column]: {\n            scope,\n            immune } };\n\n\n      }, {});\n\n      const componentId = chartIdToLayoutId[key];\n      const directPathToFilter = (layout[componentId].parents || []).slice();\n      directPathToFilter.push(componentId);\n      dashboardFilters[key] = {\n        ...dashboardFilter,\n        chartId: key,\n        componentId,\n        datasourceId: slice.form_data.datasource,\n        filterName: slice.slice_name,\n        directPathToFilter,\n        columns,\n        labels,\n        scopes: scopesByChartId,\n        isInstantFilter: !!slice.form_data.instant_filtering,\n        isDateFilter: Object.keys(columns).includes(TIME_RANGE) };\n\n    }\n\n    // sync layout names with current slice names in case a slice was edited\n    // in explore since the layout was updated. name updates go through layout for undo/redo\n    // functionality and python updates slice names based on layout upon dashboard save\n    const layoutId = chartIdToLayoutId[key];\n    if (layoutId && layout[layoutId]) {\n      layout[layoutId].meta.sliceName = slice.slice_name;\n    }\n  });\n  buildActiveFilters({\n    dashboardFilters,\n    components: layout });\n\n\n  // store the header as a layout component so we can undo/redo changes\n  layout[DASHBOARD_HEADER_ID] = {\n    id: DASHBOARD_HEADER_ID,\n    type: DASHBOARD_HEADER_TYPE,\n    meta: {\n      text: dashboardData.dashboard_title } };\n\n\n\n  const dashboardLayout = {\n    past: [],\n    present: layout,\n    future: [] };\n\n\n  // find direct link component and path from root\n  const directLinkComponentId = getLocationHash();\n  let directPathToChild = [];\n  if (layout[directLinkComponentId]) {\n    directPathToChild = (layout[directLinkComponentId].parents || []).slice();\n    directPathToChild.push(directLinkComponentId);\n  }\n\n  const nativeFilters = getInitialNativeFilterState({\n    filterConfig: ((_metadata3 = metadata) == null ? void 0 : _metadata3.native_filter_configuration) || [],\n    filterSetsConfig: ((_metadata4 = metadata) == null ? void 0 : _metadata4.filter_sets_configuration) || [] });\n\n\n  if (!metadata) {\n    metadata = {};\n  }\n\n  metadata.show_native_filters = (_dashboardData$metada =\n  dashboardData == null ? void 0 : (_dashboardData$metada2 = dashboardData.metadata) == null ? void 0 : _dashboardData$metada2.show_native_filters) != null ? _dashboardData$metada :\n  isFeatureEnabled(FeatureFlag.DASHBOARD_NATIVE_FILTERS);\n\n  if (isFeatureEnabled(FeatureFlag.DASHBOARD_CROSS_FILTERS)) {\n    // If user just added cross filter to dashboard it's not saving it scope on server,\n    // so we tweak it until user will update scope and will save it in server\n    Object.values(dashboardLayout.present).forEach((layoutItem) => {var _layoutItem$meta, _behaviors, _ref, _getChartMetadataRegi, _chartQueries$chartId, _chartQueries$chartId2;\n      const chartId = (_layoutItem$meta = layoutItem.meta) == null ? void 0 : _layoutItem$meta.chartId;\n      const behaviors = (_behaviors = (_ref = (_getChartMetadataRegi =\n\n      getChartMetadataRegistry().get((_chartQueries$chartId =\n      chartQueries[chartId]) == null ? void 0 : (_chartQueries$chartId2 = _chartQueries$chartId.formData) == null ? void 0 : _chartQueries$chartId2.viz_type)) != null ? _getChartMetadataRegi :\n      {}) == null ? void 0 : _ref.\n      behaviors) != null ? _behaviors : [];\n\n      if (!metadata.chart_configuration) {\n        metadata.chart_configuration = {};\n      }\n      if (\n      behaviors.includes(Behavior.INTERACTIVE_CHART) &&\n      !metadata.chart_configuration[chartId])\n      {\n        metadata.chart_configuration[chartId] = {\n          id: chartId,\n          crossFilters: {\n            scope: {\n              rootPath: [DASHBOARD_ROOT_ID],\n              excluded: [chartId] // By default it doesn't affects itself\n            } } };\n\n\n      }\n    });\n  }\n\n  const { roles } = user;\n  const canEdit = canUserEditDashboard(dashboardData, user);\n\n  return dispatch({\n    type: HYDRATE_DASHBOARD,\n    data: {\n      sliceEntities: { ...initSliceEntities, slices, isLoading: false },\n      charts: chartQueries,\n      // read-only data\n      dashboardInfo: {\n        ...dashboardData,\n        metadata,\n        userId: user.userId ? String(user.userId) : null, // legacy, please use state.user instead\n        dash_edit_perm: canEdit,\n        dash_save_perm: findPermission('can_save_dash', 'Superset', roles),\n        dash_share_perm: findPermission(\n        'can_share_dashboard',\n        'Superset',\n        roles),\n\n        superset_can_explore: findPermission('can_explore', 'Superset', roles),\n        superset_can_share: findPermission(\n        'can_share_chart',\n        'Superset',\n        roles),\n\n        superset_can_csv: findPermission('can_csv', 'Superset', roles),\n        slice_can_edit: findPermission('can_slice', 'Superset', roles),\n        common: {\n          // legacy, please use state.common instead\n          flash_messages: common.flash_messages,\n          conf: common.conf } },\n\n\n      dashboardFilters,\n      nativeFilters,\n      dashboardState: {\n        preselectNativeFilters: getUrlParam(URL_PARAMS.nativeFilters),\n        sliceIds: Array.from(sliceIds),\n        directPathToChild,\n        directPathLastUpdated: Date.now(),\n        focusedFilterField: null,\n        expandedSlices: ((_metadata5 = metadata) == null ? void 0 : _metadata5.expanded_slices) || {},\n        refreshFrequency: ((_metadata6 = metadata) == null ? void 0 : _metadata6.refresh_frequency) || 0,\n        // dashboard viewers can set refresh frequency for the current visit,\n        // only persistent refreshFrequency will be saved to backend\n        shouldPersistRefreshFrequency: false,\n        css: dashboardData.css || '',\n        colorNamespace: ((_metadata7 = metadata) == null ? void 0 : _metadata7.color_namespace) || null,\n        colorScheme: ((_metadata8 = metadata) == null ? void 0 : _metadata8.color_scheme) || null,\n        editMode: canEdit && editMode,\n        isPublished: dashboardData.published,\n        hasUnsavedChanges: false,\n        maxUndoHistoryExceeded: false,\n        lastModifiedTime: dashboardData.changed_on,\n        isRefreshing: false,\n        activeTabs: [] },\n\n      dashboardLayout } });\n\n\n};","map":null,"metadata":{},"sourceType":"module"}