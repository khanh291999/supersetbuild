{"ast":null,"code":"import _extends from \"@babel/runtime-corejs3/helpers/extends\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport React, { useRef } from 'react';\nimport { useDrag, useDrop } from 'react-dnd';\nimport { styled, t, useTheme } from '@superset-ui/core';\nimport { InfoTooltipWithTrigger } from '@superset-ui/chart-controls';\nimport { Tooltip } from 'src/components/Tooltip';\nimport Icons from 'src/components/Icons';\nimport { StyledMetricOption } from '../../optionRenderers';import { jsx as ___EmotionJSX } from \"@emotion/react\";\nexport const DragContainer = styled.div`\n  margin-bottom: ${({ theme }) => theme.gridUnit}px;\n  :last-child {\n    margin-bottom: 0;\n  }\n`;\nexport const OptionControlContainer = styled.div`\n  display: flex;\n  align-items: center;\n  width: 100%;\n  font-size: ${({ theme }) => theme.typography.sizes.s}px;\n  height: ${({ theme }) => theme.gridUnit * 6}px;\n  background-color: ${({ theme }) => theme.colors.grayscale.light3};\n  border-radius: 3px;\n  cursor: ${({ withCaret }) => withCaret ? 'pointer' : 'default'};\n`;\nexport const Label = styled.div`\n  ${({ theme }) => `\n    display: flex;\n    width: 100%;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    align-items: center;\n    white-space: nowrap;\n    padding-left: ${theme.gridUnit}px;\n    svg {\n      margin-right: ${theme.gridUnit}px;\n      margin-left: ${theme.gridUnit}px;\n    }\n    .type-label {\n      margin-right: ${theme.gridUnit * 2}px;\n      margin-left: ${theme.gridUnit}px;\n      font-weight: ${theme.typography.weights.normal};\n      width: auto;\n    }\n    .option-label {\n      display: inline;\n    }\n  `}\n`;\nconst LabelText = styled.span`\n  overflow: hidden;\n  text-overflow: ellipsis;\n`;\nexport const CaretContainer = styled.div`\n  height: 100%;\n  border-left: solid 1px ${({ theme }) => theme.colors.grayscale.dark2}0C;\n  margin-left: auto;\n`;\nexport const CloseContainer = styled.div`\n  height: 100%;\n  width: ${({ theme }) => theme.gridUnit * 6}px;\n  border-right: solid 1px ${({ theme }) => theme.colors.grayscale.dark2}0C;\n  cursor: pointer;\n`;\nconst StyledInfoTooltipWithTrigger = styled(InfoTooltipWithTrigger)`\n  margin: 0 ${({ theme }) => theme.gridUnit}px;\n`;\nexport const HeaderContainer = styled.div`\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n`;\nexport const LabelsContainer = styled.div`\n  padding: ${({ theme }) => theme.gridUnit}px;\n  border: solid 1px ${({ theme }) => theme.colors.grayscale.light2};\n  border-radius: ${({ theme }) => theme.gridUnit}px;\n`;\nexport const DndLabelsContainer = styled.div`\n  padding: ${({ theme }) => theme.gridUnit}px;\n  border: ${({ canDrop, isOver, theme }) => {\n  if (canDrop) {\n    return `dashed 1px ${theme.colors.info.dark1}`;\n  }\n  if (isOver && !canDrop) {\n    return `dashed 1px ${theme.colors.error.dark1}`;\n  }\n  return `solid 1px ${theme.colors.grayscale.light2}`;\n}};\n  border-radius: ${({ theme }) => theme.gridUnit}px;\n`;\nexport const AddControlLabel = styled.div`\n  display: flex;\n  align-items: center;\n  width: 100%;\n  height: ${({ theme }) => theme.gridUnit * 6}px;\n  padding-left: ${({ theme }) => theme.gridUnit}px;\n  font-size: ${({ theme }) => theme.typography.sizes.s}px;\n  color: ${({ theme }) => theme.colors.grayscale.light1};\n  border: dashed 1px ${({ theme }) => theme.colors.grayscale.light2};\n  border-radius: ${({ theme }) => theme.gridUnit}px;\n  cursor: ${({ cancelHover }) => cancelHover ? 'inherit' : 'pointer'};\n\n  :hover {\n    background-color: ${({ cancelHover, theme }) => cancelHover ? 'inherit' : theme.colors.grayscale.light4};\n  }\n\n  :active {\n    background-color: ${({ cancelHover, theme }) => cancelHover ? 'inherit' : theme.colors.grayscale.light3};\n  }\n`;\nexport const AddIconButton = styled.button`\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  height: ${({ theme }) => theme.gridUnit * 4}px;\n  width: ${({ theme }) => theme.gridUnit * 4}px;\n  padding: 0;\n  background-color: ${({ theme }) => theme.colors.primary.dark1};\n  border: none;\n  border-radius: 2px;\n\n  :disabled {\n    cursor: not-allowed;\n    background-color: ${({ theme }) => theme.colors.grayscale.light1};\n  }\n`;\nexport const OptionControlLabel = ({ label, savedMetric, adhocMetric, onRemove, onMoveLabel, onDropLabel, withCaret, isFunction, type, index, isExtra, tooltipTitle, multi = true, ...props }) => {\n  const theme = useTheme();\n  const ref = useRef(null);\n  const labelRef = useRef(null);\n  const hasMetricName = savedMetric == null ? void 0 : savedMetric.metric_name;\n  const [, drop] = useDrop({\n    accept: type,\n    drop() {\n      if (!multi) {\n        return;\n      }\n      onDropLabel == null ? void 0 : onDropLabel();\n    },\n    hover(item, monitor) {var _ref$current;\n      if (!multi) {\n        return;\n      }\n      if (!ref.current) {\n        return;\n      }\n      const dragIndex = item.index;\n      const hoverIndex = index;\n      // Don't replace items with themselves\n      if (dragIndex === hoverIndex) {\n        return;\n      }\n      // Determine rectangle on screen\n      const hoverBoundingRect = (_ref$current = ref.current) == null ? void 0 : _ref$current.getBoundingClientRect();\n      // Get vertical middle\n      const hoverMiddleY = (hoverBoundingRect.bottom - hoverBoundingRect.top) / 2;\n      // Determine mouse position\n      const clientOffset = monitor.getClientOffset();\n      // Get pixels to the top\n      const hoverClientY = clientOffset != null && clientOffset.y ?\n      (clientOffset == null ? void 0 : clientOffset.y) - hoverBoundingRect.top :\n      0;\n      // Only perform the move when the mouse has crossed half of the items height\n      // When dragging downwards, only move when the cursor is below 50%\n      // When dragging upwards, only move when the cursor is above 50%\n      // Dragging downwards\n      if (dragIndex < hoverIndex && hoverClientY < hoverMiddleY) {\n        return;\n      }\n      // Dragging upwards\n      if (dragIndex > hoverIndex && hoverClientY > hoverMiddleY) {\n        return;\n      }\n      // Time to actually perform the action\n      onMoveLabel == null ? void 0 : onMoveLabel(dragIndex, hoverIndex);\n      // Note: we're mutating the monitor item here!\n      // Generally it's better to avoid mutations,\n      // but it's good here for the sake of performance\n      // to avoid expensive index searches.\n      // eslint-disable-next-line no-param-reassign\n      item.index = hoverIndex;\n    } });\n\n  const [{ isDragging }, drag] = useDrag({\n    item: {\n      type,\n      index,\n      value: savedMetric != null && savedMetric.metric_name ? savedMetric : adhocMetric },\n\n    collect: (monitor) => ({\n      isDragging: monitor.isDragging() }) });\n\n\n  const getLabelContent = () => {\n    const shouldShowTooltip = !isDragging &&\n    typeof label === 'string' &&\n    tooltipTitle &&\n    label &&\n    tooltipTitle !== label ||\n    !isDragging &&\n    labelRef &&\n    labelRef.current &&\n    labelRef.current.scrollWidth > labelRef.current.clientWidth;\n    if (savedMetric && hasMetricName) {\n      return ___EmotionJSX(StyledMetricOption, { metric: savedMetric, labelRef: labelRef, showTooltip: !!shouldShowTooltip });\n    }\n    if (!shouldShowTooltip) {\n      return ___EmotionJSX(LabelText, { ref: labelRef }, label);\n    }\n    return ___EmotionJSX(Tooltip, { title: tooltipTitle || label },\n    ___EmotionJSX(LabelText, { ref: labelRef }, label));\n\n  };\n  const getOptionControlContent = () => ___EmotionJSX(OptionControlContainer, _extends({ withCaret: withCaret }, props),\n  ___EmotionJSX(CloseContainer, { role: \"button\", onClick: onRemove },\n  ___EmotionJSX(Icons.XSmall, { iconColor: theme.colors.grayscale.light1 })),\n\n  ___EmotionJSX(Label, null,\n  isFunction && ___EmotionJSX(Icons.FunctionX, { viewBox: \"0 0 16 11\", iconSize: \"l\" }),\n  getLabelContent()),\n\n  isExtra && ___EmotionJSX(StyledInfoTooltipWithTrigger, { icon: \"exclamation-triangle\", placement: \"top\", bsStyle: \"warning\", tooltip: t(`\n                This filter was inherited from the dashboard's context.\n                It won't be saved when saving the chart.\n              `) }),\n  withCaret && ___EmotionJSX(CaretContainer, null,\n  ___EmotionJSX(Icons.CaretRight, { iconColor: theme.colors.grayscale.light1 })));\n\n\n  drag(drop(ref));\n  return ___EmotionJSX(DragContainer, { ref: ref }, getOptionControlContent());\n};","map":null,"metadata":{},"sourceType":"module"}