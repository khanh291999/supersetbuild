{"ast":null,"code":"import _isEmpty from \"lodash/isEmpty\";import _flatMap from \"lodash/flatMap\";import _mapValues from \"lodash/fp/mapValues\";import _keyBy from \"lodash/fp/keyBy\";import _flow from \"lodash/fp/flow\";\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport { CHART_TYPE, TAB_TYPE } from './componentTypes';\nimport { getChartIdAndColumnFromFilterKey } from './getDashboardFilterKey';\n\nfunction getImmuneChartIdsFromTabsNotInScope({ tabs = [], tabsInScope = [] }) {\n  const chartsNotInScope = [];\n  tabs.forEach(({ value: tab, children: tabChildren }) => {\n    if (tabChildren && !tabsInScope.includes(tab)) {\n      tabChildren.forEach(({ value: subTab, children: subTabChildren }) => {\n        if (subTabChildren && !tabsInScope.includes(subTab)) {\n          chartsNotInScope.push(\n          ...subTabChildren.filter(({ type }) => type === CHART_TYPE));\n\n        }\n      });\n    }\n  });\n\n  // return chartId only\n  return chartsNotInScope.map(({ value }) => value);\n}\nfunction getTabChildrenScope({\n  tabScopes,\n  parentNodeValue,\n  forceAggregate = false,\n  hasChartSiblings = false,\n  tabChildren = [],\n  immuneChartSiblings = [] })\n{\n  // if all sub-tabs are in scope, or forceAggregate =  true\n  // aggregate scope to parentNodeValue\n  if (\n  forceAggregate ||\n  !hasChartSiblings &&\n  Object.entries(tabScopes).every(\n  ([key, { scope }]) => scope && scope.length && key === scope[0]))\n\n  {\n    // get all charts from tabChildren that is not in scope\n    const immuneChartIdsFromTabsNotInScope = getImmuneChartIdsFromTabsNotInScope(\n    {\n      tabs: tabChildren,\n      tabsInScope: _flatMap(tabScopes, ({ scope }) => scope) });\n\n\n    const immuneChartIdsFromTabsInScope = _flatMap(\n    Object.values(tabScopes),\n    ({ immune }) => immune);\n\n    const immuneCharts = [\n    ...new Set([\n    ...immuneChartIdsFromTabsNotInScope,\n    ...immuneChartIdsFromTabsInScope])];\n\n\n    return {\n      scope: [parentNodeValue],\n      immune: immuneCharts };\n\n  }\n\n  const componentsInScope = Object.values(tabScopes).filter(\n  ({ scope }) => scope && scope.length);\n\n  return {\n    scope: _flatMap(componentsInScope, ({ scope }) => scope),\n    immune: componentsInScope.length ?\n    _flatMap(componentsInScope, ({ immune }) => immune) :\n    _flatMap(Object.values(tabScopes), ({ immune }) => immune).concat(\n    immuneChartSiblings) };\n\n\n}\n\nfunction traverse({ currentNode = {}, filterId, checkedChartIds = [] }) {\n  if (!currentNode) {\n    return {};\n  }\n\n  const { value: currentValue, children } = currentNode;\n  const chartChildren = children.filter(({ type }) => type === CHART_TYPE);\n  const tabChildren = children.filter(({ type }) => type === TAB_TYPE);\n\n  const chartsImmune = chartChildren.\n  filter(\n  ({ value }) => filterId !== value && !checkedChartIds.includes(value)).\n\n  map(({ value }) => value);\n  const tabScopes = _flow(\n  _keyBy((child) => child.value),\n  _mapValues((child) =>\n  traverse({\n    currentNode: child,\n    filterId,\n    checkedChartIds })))(\n\n\n  tabChildren);\n\n  // if any chart type child is in scope,\n  // no matter has tab children or not, current node should be scope\n  if (\n  !_isEmpty(chartChildren) &&\n  chartChildren.some(({ value }) => checkedChartIds.includes(value)))\n  {\n    if (_isEmpty(tabChildren)) {\n      return { scope: [currentValue], immune: chartsImmune };\n    }\n\n    const { scope, immune } = getTabChildrenScope({\n      tabScopes,\n      parentNodeValue: currentValue,\n      forceAggregate: true,\n      tabChildren });\n\n    return {\n      scope,\n      immune: chartsImmune.concat(immune) };\n\n  }\n\n  // has tab children but only some sub-tab in scope\n  if (tabChildren.length) {\n    return getTabChildrenScope({\n      tabScopes,\n      parentNodeValue: currentValue,\n      hasChartSiblings: !_isEmpty(chartChildren),\n      tabChildren,\n      immuneChartSiblings: chartsImmune });\n\n  }\n\n  // no tab children and no chart children in scope\n  return {\n    scope: [],\n    immune: chartsImmune };\n\n}\n\nexport default function getFilterScopeFromNodesTree({\n  filterKey,\n  nodes = [],\n  checkedChartIds = [] })\n{\n  if (nodes.length) {\n    const { chartId } = getChartIdAndColumnFromFilterKey(filterKey);\n    return traverse({\n      currentNode: nodes[0],\n      filterId: chartId,\n      checkedChartIds });\n\n  }\n\n  return {};\n}","map":null,"metadata":{},"sourceType":"module"}