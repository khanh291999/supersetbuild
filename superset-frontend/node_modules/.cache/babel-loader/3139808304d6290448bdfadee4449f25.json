{"ast":null,"code":"var e10 = Math.sqrt(50),\ne5 = Math.sqrt(10),\ne2 = Math.sqrt(2);\n\nexport default function (start, stop, count) {\n  var reverse,\n  i = -1,\n  n,\n  ticks,\n  step;\n\n  stop = +stop, start = +start, count = +count;\n  if (start === stop && count > 0) return [start];\n  if (reverse = stop < start) n = start, start = stop, stop = n;\n  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];\n\n  if (step > 0) {\n    let r0 = Math.round(start / step),r1 = Math.round(stop / step);\n    if (r0 * step < start) ++r0;\n    if (r1 * step > stop) --r1;\n    ticks = new Array(n = r1 - r0 + 1);\n    while (++i < n) ticks[i] = (r0 + i) * step;\n  } else {\n    step = -step;\n    let r0 = Math.round(start * step),r1 = Math.round(stop * step);\n    if (r0 / step < start) ++r0;\n    if (r1 / step > stop) --r1;\n    ticks = new Array(n = r1 - r0 + 1);\n    while (++i < n) ticks[i] = (r0 + i) / step;\n  }\n\n  if (reverse) ticks.reverse();\n\n  return ticks;\n}\n\nexport function tickIncrement(start, stop, count) {\n  var step = (stop - start) / Math.max(0, count),\n  power = Math.floor(Math.log(step) / Math.LN10),\n  error = step / Math.pow(10, power);\n  return power >= 0 ?\n  (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power) :\n  -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);\n}\n\nexport function tickStep(start, stop, count) {\n  var step0 = Math.abs(stop - start) / Math.max(0, count),\n  step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),\n  error = step0 / step1;\n  if (error >= e10) step1 *= 10;else\n  if (error >= e5) step1 *= 5;else\n  if (error >= e2) step1 *= 2;\n  return stop < start ? -step1 : step1;\n}","map":null,"metadata":{},"sourceType":"module"}