{"ast":null,"code":"function _EMOTION_STRINGIFIED_CSS_ERROR__() {return \"You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).\";} /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport { CompactPicker } from 'react-color';\nimport Button from 'src/components/Button';\nimport {\nt,\nSupersetClient,\ngetCategoricalSchemeRegistry,\ngetChartMetadataRegistry,\nvalidateNonEmpty,\nisValidExpression } from\n'@superset-ui/core';\n\nimport SelectControl from 'src/explore/components/controls/SelectControl';\nimport TextControl from 'src/explore/components/controls/TextControl';\nimport CheckboxControl from 'src/explore/components/controls/CheckboxControl';\nimport {\nANNOTATION_SOURCE_TYPES,\nANNOTATION_TYPES,\nANNOTATION_TYPES_METADATA,\nDEFAULT_ANNOTATION_TYPE,\nrequiresQuery,\nANNOTATION_SOURCE_TYPES_METADATA } from\n'src/modules/AnnotationTypes';\nimport PopoverSection from 'src/components/PopoverSection';\nimport ControlHeader from 'src/explore/components/ControlHeader';import { jsx as ___EmotionJSX } from \"@emotion/react\";\n\nconst AUTOMATIC_COLOR = '';\n\nconst propTypes = {\n  name: PropTypes.string,\n  annotationType: PropTypes.string,\n  sourceType: PropTypes.string,\n  color: PropTypes.string,\n  opacity: PropTypes.string,\n  style: PropTypes.string,\n  width: PropTypes.number,\n  showMarkers: PropTypes.bool,\n  hideLine: PropTypes.bool,\n  value: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  overrides: PropTypes.object,\n  show: PropTypes.bool,\n  titleColumn: PropTypes.string,\n  descriptionColumns: PropTypes.arrayOf(PropTypes.string),\n  timeColumn: PropTypes.string,\n  intervalEndColumn: PropTypes.string,\n  vizType: PropTypes.string,\n\n  error: PropTypes.string,\n  colorScheme: PropTypes.string,\n\n  addAnnotationLayer: PropTypes.func,\n  removeAnnotationLayer: PropTypes.func,\n  close: PropTypes.func };\n\n\nconst defaultProps = {\n  name: '',\n  annotationType: DEFAULT_ANNOTATION_TYPE,\n  sourceType: '',\n  color: AUTOMATIC_COLOR,\n  opacity: '',\n  style: 'solid',\n  width: 1,\n  showMarkers: false,\n  hideLine: false,\n  overrides: {},\n  colorScheme: 'd3Category10',\n  show: true,\n  titleColumn: '',\n  descriptionColumns: [],\n  timeColumn: '',\n  intervalEndColumn: '',\n\n  addAnnotationLayer: () => {},\n  removeAnnotationLayer: () => {},\n  close: () => {} };var _ref = process.env.NODE_ENV === \"production\" ? { name: \"1h52dri\", styles: \"overflow:hidden;text-overflow:ellipsis;white-space:nowrap\" } : { name: \"1jn9azd-AnnotationLayer\", styles: \"overflow:hidden;text-overflow:ellipsis;white-space:nowrap;label:AnnotationLayer;\", map: \"/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9zdXBlcnNldC1mcm9udGVuZC9zcmMvZXhwbG9yZS9jb21wb25lbnRzL2NvbnRyb2xzL0Fubm90YXRpb25MYXllckNvbnRyb2wvQW5ub3RhdGlvbkxheWVyLmpzeCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFtV1EiLCJmaWxlIjoiL3N1cGVyc2V0LWZyb250ZW5kL3NyYy9leHBsb3JlL2NvbXBvbmVudHMvY29udHJvbHMvQW5ub3RhdGlvbkxheWVyQ29udHJvbC9Bbm5vdGF0aW9uTGF5ZXIuanN4Iiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgeyBDb21wYWN0UGlja2VyIH0gZnJvbSAncmVhY3QtY29sb3InO1xuaW1wb3J0IEJ1dHRvbiBmcm9tICdzcmMvY29tcG9uZW50cy9CdXR0b24nO1xuaW1wb3J0IHtcbiAgdCxcbiAgU3VwZXJzZXRDbGllbnQsXG4gIGdldENhdGVnb3JpY2FsU2NoZW1lUmVnaXN0cnksXG4gIGdldENoYXJ0TWV0YWRhdGFSZWdpc3RyeSxcbiAgdmFsaWRhdGVOb25FbXB0eSxcbiAgaXNWYWxpZEV4cHJlc3Npb24sXG59IGZyb20gJ0BzdXBlcnNldC11aS9jb3JlJztcblxuaW1wb3J0IFNlbGVjdENvbnRyb2wgZnJvbSAnc3JjL2V4cGxvcmUvY29tcG9uZW50cy9jb250cm9scy9TZWxlY3RDb250cm9sJztcbmltcG9ydCBUZXh0Q29udHJvbCBmcm9tICdzcmMvZXhwbG9yZS9jb21wb25lbnRzL2NvbnRyb2xzL1RleHRDb250cm9sJztcbmltcG9ydCBDaGVja2JveENvbnRyb2wgZnJvbSAnc3JjL2V4cGxvcmUvY29tcG9uZW50cy9jb250cm9scy9DaGVja2JveENvbnRyb2wnO1xuaW1wb3J0IHtcbiAgQU5OT1RBVElPTl9TT1VSQ0VfVFlQRVMsXG4gIEFOTk9UQVRJT05fVFlQRVMsXG4gIEFOTk9UQVRJT05fVFlQRVNfTUVUQURBVEEsXG4gIERFRkFVTFRfQU5OT1RBVElPTl9UWVBFLFxuICByZXF1aXJlc1F1ZXJ5LFxuICBBTk5PVEFUSU9OX1NPVVJDRV9UWVBFU19NRVRBREFUQSxcbn0gZnJvbSAnc3JjL21vZHVsZXMvQW5ub3RhdGlvblR5cGVzJztcbmltcG9ydCBQb3BvdmVyU2VjdGlvbiBmcm9tICdzcmMvY29tcG9uZW50cy9Qb3BvdmVyU2VjdGlvbic7XG5pbXBvcnQgQ29udHJvbEhlYWRlciBmcm9tICdzcmMvZXhwbG9yZS9jb21wb25lbnRzL0NvbnRyb2xIZWFkZXInO1xuXG5jb25zdCBBVVRPTUFUSUNfQ09MT1IgPSAnJztcblxuY29uc3QgcHJvcFR5cGVzID0ge1xuICBuYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBhbm5vdGF0aW9uVHlwZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgc291cmNlVHlwZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgY29sb3I6IFByb3BUeXBlcy5zdHJpbmcsXG4gIG9wYWNpdHk6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHN0eWxlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICB3aWR0aDogUHJvcFR5cGVzLm51bWJlcixcbiAgc2hvd01hcmtlcnM6IFByb3BUeXBlcy5ib29sLFxuICBoaWRlTGluZTogUHJvcFR5cGVzLmJvb2wsXG4gIHZhbHVlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMubnVtYmVyXSksXG4gIG92ZXJyaWRlczogUHJvcFR5cGVzLm9iamVjdCxcbiAgc2hvdzogUHJvcFR5cGVzLmJvb2wsXG4gIHRpdGxlQ29sdW1uOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBkZXNjcmlwdGlvbkNvbHVtbnM6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5zdHJpbmcpLFxuICB0aW1lQ29sdW1uOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBpbnRlcnZhbEVuZENvbHVtbjogUHJvcFR5cGVzLnN0cmluZyxcbiAgdml6VHlwZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICBlcnJvcjogUHJvcFR5cGVzLnN0cmluZyxcbiAgY29sb3JTY2hlbWU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgYWRkQW5ub3RhdGlvbkxheWVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgcmVtb3ZlQW5ub3RhdGlvbkxheWVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgY2xvc2U6IFByb3BUeXBlcy5mdW5jLFxufTtcblxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBuYW1lOiAnJyxcbiAgYW5ub3RhdGlvblR5cGU6IERFRkFVTFRfQU5OT1RBVElPTl9UWVBFLFxuICBzb3VyY2VUeXBlOiAnJyxcbiAgY29sb3I6IEFVVE9NQVRJQ19DT0xPUixcbiAgb3BhY2l0eTogJycsXG4gIHN0eWxlOiAnc29saWQnLFxuICB3aWR0aDogMSxcbiAgc2hvd01hcmtlcnM6IGZhbHNlLFxuICBoaWRlTGluZTogZmFsc2UsXG4gIG92ZXJyaWRlczoge30sXG4gIGNvbG9yU2NoZW1lOiAnZDNDYXRlZ29yeTEwJyxcbiAgc2hvdzogdHJ1ZSxcbiAgdGl0bGVDb2x1bW46ICcnLFxuICBkZXNjcmlwdGlvbkNvbHVtbnM6IFtdLFxuICB0aW1lQ29sdW1uOiAnJyxcbiAgaW50ZXJ2YWxFbmRDb2x1bW46ICcnLFxuXG4gIGFkZEFubm90YXRpb25MYXllcjogKCkgPT4ge30sXG4gIHJlbW92ZUFubm90YXRpb25MYXllcjogKCkgPT4ge30sXG4gIGNsb3NlOiAoKSA9PiB7fSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFubm90YXRpb25MYXllciBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICBjb25zdCB7XG4gICAgICBuYW1lLFxuICAgICAgYW5ub3RhdGlvblR5cGUsXG4gICAgICBzb3VyY2VUeXBlLFxuICAgICAgY29sb3IsXG4gICAgICBvcGFjaXR5LFxuICAgICAgc3R5bGUsXG4gICAgICB3aWR0aCxcbiAgICAgIHNob3dNYXJrZXJzLFxuICAgICAgaGlkZUxpbmUsXG4gICAgICB2YWx1ZSxcbiAgICAgIG92ZXJyaWRlcyxcbiAgICAgIHNob3csXG4gICAgICB0aXRsZUNvbHVtbixcbiAgICAgIGRlc2NyaXB0aW9uQ29sdW1ucyxcbiAgICAgIHRpbWVDb2x1bW4sXG4gICAgICBpbnRlcnZhbEVuZENvbHVtbixcbiAgICAgIHZpelR5cGUsXG4gICAgfSA9IHByb3BzO1xuXG4gICAgLy8gT25seSBhbGxvdyBvdmVycmlkZSB3aG9sZSB0aW1lX3JhbmdlXG4gICAgaWYgKCdzaW5jZScgaW4gb3ZlcnJpZGVzIHx8ICd1bnRpbCcgaW4gb3ZlcnJpZGVzKSB7XG4gICAgICBvdmVycmlkZXMudGltZV9yYW5nZSA9IG51bGw7XG4gICAgICBkZWxldGUgb3ZlcnJpZGVzLnNpbmNlO1xuICAgICAgZGVsZXRlIG92ZXJyaWRlcy51bnRpbDtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBhbm5vdGF0aW9uVHlwZSBpcyBzdXBwb3J0ZWQgYnkgdGhpcyBjaGFydFxuICAgIGNvbnN0IG1ldGFkYXRhID0gZ2V0Q2hhcnRNZXRhZGF0YVJlZ2lzdHJ5KCkuZ2V0KHZpelR5cGUpO1xuICAgIGNvbnN0IHN1cHBvcnRlZEFubm90YXRpb25UeXBlcyA9IG1ldGFkYXRhPy5zdXBwb3J0ZWRBbm5vdGF0aW9uVHlwZXMgfHwgW107XG4gICAgY29uc3QgdmFsaWRBbm5vdGF0aW9uVHlwZSA9IHN1cHBvcnRlZEFubm90YXRpb25UeXBlcy5pbmNsdWRlcyhcbiAgICAgIGFubm90YXRpb25UeXBlLFxuICAgIClcbiAgICAgID8gYW5ub3RhdGlvblR5cGVcbiAgICAgIDogc3VwcG9ydGVkQW5ub3RhdGlvblR5cGVzWzBdO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIC8vIGJhc2VcbiAgICAgIG5hbWUsXG4gICAgICBhbm5vdGF0aW9uVHlwZTogdmFsaWRBbm5vdGF0aW9uVHlwZSxcbiAgICAgIHNvdXJjZVR5cGUsXG4gICAgICB2YWx1ZSxcbiAgICAgIG92ZXJyaWRlcyxcbiAgICAgIHNob3csXG4gICAgICAvLyBzbGljZVxuICAgICAgdGl0bGVDb2x1bW4sXG4gICAgICBkZXNjcmlwdGlvbkNvbHVtbnMsXG4gICAgICB0aW1lQ29sdW1uLFxuICAgICAgaW50ZXJ2YWxFbmRDb2x1bW4sXG4gICAgICAvLyBkaXNwbGF5XG4gICAgICBjb2xvcjogY29sb3IgfHwgQVVUT01BVElDX0NPTE9SLFxuICAgICAgb3BhY2l0eSxcbiAgICAgIHN0eWxlLFxuICAgICAgd2lkdGgsXG4gICAgICBzaG93TWFya2VycyxcbiAgICAgIGhpZGVMaW5lLFxuICAgICAgLy8gcmVmRGF0YVxuICAgICAgaXNOZXc6ICFuYW1lLFxuICAgICAgaXNMb2FkaW5nT3B0aW9uczogdHJ1ZSxcbiAgICAgIHZhbHVlT3B0aW9uczogW10sXG4gICAgfTtcbiAgICB0aGlzLnN1Ym1pdEFubm90YXRpb24gPSB0aGlzLnN1Ym1pdEFubm90YXRpb24uYmluZCh0aGlzKTtcbiAgICB0aGlzLmRlbGV0ZUFubm90YXRpb24gPSB0aGlzLmRlbGV0ZUFubm90YXRpb24uYmluZCh0aGlzKTtcbiAgICB0aGlzLmFwcGx5QW5ub3RhdGlvbiA9IHRoaXMuYXBwbHlBbm5vdGF0aW9uLmJpbmQodGhpcyk7XG4gICAgdGhpcy5mZXRjaE9wdGlvbnMgPSB0aGlzLmZldGNoT3B0aW9ucy5iaW5kKHRoaXMpO1xuICAgIHRoaXMuaGFuZGxlQW5ub3RhdGlvblR5cGUgPSB0aGlzLmhhbmRsZUFubm90YXRpb25UeXBlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5oYW5kbGVBbm5vdGF0aW9uU291cmNlVHlwZSA9IHRoaXMuaGFuZGxlQW5ub3RhdGlvblNvdXJjZVR5cGUuYmluZChcbiAgICAgIHRoaXMsXG4gICAgKTtcbiAgICB0aGlzLmhhbmRsZVZhbHVlID0gdGhpcy5oYW5kbGVWYWx1ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuaXNWYWxpZEZvcm0gPSB0aGlzLmlzVmFsaWRGb3JtLmJpbmQodGhpcyk7XG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBjb25zdCB7IGFubm90YXRpb25UeXBlLCBzb3VyY2VUeXBlLCBpc0xvYWRpbmdPcHRpb25zIH0gPSB0aGlzLnN0YXRlO1xuICAgIHRoaXMuZmV0Y2hPcHRpb25zKGFubm90YXRpb25UeXBlLCBzb3VyY2VUeXBlLCBpc0xvYWRpbmdPcHRpb25zKTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSkge1xuICAgIGlmIChwcmV2U3RhdGUuc291cmNlVHlwZSAhPT0gdGhpcy5zdGF0ZS5zb3VyY2VUeXBlKSB7XG4gICAgICB0aGlzLmZldGNoT3B0aW9ucyh0aGlzLnN0YXRlLmFubm90YXRpb25UeXBlLCB0aGlzLnN0YXRlLnNvdXJjZVR5cGUsIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIGdldFN1cHBvcnRlZFNvdXJjZVR5cGVzKGFubm90YXRpb25UeXBlKSB7XG4gICAgLy8gR2V0IHZpcyB0eXBlcyB0aGF0IGNhbiBiZSBzb3VyY2UuXG4gICAgY29uc3Qgc291cmNlcyA9IGdldENoYXJ0TWV0YWRhdGFSZWdpc3RyeSgpXG4gICAgICAuZW50cmllcygpXG4gICAgICAuZmlsdGVyKCh7IHZhbHVlOiBjaGFydE1ldGFkYXRhIH0pID0+XG4gICAgICAgIGNoYXJ0TWV0YWRhdGEuY2FuQmVBbm5vdGF0aW9uVHlwZShhbm5vdGF0aW9uVHlwZSksXG4gICAgICApXG4gICAgICAubWFwKCh7IGtleSwgdmFsdWU6IGNoYXJ0TWV0YWRhdGEgfSkgPT4gKHtcbiAgICAgICAgdmFsdWU6IGtleSxcbiAgICAgICAgbGFiZWw6IGNoYXJ0TWV0YWRhdGEubmFtZSxcbiAgICAgIH0pKTtcbiAgICAvLyBQcmVwZW5kIG5hdGl2ZSBzb3VyY2UgaWYgYXBwbGljYWJsZVxuICAgIGlmIChBTk5PVEFUSU9OX1RZUEVTX01FVEFEQVRBW2Fubm90YXRpb25UeXBlXT8uc3VwcG9ydE5hdGl2ZVNvdXJjZSkge1xuICAgICAgc291cmNlcy51bnNoaWZ0KEFOTk9UQVRJT05fU09VUkNFX1RZUEVTX01FVEFEQVRBLk5BVElWRSk7XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2VzO1xuICB9XG5cbiAgaXNWYWxpZEZvcm11bGFBbm5vdGF0aW9uKGV4cHJlc3Npb24sIGFubm90YXRpb25UeXBlKSB7XG4gICAgaWYgKGFubm90YXRpb25UeXBlID09PSBBTk5PVEFUSU9OX1RZUEVTLkZPUk1VTEEpIHtcbiAgICAgIHJldHVybiBpc1ZhbGlkRXhwcmVzc2lvbihleHByZXNzaW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpc1ZhbGlkRm9ybSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBuYW1lLFxuICAgICAgYW5ub3RhdGlvblR5cGUsXG4gICAgICBzb3VyY2VUeXBlLFxuICAgICAgdmFsdWUsXG4gICAgICB0aW1lQ29sdW1uLFxuICAgICAgaW50ZXJ2YWxFbmRDb2x1bW4sXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgZXJyb3JzID0gW1xuICAgICAgdmFsaWRhdGVOb25FbXB0eShuYW1lKSxcbiAgICAgIHZhbGlkYXRlTm9uRW1wdHkoYW5ub3RhdGlvblR5cGUpLFxuICAgICAgdmFsaWRhdGVOb25FbXB0eSh2YWx1ZSksXG4gICAgXTtcbiAgICBpZiAoc291cmNlVHlwZSAhPT0gQU5OT1RBVElPTl9TT1VSQ0VfVFlQRVMuTkFUSVZFKSB7XG4gICAgICBpZiAoYW5ub3RhdGlvblR5cGUgPT09IEFOTk9UQVRJT05fVFlQRVMuRVZFTlQpIHtcbiAgICAgICAgZXJyb3JzLnB1c2godmFsaWRhdGVOb25FbXB0eSh0aW1lQ29sdW1uKSk7XG4gICAgICB9XG4gICAgICBpZiAoYW5ub3RhdGlvblR5cGUgPT09IEFOTk9UQVRJT05fVFlQRVMuSU5URVJWQUwpIHtcbiAgICAgICAgZXJyb3JzLnB1c2godmFsaWRhdGVOb25FbXB0eSh0aW1lQ29sdW1uKSk7XG4gICAgICAgIGVycm9ycy5wdXNoKHZhbGlkYXRlTm9uRW1wdHkoaW50ZXJ2YWxFbmRDb2x1bW4pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZXJyb3JzLnB1c2goIXRoaXMuaXNWYWxpZEZvcm11bGFBbm5vdGF0aW9uKHZhbHVlLCBhbm5vdGF0aW9uVHlwZSkpO1xuICAgIHJldHVybiAhZXJyb3JzLmZpbHRlcih4ID0+IHgpLmxlbmd0aDtcbiAgfVxuXG4gIGhhbmRsZUFubm90YXRpb25UeXBlKGFubm90YXRpb25UeXBlKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBhbm5vdGF0aW9uVHlwZSxcbiAgICAgIHNvdXJjZVR5cGU6IG51bGwsXG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICB9KTtcbiAgfVxuXG4gIGhhbmRsZUFubm90YXRpb25Tb3VyY2VUeXBlKHNvdXJjZVR5cGUpIHtcbiAgICBjb25zdCB7IHNvdXJjZVR5cGU6IHByZXZTb3VyY2VUeXBlIH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgaWYgKHByZXZTb3VyY2VUeXBlICE9PSBzb3VyY2VUeXBlKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgc291cmNlVHlwZSwgdmFsdWU6IG51bGwsIGlzTG9hZGluZ09wdGlvbnM6IHRydWUgfSk7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlVmFsdWUodmFsdWUpIHtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHZhbHVlLFxuICAgICAgZGVzY3JpcHRpb25Db2x1bW5zOiBbXSxcbiAgICAgIGludGVydmFsRW5kQ29sdW1uOiBudWxsLFxuICAgICAgdGltZUNvbHVtbjogbnVsbCxcbiAgICAgIHRpdGxlQ29sdW1uOiBudWxsLFxuICAgICAgb3ZlcnJpZGVzOiB7IHRpbWVfcmFuZ2U6IG51bGwgfSxcbiAgICB9KTtcbiAgfVxuXG4gIGZldGNoT3B0aW9ucyhhbm5vdGF0aW9uVHlwZSwgc291cmNlVHlwZSwgaXNMb2FkaW5nT3B0aW9ucykge1xuICAgIGlmIChpc0xvYWRpbmdPcHRpb25zKSB7XG4gICAgICBpZiAoc291cmNlVHlwZSA9PT0gQU5OT1RBVElPTl9TT1VSQ0VfVFlQRVMuTkFUSVZFKSB7XG4gICAgICAgIFN1cGVyc2V0Q2xpZW50LmdldCh7XG4gICAgICAgICAgZW5kcG9pbnQ6ICcvYW5ub3RhdGlvbmxheWVybW9kZWx2aWV3L2FwaS9yZWFkPycsXG4gICAgICAgIH0pLnRoZW4oKHsganNvbiB9KSA9PiB7XG4gICAgICAgICAgY29uc3QgbGF5ZXJzID0ganNvblxuICAgICAgICAgICAgPyBqc29uLnJlc3VsdC5tYXAobGF5ZXIgPT4gKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbGF5ZXIuaWQsXG4gICAgICAgICAgICAgICAgbGFiZWw6IGxheWVyLm5hbWUsXG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgOiBbXTtcbiAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGlzTG9hZGluZ09wdGlvbnM6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWVPcHRpb25zOiBsYXllcnMsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChyZXF1aXJlc1F1ZXJ5KHNvdXJjZVR5cGUpKSB7XG4gICAgICAgIFN1cGVyc2V0Q2xpZW50LmdldCh7IGVuZHBvaW50OiAnL3N1cGVyc2V0L3VzZXJfc2xpY2VzJyB9KS50aGVuKFxuICAgICAgICAgICh7IGpzb24gfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVnaXN0cnkgPSBnZXRDaGFydE1ldGFkYXRhUmVnaXN0cnkoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICBpc0xvYWRpbmdPcHRpb25zOiBmYWxzZSxcbiAgICAgICAgICAgICAgdmFsdWVPcHRpb25zOiBqc29uXG4gICAgICAgICAgICAgICAgLmZpbHRlcih4ID0+IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gcmVnaXN0cnkuZ2V0KHgudml6X3R5cGUpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGEgJiYgbWV0YWRhdGEuY2FuQmVBbm5vdGF0aW9uVHlwZShhbm5vdGF0aW9uVHlwZSlcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAubWFwKHggPT4gKHsgdmFsdWU6IHguaWQsIGxhYmVsOiB4LnRpdGxlLCBzbGljZTogeCB9KSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgaXNMb2FkaW5nT3B0aW9uczogZmFsc2UsXG4gICAgICAgICAgdmFsdWVPcHRpb25zOiBbXSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZGVsZXRlQW5ub3RhdGlvbigpIHtcbiAgICB0aGlzLnByb3BzLnJlbW92ZUFubm90YXRpb25MYXllcigpO1xuICAgIHRoaXMucHJvcHMuY2xvc2UoKTtcbiAgfVxuXG4gIGFwcGx5QW5ub3RhdGlvbigpIHtcbiAgICBpZiAodGhpcy5pc1ZhbGlkRm9ybSgpKSB7XG4gICAgICBjb25zdCBhbm5vdGF0aW9uRmllbGRzID0gW1xuICAgICAgICAnbmFtZScsXG4gICAgICAgICdhbm5vdGF0aW9uVHlwZScsXG4gICAgICAgICdzb3VyY2VUeXBlJyxcbiAgICAgICAgJ2NvbG9yJyxcbiAgICAgICAgJ29wYWNpdHknLFxuICAgICAgICAnc3R5bGUnLFxuICAgICAgICAnd2lkdGgnLFxuICAgICAgICAnc2hvd01hcmtlcnMnLFxuICAgICAgICAnaGlkZUxpbmUnLFxuICAgICAgICAndmFsdWUnLFxuICAgICAgICAnb3ZlcnJpZGVzJyxcbiAgICAgICAgJ3Nob3cnLFxuICAgICAgICAndGl0bGVDb2x1bW4nLFxuICAgICAgICAnZGVzY3JpcHRpb25Db2x1bW5zJyxcbiAgICAgICAgJ3RpbWVDb2x1bW4nLFxuICAgICAgICAnaW50ZXJ2YWxFbmRDb2x1bW4nLFxuICAgICAgXTtcbiAgICAgIGNvbnN0IG5ld0Fubm90YXRpb24gPSB7fTtcbiAgICAgIGFubm90YXRpb25GaWVsZHMuZm9yRWFjaChmaWVsZCA9PiB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlW2ZpZWxkXSAhPT0gbnVsbCkge1xuICAgICAgICAgIG5ld0Fubm90YXRpb25bZmllbGRdID0gdGhpcy5zdGF0ZVtmaWVsZF07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAobmV3QW5ub3RhdGlvbi5jb2xvciA9PT0gQVVUT01BVElDX0NPTE9SKSB7XG4gICAgICAgIG5ld0Fubm90YXRpb24uY29sb3IgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnByb3BzLmFkZEFubm90YXRpb25MYXllcihuZXdBbm5vdGF0aW9uKTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBpc05ldzogZmFsc2UgfSk7XG4gICAgfVxuICB9XG5cbiAgc3VibWl0QW5ub3RhdGlvbigpIHtcbiAgICB0aGlzLmFwcGx5QW5ub3RhdGlvbigpO1xuICAgIHRoaXMucHJvcHMuY2xvc2UoKTtcbiAgfVxuXG4gIHJlbmRlck9wdGlvbihvcHRpb24pIHtcbiAgICByZXR1cm4gKFxuICAgICAgPHNwYW5cbiAgICAgICAgY3NzPXt7XG4gICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgICAgIHRleHRPdmVyZmxvdzogJ2VsbGlwc2lzJyxcbiAgICAgICAgICB3aGl0ZVNwYWNlOiAnbm93cmFwJyxcbiAgICAgICAgfX1cbiAgICAgICAgdGl0bGU9e29wdGlvbi5sYWJlbH1cbiAgICAgID5cbiAgICAgICAge29wdGlvbi5sYWJlbH1cbiAgICAgIDwvc3Bhbj5cbiAgICApO1xuICB9XG5cbiAgcmVuZGVyVmFsdWVDb25maWd1cmF0aW9uKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGFubm90YXRpb25UeXBlLFxuICAgICAgc291cmNlVHlwZSxcbiAgICAgIHZhbHVlLFxuICAgICAgdmFsdWVPcHRpb25zLFxuICAgICAgaXNMb2FkaW5nT3B0aW9ucyxcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBsZXQgbGFiZWwgPSAnJztcbiAgICBsZXQgZGVzY3JpcHRpb24gPSAnJztcbiAgICBpZiAocmVxdWlyZXNRdWVyeShzb3VyY2VUeXBlKSkge1xuICAgICAgaWYgKHNvdXJjZVR5cGUgPT09IEFOTk9UQVRJT05fU09VUkNFX1RZUEVTLk5BVElWRSkge1xuICAgICAgICBsYWJlbCA9ICdBbm5vdGF0aW9uIGxheWVyJztcbiAgICAgICAgZGVzY3JpcHRpb24gPSAnU2VsZWN0IHRoZSBBbm5vdGF0aW9uIExheWVyIHlvdSB3b3VsZCBsaWtlIHRvIHVzZS4nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGFiZWwgPSB0KCdDaGFydCcpO1xuICAgICAgICBkZXNjcmlwdGlvbiA9IGBVc2UgYSBwcmUgZGVmaW5lZCBTdXBlcnNldCBDaGFydCBhcyBhIHNvdXJjZSBmb3IgYW5ub3RhdGlvbnMgYW5kIG92ZXJsYXlzLlxuICAgICAgICB5b3VyIGNoYXJ0IG11c3QgYmUgb25lIG9mIHRoZXNlIHZpc3VhbGl6YXRpb24gdHlwZXM6XG4gICAgICAgIFske3RoaXMuZ2V0U3VwcG9ydGVkU291cmNlVHlwZXMoYW5ub3RhdGlvblR5cGUpXG4gICAgICAgICAgLm1hcCh4ID0+IHgubGFiZWwpXG4gICAgICAgICAgLmpvaW4oJywgJyl9XWA7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhbm5vdGF0aW9uVHlwZSA9PT0gQU5OT1RBVElPTl9UWVBFUy5GT1JNVUxBKSB7XG4gICAgICBsYWJlbCA9ICdGb3JtdWxhJztcbiAgICAgIGRlc2NyaXB0aW9uID0gYEV4cGVjdHMgYSBmb3JtdWxhIHdpdGggZGVwZW5kaW5nIHRpbWUgcGFyYW1ldGVyICd4J1xuICAgICAgICBpbiBtaWxsaXNlY29uZHMgc2luY2UgZXBvY2guIG1hdGhqcyBpcyB1c2VkIHRvIGV2YWx1YXRlIHRoZSBmb3JtdWxhcy5cbiAgICAgICAgRXhhbXBsZTogJzJ4KzUnYDtcbiAgICB9XG4gICAgaWYgKHJlcXVpcmVzUXVlcnkoc291cmNlVHlwZSkpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxTZWxlY3RDb250cm9sXG4gICAgICAgICAgYXJpYUxhYmVsPXt0KCdBbm5vdGF0aW9uIGxheWVyIHZhbHVlJyl9XG4gICAgICAgICAgbmFtZT1cImFubm90YXRpb24tbGF5ZXItdmFsdWVcIlxuICAgICAgICAgIHNob3dIZWFkZXJcbiAgICAgICAgICBob3ZlcmVkXG4gICAgICAgICAgZGVzY3JpcHRpb249e2Rlc2NyaXB0aW9ufVxuICAgICAgICAgIGxhYmVsPXtsYWJlbH1cbiAgICAgICAgICBwbGFjZWhvbGRlcj1cIlwiXG4gICAgICAgICAgb3B0aW9ucz17dmFsdWVPcHRpb25zfVxuICAgICAgICAgIGlzTG9hZGluZz17aXNMb2FkaW5nT3B0aW9uc31cbiAgICAgICAgICB2YWx1ZT17dmFsdWV9XG4gICAgICAgICAgb25DaGFuZ2U9e3RoaXMuaGFuZGxlVmFsdWV9XG4gICAgICAgICAgdmFsaWRhdGlvbkVycm9ycz17IXZhbHVlID8gWydNYW5kYXRvcnknXSA6IFtdfVxuICAgICAgICAgIG9wdGlvblJlbmRlcmVyPXt0aGlzLnJlbmRlck9wdGlvbn1cbiAgICAgICAgLz5cbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChhbm5vdGF0aW9uVHlwZSA9PT0gQU5OT1RBVElPTl9UWVBFUy5GT1JNVUxBKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8VGV4dENvbnRyb2xcbiAgICAgICAgICBuYW1lPVwiYW5ub3RhdGlvbi1sYXllci12YWx1ZVwiXG4gICAgICAgICAgaG92ZXJlZFxuICAgICAgICAgIHNob3dIZWFkZXJcbiAgICAgICAgICBkZXNjcmlwdGlvbj17ZGVzY3JpcHRpb259XG4gICAgICAgICAgbGFiZWw9e2xhYmVsfVxuICAgICAgICAgIHBsYWNlaG9sZGVyPVwiXCJcbiAgICAgICAgICB2YWx1ZT17dmFsdWV9XG4gICAgICAgICAgb25DaGFuZ2U9e3RoaXMuaGFuZGxlVmFsdWV9XG4gICAgICAgICAgdmFsaWRhdGlvbkVycm9ycz17XG4gICAgICAgICAgICAhdGhpcy5pc1ZhbGlkRm9ybXVsYUFubm90YXRpb24odmFsdWUsIGFubm90YXRpb25UeXBlKVxuICAgICAgICAgICAgICA/IFsnQmFkIGZvcm11bGEuJ11cbiAgICAgICAgICAgICAgOiBbXVxuICAgICAgICAgIH1cbiAgICAgICAgLz5cbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHJlbmRlclNsaWNlQ29uZmlndXJhdGlvbigpIHtcbiAgICBjb25zdCB7XG4gICAgICBhbm5vdGF0aW9uVHlwZSxcbiAgICAgIHNvdXJjZVR5cGUsXG4gICAgICB2YWx1ZSxcbiAgICAgIHZhbHVlT3B0aW9ucyxcbiAgICAgIG92ZXJyaWRlcyxcbiAgICAgIHRpdGxlQ29sdW1uLFxuICAgICAgdGltZUNvbHVtbixcbiAgICAgIGludGVydmFsRW5kQ29sdW1uLFxuICAgICAgZGVzY3JpcHRpb25Db2x1bW5zLFxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHsgc2xpY2UgfSA9IHZhbHVlT3B0aW9ucy5maW5kKHggPT4geC52YWx1ZSA9PT0gdmFsdWUpIHx8IHt9O1xuICAgIGlmIChzb3VyY2VUeXBlICE9PSBBTk5PVEFUSU9OX1NPVVJDRV9UWVBFUy5OQVRJVkUgJiYgc2xpY2UpIHtcbiAgICAgIGNvbnN0IGNvbHVtbnMgPSAoc2xpY2UuZGF0YS5ncm91cGJ5IHx8IFtdKVxuICAgICAgICAuY29uY2F0KHNsaWNlLmRhdGEuYWxsX2NvbHVtbnMgfHwgW10pXG4gICAgICAgIC5tYXAoeCA9PiAoeyB2YWx1ZTogeCwgbGFiZWw6IHggfSkpO1xuICAgICAgY29uc3QgdGltZUNvbHVtbk9wdGlvbnMgPSBzbGljZS5kYXRhLmluY2x1ZGVfdGltZVxuICAgICAgICA/IFt7IHZhbHVlOiAnX190aW1lc3RhbXAnLCBsYWJlbDogJ19fdGltZXN0YW1wJyB9XS5jb25jYXQoY29sdW1ucylcbiAgICAgICAgOiBjb2x1bW5zO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgPGRpdiBzdHlsZT17eyBtYXJnaW5SaWdodDogJzJyZW0nIH19PlxuICAgICAgICAgIDxQb3BvdmVyU2VjdGlvblxuICAgICAgICAgICAgaXNTZWxlY3RlZFxuICAgICAgICAgICAgdGl0bGU9e3QoJ0Fubm90YXRpb24gU2xpY2UgQ29uZmlndXJhdGlvbicpfVxuICAgICAgICAgICAgaW5mbz17dChgVGhpcyBzZWN0aW9uIGFsbG93cyB5b3UgdG8gY29uZmlndXJlIGhvdyB0byB1c2UgdGhlIHNsaWNlXG4gICAgICAgICAgICAgICB0byBnZW5lcmF0ZSBhbm5vdGF0aW9ucy5gKX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICB7KGFubm90YXRpb25UeXBlID09PSBBTk5PVEFUSU9OX1RZUEVTLkVWRU5UIHx8XG4gICAgICAgICAgICAgIGFubm90YXRpb25UeXBlID09PSBBTk5PVEFUSU9OX1RZUEVTLklOVEVSVkFMKSAmJiAoXG4gICAgICAgICAgICAgIDxTZWxlY3RDb250cm9sXG4gICAgICAgICAgICAgICAgYXJpYUxhYmVsPXt0KCdBbm5vdGF0aW9uIGxheWVyIHRpbWUgY29sdW1uJyl9XG4gICAgICAgICAgICAgICAgaG92ZXJlZFxuICAgICAgICAgICAgICAgIG5hbWU9XCJhbm5vdGF0aW9uLWxheWVyLXRpbWUtY29sdW1uXCJcbiAgICAgICAgICAgICAgICBsYWJlbD17XG4gICAgICAgICAgICAgICAgICBhbm5vdGF0aW9uVHlwZSA9PT0gQU5OT1RBVElPTl9UWVBFUy5JTlRFUlZBTFxuICAgICAgICAgICAgICAgICAgICA/IHQoJ0ludGVydmFsIHN0YXJ0IGNvbHVtbicpXG4gICAgICAgICAgICAgICAgICAgIDogdCgnRXZlbnQgdGltZSBjb2x1bW4nKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbj17dChcbiAgICAgICAgICAgICAgICAgICdUaGlzIGNvbHVtbiBtdXN0IGNvbnRhaW4gZGF0ZS90aW1lIGluZm9ybWF0aW9uLicsXG4gICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICB2YWxpZGF0aW9uRXJyb3JzPXshdGltZUNvbHVtbiA/IFsnTWFuZGF0b3J5J10gOiBbXX1cbiAgICAgICAgICAgICAgICBjbGVhcmFibGU9e2ZhbHNlfVxuICAgICAgICAgICAgICAgIG9wdGlvbnM9e3RpbWVDb2x1bW5PcHRpb25zfVxuICAgICAgICAgICAgICAgIHZhbHVlPXt0aW1lQ29sdW1ufVxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXt2ID0+IHRoaXMuc2V0U3RhdGUoeyB0aW1lQ29sdW1uOiB2IH0pfVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIHthbm5vdGF0aW9uVHlwZSA9PT0gQU5OT1RBVElPTl9UWVBFUy5JTlRFUlZBTCAmJiAoXG4gICAgICAgICAgICAgIDxTZWxlY3RDb250cm9sXG4gICAgICAgICAgICAgICAgYXJpYUxhYmVsPXt0KCdBbm5vdGF0aW9uIGxheWVyIGludGVydmFsIGVuZCcpfVxuICAgICAgICAgICAgICAgIGhvdmVyZWRcbiAgICAgICAgICAgICAgICBuYW1lPVwiYW5ub3RhdGlvbi1sYXllci1pbnRlcnZhbEVuZFwiXG4gICAgICAgICAgICAgICAgbGFiZWw9e3QoJ0ludGVydmFsIEVuZCBjb2x1bW4nKX1cbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbj17dChcbiAgICAgICAgICAgICAgICAgICdUaGlzIGNvbHVtbiBtdXN0IGNvbnRhaW4gZGF0ZS90aW1lIGluZm9ybWF0aW9uLicsXG4gICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICB2YWxpZGF0aW9uRXJyb3JzPXshaW50ZXJ2YWxFbmRDb2x1bW4gPyBbJ01hbmRhdG9yeSddIDogW119XG4gICAgICAgICAgICAgICAgb3B0aW9ucz17Y29sdW1uc31cbiAgICAgICAgICAgICAgICB2YWx1ZT17aW50ZXJ2YWxFbmRDb2x1bW59XG4gICAgICAgICAgICAgICAgb25DaGFuZ2U9e3ZhbHVlID0+IHRoaXMuc2V0U3RhdGUoeyBpbnRlcnZhbEVuZENvbHVtbjogdmFsdWUgfSl9XG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICApfVxuICAgICAgICAgICAgPFNlbGVjdENvbnRyb2xcbiAgICAgICAgICAgICAgYXJpYUxhYmVsPXt0KCdBbm5vdGF0aW9uIGxheWVyIHRpdGxlIGNvbHVtbicpfVxuICAgICAgICAgICAgICBob3ZlcmVkXG4gICAgICAgICAgICAgIG5hbWU9XCJhbm5vdGF0aW9uLWxheWVyLXRpdGxlXCJcbiAgICAgICAgICAgICAgbGFiZWw9e3QoJ1RpdGxlIENvbHVtbicpfVxuICAgICAgICAgICAgICBkZXNjcmlwdGlvbj17dCgnUGljayBhIHRpdGxlIGZvciB5b3UgYW5ub3RhdGlvbi4nKX1cbiAgICAgICAgICAgICAgb3B0aW9ucz17W3sgdmFsdWU6ICcnLCBsYWJlbDogJ05vbmUnIH1dLmNvbmNhdChjb2x1bW5zKX1cbiAgICAgICAgICAgICAgdmFsdWU9e3RpdGxlQ29sdW1ufVxuICAgICAgICAgICAgICBvbkNoYW5nZT17dmFsdWUgPT4gdGhpcy5zZXRTdGF0ZSh7IHRpdGxlQ29sdW1uOiB2YWx1ZSB9KX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICB7YW5ub3RhdGlvblR5cGUgIT09IEFOTk9UQVRJT05fVFlQRVMuVElNRV9TRVJJRVMgJiYgKFxuICAgICAgICAgICAgICA8U2VsZWN0Q29udHJvbFxuICAgICAgICAgICAgICAgIGFyaWFMYWJlbD17dCgnQW5ub3RhdGlvbiBsYXllciBkZXNjcmlwdGlvbiBjb2x1bW5zJyl9XG4gICAgICAgICAgICAgICAgaG92ZXJlZFxuICAgICAgICAgICAgICAgIG5hbWU9XCJhbm5vdGF0aW9uLWxheWVyLXRpdGxlXCJcbiAgICAgICAgICAgICAgICBsYWJlbD17dCgnRGVzY3JpcHRpb24gQ29sdW1ucycpfVxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uPXt0KFxuICAgICAgICAgICAgICAgICAgXCJQaWNrIG9uZSBvciBtb3JlIGNvbHVtbnMgdGhhdCBzaG91bGQgYmUgc2hvd24gaW4gdGhlIGFubm90YXRpb24uIElmIHlvdSBkb24ndCBzZWxlY3QgYSBjb2x1bW4gYWxsIG9mIHRoZW0gd2lsbCBiZSBzaG93bi5cIixcbiAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgIG11bHRpXG4gICAgICAgICAgICAgICAgb3B0aW9ucz17Y29sdW1uc31cbiAgICAgICAgICAgICAgICB2YWx1ZT17ZGVzY3JpcHRpb25Db2x1bW5zfVxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXt2YWx1ZSA9PiB0aGlzLnNldFN0YXRlKHsgZGVzY3JpcHRpb25Db2x1bW5zOiB2YWx1ZSB9KX1cbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICl9XG4gICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IG1hcmdpblRvcDogJzFyZW0nIH19PlxuICAgICAgICAgICAgICA8Q2hlY2tib3hDb250cm9sXG4gICAgICAgICAgICAgICAgaG92ZXJlZFxuICAgICAgICAgICAgICAgIG5hbWU9XCJhbm5vdGF0aW9uLW92ZXJyaWRlLXRpbWVfcmFuZ2VcIlxuICAgICAgICAgICAgICAgIGxhYmVsPVwiT3ZlcnJpZGUgdGltZSByYW5nZVwiXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb249e2BUaGlzIGNvbnRyb2xzIHdoZXRoZXIgdGhlIFwidGltZV9yYW5nZVwiIGZpZWxkIGZyb20gdGhlIGN1cnJlbnRcbiAgICAgICAgICAgICAgICAgIHZpZXcgc2hvdWxkIGJlIHBhc3NlZCBkb3duIHRvIHRoZSBjaGFydCBjb250YWluaW5nIHRoZSBhbm5vdGF0aW9uIGRhdGEuYH1cbiAgICAgICAgICAgICAgICB2YWx1ZT17J3RpbWVfcmFuZ2UnIGluIG92ZXJyaWRlc31cbiAgICAgICAgICAgICAgICBvbkNoYW5nZT17diA9PiB7XG4gICAgICAgICAgICAgICAgICBkZWxldGUgb3ZlcnJpZGVzLnRpbWVfcmFuZ2U7XG4gICAgICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICBvdmVycmlkZXM6IHsgLi4ub3ZlcnJpZGVzLCB0aW1lX3JhbmdlOiBudWxsIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IG92ZXJyaWRlczogeyAuLi5vdmVycmlkZXMgfSB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICA8Q2hlY2tib3hDb250cm9sXG4gICAgICAgICAgICAgICAgaG92ZXJlZFxuICAgICAgICAgICAgICAgIG5hbWU9XCJhbm5vdGF0aW9uLW92ZXJyaWRlLXRpbWVncmFpblwiXG4gICAgICAgICAgICAgICAgbGFiZWw9XCJPdmVycmlkZSB0aW1lIGdyYWluXCJcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbj17YFRoaXMgY29udHJvbHMgd2hldGhlciB0aGUgdGltZSBncmFpbiBmaWVsZCBmcm9tIHRoZSBjdXJyZW50XG4gICAgICAgICAgICAgICAgICB2aWV3IHNob3VsZCBiZSBwYXNzZWQgZG93biB0byB0aGUgY2hhcnQgY29udGFpbmluZyB0aGUgYW5ub3RhdGlvbiBkYXRhLmB9XG4gICAgICAgICAgICAgICAgdmFsdWU9eyd0aW1lX2dyYWluX3NxbGEnIGluIG92ZXJyaWRlc31cbiAgICAgICAgICAgICAgICBvbkNoYW5nZT17diA9PiB7XG4gICAgICAgICAgICAgICAgICBkZWxldGUgb3ZlcnJpZGVzLnRpbWVfZ3JhaW5fc3FsYTtcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvdmVycmlkZXMuZ3JhbnVsYXJpdHk7XG4gICAgICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICBvdmVycmlkZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLm92ZXJyaWRlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVfZ3JhaW5fc3FsYTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYW51bGFyaXR5OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IG92ZXJyaWRlczogeyAuLi5vdmVycmlkZXMgfSB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICA8VGV4dENvbnRyb2xcbiAgICAgICAgICAgICAgICBob3ZlcmVkXG4gICAgICAgICAgICAgICAgbmFtZT1cImFubm90YXRpb24tbGF5ZXItdGltZXNoaWZ0XCJcbiAgICAgICAgICAgICAgICBsYWJlbD1cIlRpbWUgU2hpZnRcIlxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uPXtgVGltZSBkZWx0YSBpbiBuYXR1cmFsIGxhbmd1YWdlXG4gICAgICAgICAgICAgICAgICAoZXhhbXBsZTogIDI0IGhvdXJzLCA3IGRheXMsIDU2IHdlZWtzLCAzNjUgZGF5cylgfVxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiXCJcbiAgICAgICAgICAgICAgICB2YWx1ZT17b3ZlcnJpZGVzLnRpbWVfc2hpZnR9XG4gICAgICAgICAgICAgICAgb25DaGFuZ2U9e3YgPT5cbiAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBvdmVycmlkZXM6IHsgLi4ub3ZlcnJpZGVzLCB0aW1lX3NoaWZ0OiB2IH0gfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L1BvcG92ZXJTZWN0aW9uPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHJlbmRlckRpc3BsYXlDb25maWd1cmF0aW9uKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbG9yLFxuICAgICAgb3BhY2l0eSxcbiAgICAgIHN0eWxlLFxuICAgICAgd2lkdGgsXG4gICAgICBzaG93TWFya2VycyxcbiAgICAgIGhpZGVMaW5lLFxuICAgICAgYW5ub3RhdGlvblR5cGUsXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgY29sb3JTY2hlbWUgPSBnZXRDYXRlZ29yaWNhbFNjaGVtZVJlZ2lzdHJ5KClcbiAgICAgIC5nZXQodGhpcy5wcm9wcy5jb2xvclNjaGVtZSlcbiAgICAgIC5jb2xvcnMuY29uY2F0KCk7XG4gICAgaWYgKFxuICAgICAgY29sb3IgJiZcbiAgICAgIGNvbG9yICE9PSBBVVRPTUFUSUNfQ09MT1IgJiZcbiAgICAgICFjb2xvclNjaGVtZS5maW5kKHggPT4geC50b0xvd2VyQ2FzZSgpID09PSBjb2xvci50b0xvd2VyQ2FzZSgpKVxuICAgICkge1xuICAgICAgY29sb3JTY2hlbWUucHVzaChjb2xvcik7XG4gICAgfVxuICAgIHJldHVybiAoXG4gICAgICA8UG9wb3ZlclNlY3Rpb25cbiAgICAgICAgaXNTZWxlY3RlZFxuICAgICAgICB0aXRsZT17dCgnRGlzcGxheSBjb25maWd1cmF0aW9uJyl9XG4gICAgICAgIGluZm89e3QoJ0NvbmZpZ3VyZSB5b3VyIGhvdyB5b3Ugb3ZlcmxheSBpcyBkaXNwbGF5ZWQgaGVyZS4nKX1cbiAgICAgID5cbiAgICAgICAgPFNlbGVjdENvbnRyb2xcbiAgICAgICAgICBhcmlhTGFiZWw9e3QoJ0Fubm90YXRpb24gbGF5ZXIgc3Ryb2tlJyl9XG4gICAgICAgICAgbmFtZT1cImFubm90YXRpb24tbGF5ZXItc3Ryb2tlXCJcbiAgICAgICAgICBsYWJlbD17dCgnU3R5bGUnKX1cbiAgICAgICAgICAvLyBzZWUgJy4uLy4uLy4uL3Zpc3VhbGl6YXRpb25zL252ZDNfdmlzLmNzcydcbiAgICAgICAgICBvcHRpb25zPXtbXG4gICAgICAgICAgICB7IHZhbHVlOiAnc29saWQnLCBsYWJlbDogJ1NvbGlkJyB9LFxuICAgICAgICAgICAgeyB2YWx1ZTogJ2Rhc2hlZCcsIGxhYmVsOiAnRGFzaGVkJyB9LFxuICAgICAgICAgICAgeyB2YWx1ZTogJ2xvbmdEYXNoZWQnLCBsYWJlbDogJ0xvbmcgZGFzaGVkJyB9LFxuICAgICAgICAgICAgeyB2YWx1ZTogJ2RvdHRlZCcsIGxhYmVsOiAnRG90dGVkJyB9LFxuICAgICAgICAgIF19XG4gICAgICAgICAgdmFsdWU9e3N0eWxlfVxuICAgICAgICAgIGNsZWFyYWJsZT17ZmFsc2V9XG4gICAgICAgICAgb25DaGFuZ2U9e3YgPT4gdGhpcy5zZXRTdGF0ZSh7IHN0eWxlOiB2IH0pfVxuICAgICAgICAvPlxuICAgICAgICA8U2VsZWN0Q29udHJvbFxuICAgICAgICAgIGFyaWFMYWJlbD17dCgnQW5ub3RhdGlvbiBsYXllciBvcGFjaXR5Jyl9XG4gICAgICAgICAgbmFtZT1cImFubm90YXRpb24tbGF5ZXItb3BhY2l0eVwiXG4gICAgICAgICAgbGFiZWw9e3QoJ09wYWNpdHknKX1cbiAgICAgICAgICAvLyBzZWUgJy4uLy4uLy4uL3Zpc3VhbGl6YXRpb25zL252ZDNfdmlzLmNzcydcbiAgICAgICAgICBvcHRpb25zPXtbXG4gICAgICAgICAgICB7IHZhbHVlOiAnJywgbGFiZWw6ICdTb2xpZCcgfSxcbiAgICAgICAgICAgIHsgdmFsdWU6ICdvcGFjaXR5TG93JywgbGFiZWw6ICcwLjInIH0sXG4gICAgICAgICAgICB7IHZhbHVlOiAnb3BhY2l0eU1lZGl1bScsIGxhYmVsOiAnMC41JyB9LFxuICAgICAgICAgICAgeyB2YWx1ZTogJ29wYWNpdHlIaWdoJywgbGFiZWw6ICcwLjgnIH0sXG4gICAgICAgICAgXX1cbiAgICAgICAgICB2YWx1ZT17b3BhY2l0eX1cbiAgICAgICAgICBvbkNoYW5nZT17dmFsdWUgPT4gdGhpcy5zZXRTdGF0ZSh7IG9wYWNpdHk6IHZhbHVlIH0pfVxuICAgICAgICAvPlxuICAgICAgICA8ZGl2PlxuICAgICAgICAgIDxDb250cm9sSGVhZGVyIGxhYmVsPXt0KCdDb2xvcicpfSAvPlxuICAgICAgICAgIDxkaXYgc3R5bGU9e3sgZGlzcGxheTogJ2ZsZXgnLCBmbGV4RGlyZWN0aW9uOiAnY29sdW1uJyB9fT5cbiAgICAgICAgICAgIDxDb21wYWN0UGlja2VyXG4gICAgICAgICAgICAgIGNvbG9yPXtjb2xvcn1cbiAgICAgICAgICAgICAgY29sb3JzPXtjb2xvclNjaGVtZX1cbiAgICAgICAgICAgICAgb25DaGFuZ2VDb21wbGV0ZT17diA9PiB0aGlzLnNldFN0YXRlKHsgY29sb3I6IHYuaGV4IH0pfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDxCdXR0b25cbiAgICAgICAgICAgICAgc3R5bGU9e3sgbWFyZ2luVG9wOiAnMC41cmVtJywgbWFyZ2luQm90dG9tOiAnMC41cmVtJyB9fVxuICAgICAgICAgICAgICBidXR0b25TdHlsZT17Y29sb3IgPT09IEFVVE9NQVRJQ19DT0xPUiA/ICdzdWNjZXNzJyA6ICdkZWZhdWx0J31cbiAgICAgICAgICAgICAgYnV0dG9uU2l6ZT1cInhzbWFsbFwiXG4gICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHRoaXMuc2V0U3RhdGUoeyBjb2xvcjogQVVUT01BVElDX0NPTE9SIH0pfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICBBdXRvbWF0aWMgQ29sb3JcbiAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPFRleHRDb250cm9sXG4gICAgICAgICAgbmFtZT1cImFubm90YXRpb24tbGF5ZXItc3Ryb2tlLXdpZHRoXCJcbiAgICAgICAgICBsYWJlbD17dCgnTGluZSB3aWR0aCcpfVxuICAgICAgICAgIGlzSW50XG4gICAgICAgICAgdmFsdWU9e3dpZHRofVxuICAgICAgICAgIG9uQ2hhbmdlPXt2ID0+IHRoaXMuc2V0U3RhdGUoeyB3aWR0aDogdiB9KX1cbiAgICAgICAgLz5cbiAgICAgICAge2Fubm90YXRpb25UeXBlID09PSBBTk5PVEFUSU9OX1RZUEVTLlRJTUVfU0VSSUVTICYmIChcbiAgICAgICAgICA8Q2hlY2tib3hDb250cm9sXG4gICAgICAgICAgICBob3ZlcmVkXG4gICAgICAgICAgICBuYW1lPVwiYW5ub3RhdGlvbi1sYXllci1zaG93LW1hcmtlcnNcIlxuICAgICAgICAgICAgbGFiZWw9XCJTaG93IE1hcmtlcnNcIlxuICAgICAgICAgICAgZGVzY3JpcHRpb249XCJTaG93cyBvciBoaWRlcyBtYXJrZXJzIGZvciB0aGUgdGltZSBzZXJpZXNcIlxuICAgICAgICAgICAgdmFsdWU9e3Nob3dNYXJrZXJzfVxuICAgICAgICAgICAgb25DaGFuZ2U9e3YgPT4gdGhpcy5zZXRTdGF0ZSh7IHNob3dNYXJrZXJzOiB2IH0pfVxuICAgICAgICAgIC8+XG4gICAgICAgICl9XG4gICAgICAgIHthbm5vdGF0aW9uVHlwZSA9PT0gQU5OT1RBVElPTl9UWVBFUy5USU1FX1NFUklFUyAmJiAoXG4gICAgICAgICAgPENoZWNrYm94Q29udHJvbFxuICAgICAgICAgICAgaG92ZXJlZFxuICAgICAgICAgICAgbmFtZT1cImFubm90YXRpb24tbGF5ZXItaGlkZS1saW5lXCJcbiAgICAgICAgICAgIGxhYmVsPVwiSGlkZSBMaW5lXCJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uPVwiSGlkZXMgdGhlIExpbmUgZm9yIHRoZSB0aW1lIHNlcmllc1wiXG4gICAgICAgICAgICB2YWx1ZT17aGlkZUxpbmV9XG4gICAgICAgICAgICBvbkNoYW5nZT17diA9PiB0aGlzLnNldFN0YXRlKHsgaGlkZUxpbmU6IHYgfSl9XG4gICAgICAgICAgLz5cbiAgICAgICAgKX1cbiAgICAgIDwvUG9wb3ZlclNlY3Rpb24+XG4gICAgKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGlzTmV3LCBuYW1lLCBhbm5vdGF0aW9uVHlwZSwgc291cmNlVHlwZSwgc2hvdyB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBpc1ZhbGlkID0gdGhpcy5pc1ZhbGlkRm9ybSgpO1xuICAgIGNvbnN0IG1ldGFkYXRhID0gZ2V0Q2hhcnRNZXRhZGF0YVJlZ2lzdHJ5KCkuZ2V0KHRoaXMucHJvcHMudml6VHlwZSk7XG4gICAgY29uc3Qgc3VwcG9ydGVkQW5ub3RhdGlvblR5cGVzID0gbWV0YWRhdGFcbiAgICAgID8gbWV0YWRhdGEuc3VwcG9ydGVkQW5ub3RhdGlvblR5cGVzLm1hcChcbiAgICAgICAgICB0eXBlID0+IEFOTk9UQVRJT05fVFlQRVNfTUVUQURBVEFbdHlwZV0sXG4gICAgICAgIClcbiAgICAgIDogW107XG4gICAgY29uc3Qgc3VwcG9ydGVkU291cmNlVHlwZXMgPSB0aGlzLmdldFN1cHBvcnRlZFNvdXJjZVR5cGVzKGFubm90YXRpb25UeXBlKTtcblxuICAgIHJldHVybiAoXG4gICAgICA8PlxuICAgICAgICB7dGhpcy5wcm9wcy5lcnJvciAmJiAoXG4gICAgICAgICAgPHNwYW4gc3R5bGU9e3sgY29sb3I6ICdyZWQnIH19PkVSUk9SOiB7dGhpcy5wcm9wcy5lcnJvcn08L3NwYW4+XG4gICAgICAgICl9XG4gICAgICAgIDxkaXYgc3R5bGU9e3sgZGlzcGxheTogJ2ZsZXgnLCBmbGV4RGlyZWN0aW9uOiAncm93JyB9fT5cbiAgICAgICAgICA8ZGl2IHN0eWxlPXt7IG1hcmdpblJpZ2h0OiAnMnJlbScgfX0+XG4gICAgICAgICAgICA8UG9wb3ZlclNlY3Rpb25cbiAgICAgICAgICAgICAgaXNTZWxlY3RlZFxuICAgICAgICAgICAgICB0aXRsZT17dCgnTGF5ZXIgY29uZmlndXJhdGlvbicpfVxuICAgICAgICAgICAgICBpbmZvPXt0KCdDb25maWd1cmUgdGhlIGJhc2ljcyBvZiB5b3VyIEFubm90YXRpb24gTGF5ZXIuJyl9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIDxUZXh0Q29udHJvbFxuICAgICAgICAgICAgICAgIG5hbWU9XCJhbm5vdGF0aW9uLWxheWVyLW5hbWVcIlxuICAgICAgICAgICAgICAgIGxhYmVsPXt0KCdOYW1lJyl9XG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJcIlxuICAgICAgICAgICAgICAgIHZhbHVlPXtuYW1lfVxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXt2ID0+IHRoaXMuc2V0U3RhdGUoeyBuYW1lOiB2IH0pfVxuICAgICAgICAgICAgICAgIHZhbGlkYXRpb25FcnJvcnM9eyFuYW1lID8gW3QoJ01hbmRhdG9yeScpXSA6IFtdfVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICA8Q2hlY2tib3hDb250cm9sXG4gICAgICAgICAgICAgICAgbmFtZT1cImFubm90YXRpb24tbGF5ZXItaGlkZVwiXG4gICAgICAgICAgICAgICAgbGFiZWw9e3QoJ0hpZGUgbGF5ZXInKX1cbiAgICAgICAgICAgICAgICB2YWx1ZT17IXNob3d9XG4gICAgICAgICAgICAgICAgb25DaGFuZ2U9e3YgPT4gdGhpcy5zZXRTdGF0ZSh7IHNob3c6ICF2IH0pfVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICA8U2VsZWN0Q29udHJvbFxuICAgICAgICAgICAgICAgIGFyaWFMYWJlbD17dCgnQW5ub3RhdGlvbiBsYXllciB0eXBlJyl9XG4gICAgICAgICAgICAgICAgaG92ZXJlZFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uPXt0KCdDaG9vc2UgdGhlIGFubm90YXRpb24gbGF5ZXIgdHlwZScpfVxuICAgICAgICAgICAgICAgIGxhYmVsPXt0KCdBbm5vdGF0aW9uIGxheWVyIHR5cGUnKX1cbiAgICAgICAgICAgICAgICBuYW1lPVwiYW5ub3RhdGlvbi1sYXllci10eXBlXCJcbiAgICAgICAgICAgICAgICBjbGVhcmFibGU9e2ZhbHNlfVxuICAgICAgICAgICAgICAgIG9wdGlvbnM9e3N1cHBvcnRlZEFubm90YXRpb25UeXBlc31cbiAgICAgICAgICAgICAgICB2YWx1ZT17YW5ub3RhdGlvblR5cGV9XG4gICAgICAgICAgICAgICAgb25DaGFuZ2U9e3RoaXMuaGFuZGxlQW5ub3RhdGlvblR5cGV9XG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgIHtzdXBwb3J0ZWRTb3VyY2VUeXBlcy5sZW5ndGggPiAwICYmIChcbiAgICAgICAgICAgICAgICA8U2VsZWN0Q29udHJvbFxuICAgICAgICAgICAgICAgICAgYXJpYUxhYmVsPXt0KCdBbm5vdGF0aW9uIHNvdXJjZSB0eXBlJyl9XG4gICAgICAgICAgICAgICAgICBob3ZlcmVkXG4gICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbj17dCgnQ2hvb3NlIHRoZSBzb3VyY2Ugb2YgeW91ciBhbm5vdGF0aW9ucycpfVxuICAgICAgICAgICAgICAgICAgbGFiZWw9e3QoJ0Fubm90YXRpb24gU291cmNlJyl9XG4gICAgICAgICAgICAgICAgICBuYW1lPVwiYW5ub3RhdGlvbi1zb3VyY2UtdHlwZVwiXG4gICAgICAgICAgICAgICAgICBvcHRpb25zPXtzdXBwb3J0ZWRTb3VyY2VUeXBlc31cbiAgICAgICAgICAgICAgICAgIHZhbHVlPXtzb3VyY2VUeXBlfVxuICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e3RoaXMuaGFuZGxlQW5ub3RhdGlvblNvdXJjZVR5cGV9XG4gICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uRXJyb3JzPXshc291cmNlVHlwZSA/IFt0KCdNYW5kYXRvcnknKV0gOiBbXX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICB7dGhpcy5yZW5kZXJWYWx1ZUNvbmZpZ3VyYXRpb24oKX1cbiAgICAgICAgICAgIDwvUG9wb3ZlclNlY3Rpb24+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAge3RoaXMucmVuZGVyU2xpY2VDb25maWd1cmF0aW9uKCl9XG4gICAgICAgICAge3RoaXMucmVuZGVyRGlzcGxheUNvbmZpZ3VyYXRpb24oKX1cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgc3R5bGU9e3sgZGlzcGxheTogJ2ZsZXgnLCBqdXN0aWZ5Q29udGVudDogJ3NwYWNlLWJldHdlZW4nIH19PlxuICAgICAgICAgIHtpc05ldyA/IChcbiAgICAgICAgICAgIDxCdXR0b24gYnV0dG9uU2l6ZT1cInNtYWxsXCIgb25DbGljaz17KCkgPT4gdGhpcy5wcm9wcy5jbG9zZSgpfT5cbiAgICAgICAgICAgICAge3QoJ0NhbmNlbCcpfVxuICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgKSA6IChcbiAgICAgICAgICAgIDxCdXR0b24gYnV0dG9uU2l6ZT1cInNtYWxsXCIgb25DbGljaz17dGhpcy5kZWxldGVBbm5vdGF0aW9ufT5cbiAgICAgICAgICAgICAge3QoJ1JlbW92ZScpfVxuICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgKX1cbiAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgPEJ1dHRvblxuICAgICAgICAgICAgICBidXR0b25TaXplPVwic21hbGxcIlxuICAgICAgICAgICAgICBkaXNhYmxlZD17IWlzVmFsaWR9XG4gICAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMuYXBwbHlBbm5vdGF0aW9ufVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICB7dCgnQXBwbHknKX1cbiAgICAgICAgICAgIDwvQnV0dG9uPlxuXG4gICAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICAgIGJ1dHRvblNpemU9XCJzbWFsbFwiXG4gICAgICAgICAgICAgIGJ1dHRvblN0eWxlPVwicHJpbWFyeVwiXG4gICAgICAgICAgICAgIGRpc2FibGVkPXshaXNWYWxpZH1cbiAgICAgICAgICAgICAgb25DbGljaz17dGhpcy5zdWJtaXRBbm5vdGF0aW9ufVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICB7dCgnT0snKX1cbiAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvPlxuICAgICk7XG4gIH1cbn1cblxuQW5ub3RhdGlvbkxheWVyLnByb3BUeXBlcyA9IHByb3BUeXBlcztcbkFubm90YXRpb25MYXllci5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG4iXX0= */\", toString: _EMOTION_STRINGIFIED_CSS_ERROR__ };\n\n\nexport default class AnnotationLayer extends React.PureComponent {\n  constructor(props) {\n    super(props);\n    const {\n      name,\n      annotationType,\n      sourceType,\n      color,\n      opacity,\n      style,\n      width,\n      showMarkers,\n      hideLine,\n      value,\n      overrides,\n      show,\n      titleColumn,\n      descriptionColumns,\n      timeColumn,\n      intervalEndColumn,\n      vizType } =\n    props;\n\n    // Only allow override whole time_range\n    if ('since' in overrides || 'until' in overrides) {\n      overrides.time_range = null;\n      delete overrides.since;\n      delete overrides.until;\n    }\n\n    // Check if annotationType is supported by this chart\n    const metadata = getChartMetadataRegistry().get(vizType);\n    const supportedAnnotationTypes = (metadata == null ? void 0 : metadata.supportedAnnotationTypes) || [];\n    const validAnnotationType = supportedAnnotationTypes.includes(\n    annotationType) ?\n\n    annotationType :\n    supportedAnnotationTypes[0];\n\n    this.state = {\n      // base\n      name,\n      annotationType: validAnnotationType,\n      sourceType,\n      value,\n      overrides,\n      show,\n      // slice\n      titleColumn,\n      descriptionColumns,\n      timeColumn,\n      intervalEndColumn,\n      // display\n      color: color || AUTOMATIC_COLOR,\n      opacity,\n      style,\n      width,\n      showMarkers,\n      hideLine,\n      // refData\n      isNew: !name,\n      isLoadingOptions: true,\n      valueOptions: [] };\n\n    this.submitAnnotation = this.submitAnnotation.bind(this);\n    this.deleteAnnotation = this.deleteAnnotation.bind(this);\n    this.applyAnnotation = this.applyAnnotation.bind(this);\n    this.fetchOptions = this.fetchOptions.bind(this);\n    this.handleAnnotationType = this.handleAnnotationType.bind(this);\n    this.handleAnnotationSourceType = this.handleAnnotationSourceType.bind(\n    this);\n\n    this.handleValue = this.handleValue.bind(this);\n    this.isValidForm = this.isValidForm.bind(this);\n  }\n\n  componentDidMount() {\n    const { annotationType, sourceType, isLoadingOptions } = this.state;\n    this.fetchOptions(annotationType, sourceType, isLoadingOptions);\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    if (prevState.sourceType !== this.state.sourceType) {\n      this.fetchOptions(this.state.annotationType, this.state.sourceType, true);\n    }\n  }\n\n  getSupportedSourceTypes(annotationType) {var _ANNOTATION_TYPES_MET;\n    // Get vis types that can be source.\n    const sources = getChartMetadataRegistry().\n    entries().\n    filter(({ value: chartMetadata }) =>\n    chartMetadata.canBeAnnotationType(annotationType)).\n\n    map(({ key, value: chartMetadata }) => ({\n      value: key,\n      label: chartMetadata.name }));\n\n    // Prepend native source if applicable\n    if ((_ANNOTATION_TYPES_MET = ANNOTATION_TYPES_METADATA[annotationType]) != null && _ANNOTATION_TYPES_MET.supportNativeSource) {\n      sources.unshift(ANNOTATION_SOURCE_TYPES_METADATA.NATIVE);\n    }\n    return sources;\n  }\n\n  isValidFormulaAnnotation(expression, annotationType) {\n    if (annotationType === ANNOTATION_TYPES.FORMULA) {\n      return isValidExpression(expression);\n    }\n    return true;\n  }\n\n  isValidForm() {\n    const {\n      name,\n      annotationType,\n      sourceType,\n      value,\n      timeColumn,\n      intervalEndColumn } =\n    this.state;\n    const errors = [\n    validateNonEmpty(name),\n    validateNonEmpty(annotationType),\n    validateNonEmpty(value)];\n\n    if (sourceType !== ANNOTATION_SOURCE_TYPES.NATIVE) {\n      if (annotationType === ANNOTATION_TYPES.EVENT) {\n        errors.push(validateNonEmpty(timeColumn));\n      }\n      if (annotationType === ANNOTATION_TYPES.INTERVAL) {\n        errors.push(validateNonEmpty(timeColumn));\n        errors.push(validateNonEmpty(intervalEndColumn));\n      }\n    }\n    errors.push(!this.isValidFormulaAnnotation(value, annotationType));\n    return !errors.filter((x) => x).length;\n  }\n\n  handleAnnotationType(annotationType) {\n    this.setState({\n      annotationType,\n      sourceType: null,\n      value: null });\n\n  }\n\n  handleAnnotationSourceType(sourceType) {\n    const { sourceType: prevSourceType } = this.state;\n\n    if (prevSourceType !== sourceType) {\n      this.setState({ sourceType, value: null, isLoadingOptions: true });\n    }\n  }\n\n  handleValue(value) {\n    this.setState({\n      value,\n      descriptionColumns: [],\n      intervalEndColumn: null,\n      timeColumn: null,\n      titleColumn: null,\n      overrides: { time_range: null } });\n\n  }\n\n  fetchOptions(annotationType, sourceType, isLoadingOptions) {\n    if (isLoadingOptions) {\n      if (sourceType === ANNOTATION_SOURCE_TYPES.NATIVE) {\n        SupersetClient.get({\n          endpoint: '/annotationlayermodelview/api/read?' }).\n        then(({ json }) => {\n          const layers = json ?\n          json.result.map((layer) => ({\n            value: layer.id,\n            label: layer.name })) :\n\n          [];\n          this.setState({\n            isLoadingOptions: false,\n            valueOptions: layers });\n\n        });\n      } else if (requiresQuery(sourceType)) {\n        SupersetClient.get({ endpoint: '/superset/user_slices' }).then(\n        ({ json }) => {\n          const registry = getChartMetadataRegistry();\n          this.setState({\n            isLoadingOptions: false,\n            valueOptions: json.\n            filter((x) => {\n              const metadata = registry.get(x.viz_type);\n              return (\n                metadata && metadata.canBeAnnotationType(annotationType));\n\n            }).\n            map((x) => ({ value: x.id, label: x.title, slice: x })) });\n\n        });\n\n      } else {\n        this.setState({\n          isLoadingOptions: false,\n          valueOptions: [] });\n\n      }\n    }\n  }\n\n  deleteAnnotation() {\n    this.props.removeAnnotationLayer();\n    this.props.close();\n  }\n\n  applyAnnotation() {\n    if (this.isValidForm()) {\n      const annotationFields = [\n      'name',\n      'annotationType',\n      'sourceType',\n      'color',\n      'opacity',\n      'style',\n      'width',\n      'showMarkers',\n      'hideLine',\n      'value',\n      'overrides',\n      'show',\n      'titleColumn',\n      'descriptionColumns',\n      'timeColumn',\n      'intervalEndColumn'];\n\n      const newAnnotation = {};\n      annotationFields.forEach((field) => {\n        if (this.state[field] !== null) {\n          newAnnotation[field] = this.state[field];\n        }\n      });\n\n      if (newAnnotation.color === AUTOMATIC_COLOR) {\n        newAnnotation.color = null;\n      }\n\n      this.props.addAnnotationLayer(newAnnotation);\n      this.setState({ isNew: false });\n    }\n  }\n\n  submitAnnotation() {\n    this.applyAnnotation();\n    this.props.close();\n  }\n\n  renderOption(option) {\n    return (\n      ___EmotionJSX(\"span\", {\n        css: _ref,\n\n\n\n\n        title: option.label },\n\n      option.label));\n\n\n  }\n\n  renderValueConfiguration() {\n    const {\n      annotationType,\n      sourceType,\n      value,\n      valueOptions,\n      isLoadingOptions } =\n    this.state;\n    let label = '';\n    let description = '';\n    if (requiresQuery(sourceType)) {\n      if (sourceType === ANNOTATION_SOURCE_TYPES.NATIVE) {\n        label = 'Annotation layer';\n        description = 'Select the Annotation Layer you would like to use.';\n      } else {\n        label = t('Chart');\n        description = `Use a pre defined Superset Chart as a source for annotations and overlays.\n        your chart must be one of these visualization types:\n        [${this.getSupportedSourceTypes(annotationType).\n        map((x) => x.label).\n        join(', ')}]`;\n      }\n    } else if (annotationType === ANNOTATION_TYPES.FORMULA) {\n      label = 'Formula';\n      description = `Expects a formula with depending time parameter 'x'\n        in milliseconds since epoch. mathjs is used to evaluate the formulas.\n        Example: '2x+5'`;\n    }\n    if (requiresQuery(sourceType)) {\n      return (\n        ___EmotionJSX(SelectControl, {\n          ariaLabel: t('Annotation layer value'),\n          name: \"annotation-layer-value\",\n          showHeader: true,\n          hovered: true,\n          description: description,\n          label: label,\n          placeholder: \"\",\n          options: valueOptions,\n          isLoading: isLoadingOptions,\n          value: value,\n          onChange: this.handleValue,\n          validationErrors: !value ? ['Mandatory'] : [],\n          optionRenderer: this.renderOption }));\n\n\n    }\n    if (annotationType === ANNOTATION_TYPES.FORMULA) {\n      return (\n        ___EmotionJSX(TextControl, {\n          name: \"annotation-layer-value\",\n          hovered: true,\n          showHeader: true,\n          description: description,\n          label: label,\n          placeholder: \"\",\n          value: value,\n          onChange: this.handleValue,\n          validationErrors:\n          !this.isValidFormulaAnnotation(value, annotationType) ?\n          ['Bad formula.'] :\n          [] }));\n\n\n\n    }\n    return '';\n  }\n\n  renderSliceConfiguration() {\n    const {\n      annotationType,\n      sourceType,\n      value,\n      valueOptions,\n      overrides,\n      titleColumn,\n      timeColumn,\n      intervalEndColumn,\n      descriptionColumns } =\n    this.state;\n    const { slice } = valueOptions.find((x) => x.value === value) || {};\n    if (sourceType !== ANNOTATION_SOURCE_TYPES.NATIVE && slice) {\n      const columns = (slice.data.groupby || []).\n      concat(slice.data.all_columns || []).\n      map((x) => ({ value: x, label: x }));\n      const timeColumnOptions = slice.data.include_time ?\n      [{ value: '__timestamp', label: '__timestamp' }].concat(columns) :\n      columns;\n      return (\n        ___EmotionJSX(\"div\", { style: { marginRight: '2rem' } },\n        ___EmotionJSX(PopoverSection, {\n          isSelected: true,\n          title: t('Annotation Slice Configuration'),\n          info: t(`This section allows you to configure how to use the slice\n               to generate annotations.`) },\n\n        (annotationType === ANNOTATION_TYPES.EVENT ||\n        annotationType === ANNOTATION_TYPES.INTERVAL) &&\n        ___EmotionJSX(SelectControl, {\n          ariaLabel: t('Annotation layer time column'),\n          hovered: true,\n          name: \"annotation-layer-time-column\",\n          label:\n          annotationType === ANNOTATION_TYPES.INTERVAL ?\n          t('Interval start column') :\n          t('Event time column'),\n\n          description: t(\n          'This column must contain date/time information.'),\n\n          validationErrors: !timeColumn ? ['Mandatory'] : [],\n          clearable: false,\n          options: timeColumnOptions,\n          value: timeColumn,\n          onChange: (v) => this.setState({ timeColumn: v }) }),\n\n\n        annotationType === ANNOTATION_TYPES.INTERVAL &&\n        ___EmotionJSX(SelectControl, {\n          ariaLabel: t('Annotation layer interval end'),\n          hovered: true,\n          name: \"annotation-layer-intervalEnd\",\n          label: t('Interval End column'),\n          description: t(\n          'This column must contain date/time information.'),\n\n          validationErrors: !intervalEndColumn ? ['Mandatory'] : [],\n          options: columns,\n          value: intervalEndColumn,\n          onChange: (value) => this.setState({ intervalEndColumn: value }) }),\n\n\n        ___EmotionJSX(SelectControl, {\n          ariaLabel: t('Annotation layer title column'),\n          hovered: true,\n          name: \"annotation-layer-title\",\n          label: t('Title Column'),\n          description: t('Pick a title for you annotation.'),\n          options: [{ value: '', label: 'None' }].concat(columns),\n          value: titleColumn,\n          onChange: (value) => this.setState({ titleColumn: value }) }),\n\n        annotationType !== ANNOTATION_TYPES.TIME_SERIES &&\n        ___EmotionJSX(SelectControl, {\n          ariaLabel: t('Annotation layer description columns'),\n          hovered: true,\n          name: \"annotation-layer-title\",\n          label: t('Description Columns'),\n          description: t(\n          \"Pick one or more columns that should be shown in the annotation. If you don't select a column all of them will be shown.\"),\n\n          multi: true,\n          options: columns,\n          value: descriptionColumns,\n          onChange: (value) => this.setState({ descriptionColumns: value }) }),\n\n\n        ___EmotionJSX(\"div\", { style: { marginTop: '1rem' } },\n        ___EmotionJSX(CheckboxControl, {\n          hovered: true,\n          name: \"annotation-override-time_range\",\n          label: \"Override time range\",\n          description: `This controls whether the \"time_range\" field from the current\n                  view should be passed down to the chart containing the annotation data.`,\n          value: 'time_range' in overrides,\n          onChange: (v) => {\n            delete overrides.time_range;\n            if (v) {\n              this.setState({\n                overrides: { ...overrides, time_range: null } });\n\n            } else {\n              this.setState({ overrides: { ...overrides } });\n            }\n          } }),\n\n        ___EmotionJSX(CheckboxControl, {\n          hovered: true,\n          name: \"annotation-override-timegrain\",\n          label: \"Override time grain\",\n          description: `This controls whether the time grain field from the current\n                  view should be passed down to the chart containing the annotation data.`,\n          value: 'time_grain_sqla' in overrides,\n          onChange: (v) => {\n            delete overrides.time_grain_sqla;\n            delete overrides.granularity;\n            if (v) {\n              this.setState({\n                overrides: {\n                  ...overrides,\n                  time_grain_sqla: null,\n                  granularity: null } });\n\n\n            } else {\n              this.setState({ overrides: { ...overrides } });\n            }\n          } }),\n\n        ___EmotionJSX(TextControl, {\n          hovered: true,\n          name: \"annotation-layer-timeshift\",\n          label: \"Time Shift\",\n          description: `Time delta in natural language\n                  (example:  24 hours, 7 days, 56 weeks, 365 days)`,\n          placeholder: \"\",\n          value: overrides.time_shift,\n          onChange: (v) =>\n          this.setState({ overrides: { ...overrides, time_shift: v } }) })))));\n\n\n\n\n\n\n    }\n    return '';\n  }\n\n  renderDisplayConfiguration() {\n    const {\n      color,\n      opacity,\n      style,\n      width,\n      showMarkers,\n      hideLine,\n      annotationType } =\n    this.state;\n    const colorScheme = getCategoricalSchemeRegistry().\n    get(this.props.colorScheme).\n    colors.concat();\n    if (\n    color &&\n    color !== AUTOMATIC_COLOR &&\n    !colorScheme.find((x) => x.toLowerCase() === color.toLowerCase()))\n    {\n      colorScheme.push(color);\n    }\n    return (\n      ___EmotionJSX(PopoverSection, {\n        isSelected: true,\n        title: t('Display configuration'),\n        info: t('Configure your how you overlay is displayed here.') },\n\n      ___EmotionJSX(SelectControl, {\n        ariaLabel: t('Annotation layer stroke'),\n        name: \"annotation-layer-stroke\",\n        label: t('Style')\n        // see '../../../visualizations/nvd3_vis.css'\n        , options: [\n        { value: 'solid', label: 'Solid' },\n        { value: 'dashed', label: 'Dashed' },\n        { value: 'longDashed', label: 'Long dashed' },\n        { value: 'dotted', label: 'Dotted' }],\n\n        value: style,\n        clearable: false,\n        onChange: (v) => this.setState({ style: v }) }),\n\n      ___EmotionJSX(SelectControl, {\n        ariaLabel: t('Annotation layer opacity'),\n        name: \"annotation-layer-opacity\",\n        label: t('Opacity')\n        // see '../../../visualizations/nvd3_vis.css'\n        , options: [\n        { value: '', label: 'Solid' },\n        { value: 'opacityLow', label: '0.2' },\n        { value: 'opacityMedium', label: '0.5' },\n        { value: 'opacityHigh', label: '0.8' }],\n\n        value: opacity,\n        onChange: (value) => this.setState({ opacity: value }) }),\n\n      ___EmotionJSX(\"div\", null,\n      ___EmotionJSX(ControlHeader, { label: t('Color') }),\n      ___EmotionJSX(\"div\", { style: { display: 'flex', flexDirection: 'column' } },\n      ___EmotionJSX(CompactPicker, {\n        color: color,\n        colors: colorScheme,\n        onChangeComplete: (v) => this.setState({ color: v.hex }) }),\n\n      ___EmotionJSX(Button, {\n        style: { marginTop: '0.5rem', marginBottom: '0.5rem' },\n        buttonStyle: color === AUTOMATIC_COLOR ? 'success' : 'default',\n        buttonSize: \"xsmall\",\n        onClick: () => this.setState({ color: AUTOMATIC_COLOR }) }, \"Automatic Color\"))),\n\n\n\n\n\n      ___EmotionJSX(TextControl, {\n        name: \"annotation-layer-stroke-width\",\n        label: t('Line width'),\n        isInt: true,\n        value: width,\n        onChange: (v) => this.setState({ width: v }) }),\n\n      annotationType === ANNOTATION_TYPES.TIME_SERIES &&\n      ___EmotionJSX(CheckboxControl, {\n        hovered: true,\n        name: \"annotation-layer-show-markers\",\n        label: \"Show Markers\",\n        description: \"Shows or hides markers for the time series\",\n        value: showMarkers,\n        onChange: (v) => this.setState({ showMarkers: v }) }),\n\n\n      annotationType === ANNOTATION_TYPES.TIME_SERIES &&\n      ___EmotionJSX(CheckboxControl, {\n        hovered: true,\n        name: \"annotation-layer-hide-line\",\n        label: \"Hide Line\",\n        description: \"Hides the Line for the time series\",\n        value: hideLine,\n        onChange: (v) => this.setState({ hideLine: v }) })));\n\n\n\n\n  }\n\n  render() {\n    const { isNew, name, annotationType, sourceType, show } = this.state;\n    const isValid = this.isValidForm();\n    const metadata = getChartMetadataRegistry().get(this.props.vizType);\n    const supportedAnnotationTypes = metadata ?\n    metadata.supportedAnnotationTypes.map(\n    (type) => ANNOTATION_TYPES_METADATA[type]) :\n\n    [];\n    const supportedSourceTypes = this.getSupportedSourceTypes(annotationType);\n\n    return (\n      ___EmotionJSX(React.Fragment, null,\n      this.props.error &&\n      ___EmotionJSX(\"span\", { style: { color: 'red' } }, \"ERROR: \", this.props.error),\n\n      ___EmotionJSX(\"div\", { style: { display: 'flex', flexDirection: 'row' } },\n      ___EmotionJSX(\"div\", { style: { marginRight: '2rem' } },\n      ___EmotionJSX(PopoverSection, {\n        isSelected: true,\n        title: t('Layer configuration'),\n        info: t('Configure the basics of your Annotation Layer.') },\n\n      ___EmotionJSX(TextControl, {\n        name: \"annotation-layer-name\",\n        label: t('Name'),\n        placeholder: \"\",\n        value: name,\n        onChange: (v) => this.setState({ name: v }),\n        validationErrors: !name ? [t('Mandatory')] : [] }),\n\n      ___EmotionJSX(CheckboxControl, {\n        name: \"annotation-layer-hide\",\n        label: t('Hide layer'),\n        value: !show,\n        onChange: (v) => this.setState({ show: !v }) }),\n\n      ___EmotionJSX(SelectControl, {\n        ariaLabel: t('Annotation layer type'),\n        hovered: true,\n        description: t('Choose the annotation layer type'),\n        label: t('Annotation layer type'),\n        name: \"annotation-layer-type\",\n        clearable: false,\n        options: supportedAnnotationTypes,\n        value: annotationType,\n        onChange: this.handleAnnotationType }),\n\n      supportedSourceTypes.length > 0 &&\n      ___EmotionJSX(SelectControl, {\n        ariaLabel: t('Annotation source type'),\n        hovered: true,\n        description: t('Choose the source of your annotations'),\n        label: t('Annotation Source'),\n        name: \"annotation-source-type\",\n        options: supportedSourceTypes,\n        value: sourceType,\n        onChange: this.handleAnnotationSourceType,\n        validationErrors: !sourceType ? [t('Mandatory')] : [] }),\n\n\n      this.renderValueConfiguration())),\n\n\n      this.renderSliceConfiguration(),\n      this.renderDisplayConfiguration()),\n\n      ___EmotionJSX(\"div\", { style: { display: 'flex', justifyContent: 'space-between' } },\n      isNew ?\n      ___EmotionJSX(Button, { buttonSize: \"small\", onClick: () => this.props.close() },\n      t('Cancel')) :\n\n\n      ___EmotionJSX(Button, { buttonSize: \"small\", onClick: this.deleteAnnotation },\n      t('Remove')),\n\n\n      ___EmotionJSX(\"div\", null,\n      ___EmotionJSX(Button, {\n        buttonSize: \"small\",\n        disabled: !isValid,\n        onClick: this.applyAnnotation },\n\n      t('Apply')),\n\n\n      ___EmotionJSX(Button, {\n        buttonSize: \"small\",\n        buttonStyle: \"primary\",\n        disabled: !isValid,\n        onClick: this.submitAnnotation },\n\n      t('OK'))))));\n\n\n\n\n\n  }}\n\n\nAnnotationLayer.propTypes = propTypes;\nAnnotationLayer.defaultProps = defaultProps;","map":null,"metadata":{},"sourceType":"module"}