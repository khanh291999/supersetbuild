{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport handleHover from './handleHover';\nimport handleDrop from './handleDrop';\n\n// note: the 'type' hook is not useful for us as dropping is contigent on other properties\nconst TYPE = 'DRAG_DROPPABLE';\n\nexport const dragConfig = [\nTYPE,\n{\n  canDrag(props) {\n    return !props.disableDragDrop;\n  },\n\n  // this defines the dragging item object returned by monitor.getItem()\n  beginDrag(props /* , monitor, component */) {\n    const { component, index, parentComponent = {} } = props;\n    return {\n      type: component.type,\n      id: component.id,\n      meta: component.meta,\n      index,\n      parentId: parentComponent.id,\n      parentType: parentComponent.type };\n\n  } },\n\nfunction dragStateToProps(connect, monitor) {\n  return {\n    dragSourceRef: connect.dragSource(),\n    dragPreviewRef: connect.dragPreview(),\n    isDragging: monitor.isDragging() };\n\n}];\n\n\nexport const dropConfig = [\nTYPE,\n{\n  canDrop(props) {\n    return !props.disableDragDrop;\n  },\n  hover(props, monitor, component) {\n    if (component && component.mounted) {\n      handleHover(props, monitor, component);\n    }\n  },\n  // note:\n  //  the react-dnd api requires that the drop() method return a result or undefined\n  //  monitor.didDrop() cannot be used because it returns true only for the most-nested target\n  drop(props, monitor, component) {\n    const dropResult = monitor.getDropResult();\n    if ((!dropResult || !dropResult.destination) && component.mounted) {\n      return handleDrop(props, monitor, component);\n    }\n    return undefined;\n  } },\n\nfunction dropStateToProps(connect, monitor) {\n  return {\n    droppableRef: connect.dropTarget(),\n    isDraggingOver: monitor.isOver(),\n    isDraggingOverShallow: monitor.isOver({ shallow: true }) };\n\n}];","map":null,"metadata":{},"sourceType":"module"}