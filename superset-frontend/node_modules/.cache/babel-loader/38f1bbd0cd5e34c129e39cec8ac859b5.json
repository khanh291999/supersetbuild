{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { ensureIsArray, FeatureFlag, isFeatureEnabled } from '@superset-ui/core';\nimport { NO_TIME_RANGE, TIME_FILTER_MAP } from 'src/explore/constants';\nimport { getChartIdsInFilterScope } from 'src/dashboard/util/activeDashboardFilters';\nimport { DataMaskType } from 'src/dataMask/types';\nimport { areObjectsEqual } from 'src/reduxUtils';\nimport { getTreeCheckedItems } from '../nativeFilters/FiltersConfigModal/FiltersConfigForm/FilterScope/utils';\nexport var IndicatorStatus;\n(function (IndicatorStatus) {\n  IndicatorStatus[\"Unset\"] = \"UNSET\";\n  IndicatorStatus[\"Applied\"] = \"APPLIED\";\n  IndicatorStatus[\"Incompatible\"] = \"INCOMPATIBLE\";\n  IndicatorStatus[\"CrossFilterApplied\"] = \"CROSS_FILTER_APPLIED\";\n})(IndicatorStatus || (IndicatorStatus = {}));\nconst TIME_GRANULARITY_FIELDS = new Set(Object.values(TIME_FILTER_MAP));\nconst extractLabel = (filter) => {\n  if (filter != null && filter.label) {\n    return filter.label;\n  }\n  if (filter != null && filter.value) {\n    return ensureIsArray(filter == null ? void 0 : filter.value).join(', ');\n  }\n  return null;\n};\nconst selectIndicatorValue = (columnKey, filter, datasource) => {\n  const values = filter.columns[columnKey];\n  const arrValues = Array.isArray(values) ? values : [values];\n  if (values == null ||\n  filter.isDateFilter && values === NO_TIME_RANGE ||\n  arrValues.length === 0) {\n    return [];\n  }\n  if (filter.isDateFilter && TIME_GRANULARITY_FIELDS.has(columnKey)) {\n    const timeGranularityMap = ((columnKey === TIME_FILTER_MAP.time_grain_sqla ?\n    datasource.time_grain_sqla :\n    datasource.granularity) || []).reduce((map, [key, value]) => ({\n      ...map,\n      [key]: value }),\n    {});\n    return arrValues.map((value) => timeGranularityMap[value] || value);\n  }\n  return arrValues;\n};\nconst selectIndicatorsForChartFromFilter = (chartId, filter, filterDataSource, appliedColumns, rejectedColumns) => {\n  // filters can be applied (if the filter is compatible with the datasource)\n  // or rejected (if the filter is incompatible)\n  // or the status can be unknown (if the filter has calculated parameters that we can't analyze)\n  const getStatus = (column, filter) => {\n    if (appliedColumns.has(column) && filter.columns[column])\n    return IndicatorStatus.Applied;\n    if (rejectedColumns.has(column))\n    return IndicatorStatus.Incompatible;\n    return IndicatorStatus.Unset;\n  };\n  return Object.keys(filter.columns).\n  filter((column) => getChartIdsInFilterScope({\n    filterScope: filter.scopes[column] }).\n  includes(chartId)).\n  map((column) => ({\n    column,\n    name: filter.labels[column] || column,\n    value: selectIndicatorValue(column, filter, filterDataSource),\n    status: getStatus(column, filter),\n    path: filter.directPathToFilter }));\n\n};\nconst getAppliedColumns = (chart) => {var _chart$queriesRespons, _chart$queriesRespons2;return new Set(((chart == null ? void 0 : (_chart$queriesRespons = chart.queriesResponse) == null ? void 0 : (_chart$queriesRespons2 = _chart$queriesRespons[0]) == null ? void 0 : _chart$queriesRespons2.applied_filters) || []).map((filter) => filter.column));};\nconst getRejectedColumns = (chart) => {var _chart$queriesRespons3, _chart$queriesRespons4;return new Set(((chart == null ? void 0 : (_chart$queriesRespons3 = chart.queriesResponse) == null ? void 0 : (_chart$queriesRespons4 = _chart$queriesRespons3[0]) == null ? void 0 : _chart$queriesRespons4.rejected_filters) || []).map((filter) => filter.column));};\nconst cachedIndicatorsForChart = {};\nconst cachedDashboardFilterDataForChart = {};\n// inspects redux state to find what the filter indicators should be shown for a given chart\nexport const selectIndicatorsForChart = (chartId, filters, datasources, chart) => {\n  // for now we only need to know which columns are compatible/incompatible,\n  // so grab the columns from the applied/rejected filters\n  const appliedColumns = getAppliedColumns(chart);\n  const rejectedColumns = getRejectedColumns(chart);\n  const matchingFilters = Object.values(filters).filter((filter) => filter.chartId !== chartId);\n  const matchingDatasources = Object.entries(datasources).\n  filter(([key]) => matchingFilters.find((filter) => filter.datasourceId === key)).\n  map(([, datasource]) => datasource);\n  const cachedFilterData = cachedDashboardFilterDataForChart[chartId];\n  if (cachedIndicatorsForChart[chartId] &&\n  areObjectsEqual(cachedFilterData == null ? void 0 : cachedFilterData.appliedColumns, appliedColumns) &&\n  areObjectsEqual(cachedFilterData == null ? void 0 : cachedFilterData.rejectedColumns, rejectedColumns) &&\n  areObjectsEqual(cachedFilterData == null ? void 0 : cachedFilterData.matchingFilters, matchingFilters) &&\n  areObjectsEqual(cachedFilterData == null ? void 0 : cachedFilterData.matchingDatasources, matchingDatasources)) {\n    return cachedIndicatorsForChart[chartId];\n  }\n  const indicators = matchingFilters.reduce((acc, filter) => acc.concat(selectIndicatorsForChartFromFilter(chartId, filter, datasources[filter.datasourceId] || {}, appliedColumns, rejectedColumns)), []);\n  indicators.sort((a, b) => a.name.localeCompare(b.name));\n  cachedIndicatorsForChart[chartId] = indicators;\n  cachedDashboardFilterDataForChart[chartId] = {\n    appliedColumns,\n    rejectedColumns,\n    matchingFilters,\n    matchingDatasources };\n\n  return indicators;\n};\nconst cachedNativeIndicatorsForChart = {};\nconst cachedNativeFilterDataForChart = {};\nconst defaultChartConfig = {};\nexport const selectNativeIndicatorsForChart = (nativeFilters, dataMask, chartId, chart, dashboardLayout, chartConfiguration = defaultChartConfig) => {\n  const appliedColumns = getAppliedColumns(chart);\n  const rejectedColumns = getRejectedColumns(chart);\n  const cachedFilterData = cachedNativeFilterDataForChart[chartId];\n  if (cachedNativeIndicatorsForChart[chartId] &&\n  areObjectsEqual(cachedFilterData == null ? void 0 : cachedFilterData.appliedColumns, appliedColumns) &&\n  areObjectsEqual(cachedFilterData == null ? void 0 : cachedFilterData.rejectedColumns, rejectedColumns) &&\n  (cachedFilterData == null ? void 0 : cachedFilterData.nativeFilters) === nativeFilters &&\n  (cachedFilterData == null ? void 0 : cachedFilterData.dashboardLayout) === dashboardLayout &&\n  (cachedFilterData == null ? void 0 : cachedFilterData.chartConfiguration) === chartConfiguration &&\n  (cachedFilterData == null ? void 0 : cachedFilterData.dataMask) === dataMask) {\n    return cachedNativeIndicatorsForChart[chartId];\n  }\n  const getStatus = ({ label, column, type = DataMaskType.NativeFilters }) => {\n    // a filter is only considered unset if it's value is null\n    const hasValue = label !== null;\n    if (type === DataMaskType.CrossFilters && hasValue) {\n      return IndicatorStatus.CrossFilterApplied;\n    }\n    if (!column && hasValue) {\n      // Filter without datasource\n      return IndicatorStatus.Applied;\n    }\n    if (column && rejectedColumns.has(column))\n    return IndicatorStatus.Incompatible;\n    if (column && appliedColumns.has(column) && hasValue) {\n      return IndicatorStatus.Applied;\n    }\n    return IndicatorStatus.Unset;\n  };\n  let nativeFilterIndicators = [];\n  if (isFeatureEnabled(FeatureFlag.DASHBOARD_NATIVE_FILTERS)) {\n    nativeFilterIndicators =\n    nativeFilters &&\n    Object.values(nativeFilters).\n    filter((nativeFilter) => getTreeCheckedItems(nativeFilter.scope, dashboardLayout).some((layoutItem) => {var _dashboardLayout$layo, _dashboardLayout$layo2;return ((_dashboardLayout$layo = dashboardLayout[layoutItem]) == null ? void 0 : (_dashboardLayout$layo2 = _dashboardLayout$layo.meta) == null ? void 0 : _dashboardLayout$layo2.chartId) === chartId;})).\n    map((nativeFilter) => {var _nativeFilter$targets, _nativeFilter$targets2, _dataMask$nativeFilte;\n      const column = (_nativeFilter$targets = nativeFilter.targets[0]) == null ? void 0 : (_nativeFilter$targets2 = _nativeFilter$targets.column) == null ? void 0 : _nativeFilter$targets2.name;\n      const filterState = (_dataMask$nativeFilte = dataMask[nativeFilter.id]) == null ? void 0 : _dataMask$nativeFilte.filterState;\n      const label = extractLabel(filterState);\n      return {\n        column,\n        name: nativeFilter.name,\n        path: [nativeFilter.id],\n        status: getStatus({ label, column }),\n        value: label };\n\n    });\n  }\n  let crossFilterIndicators = [];\n  if (isFeatureEnabled(FeatureFlag.DASHBOARD_CROSS_FILTERS)) {\n    crossFilterIndicators = Object.values(chartConfiguration).\n    filter((chartConfig) => {var _chartConfig$crossFil;return getTreeCheckedItems(chartConfig == null ? void 0 : (_chartConfig$crossFil = chartConfig.crossFilters) == null ? void 0 : _chartConfig$crossFil.scope, dashboardLayout).some((layoutItem) => {var _dashboardLayout$layo3, _dashboardLayout$layo4;return ((_dashboardLayout$layo3 = dashboardLayout[layoutItem]) == null ? void 0 : (_dashboardLayout$layo4 = _dashboardLayout$layo3.meta) == null ? void 0 : _dashboardLayout$layo4.chartId) === chartId;});}).\n    map((chartConfig) => {var _dataMask$chartConfig, _dashboardLayoutItem$, _dashboardLayoutItem$2;\n      const filterState = (_dataMask$chartConfig = dataMask[chartConfig.id]) == null ? void 0 : _dataMask$chartConfig.filterState;\n      const label = extractLabel(filterState);\n      const filtersState = filterState == null ? void 0 : filterState.filters;\n      const column = filtersState && Object.keys(filtersState)[0];\n      const dashboardLayoutItem = Object.values(dashboardLayout).find((layoutItem) => {var _layoutItem$meta;return (layoutItem == null ? void 0 : (_layoutItem$meta = layoutItem.meta) == null ? void 0 : _layoutItem$meta.chartId) === chartConfig.id;});\n      return {\n        column,\n        name: dashboardLayoutItem == null ? void 0 : (_dashboardLayoutItem$ = dashboardLayoutItem.meta) == null ? void 0 : _dashboardLayoutItem$.sliceName,\n        path: [\n        ...((_dashboardLayoutItem$2 = dashboardLayoutItem == null ? void 0 : dashboardLayoutItem.parents) != null ? _dashboardLayoutItem$2 : []),\n        dashboardLayoutItem == null ? void 0 : dashboardLayoutItem.id],\n\n        status: getStatus({\n          label,\n          type: DataMaskType.CrossFilters }),\n\n        value: label };\n\n    }).\n    filter((filter) => filter.status === IndicatorStatus.CrossFilterApplied);\n  }\n  const indicators = crossFilterIndicators.concat(nativeFilterIndicators);\n  cachedNativeIndicatorsForChart[chartId] = indicators;\n  cachedNativeFilterDataForChart[chartId] = {\n    nativeFilters,\n    dashboardLayout,\n    chartConfiguration,\n    dataMask,\n    appliedColumns,\n    rejectedColumns };\n\n  return indicators;\n};","map":null,"metadata":{},"sourceType":"module"}