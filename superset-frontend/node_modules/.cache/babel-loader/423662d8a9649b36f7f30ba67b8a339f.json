{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport React, { useMemo } from 'react';\nimport PropTypes from 'prop-types';\nimport Mustache from 'mustache';\nimport { scaleLinear } from 'd3-scale';\nimport TableView from 'src/components/TableView';\nimport { formatNumber, formatTime, styled } from '@superset-ui/core';\nimport {\nInfoTooltipWithTrigger,\nMetricOption } from\n'@superset-ui/chart-controls';\nimport moment from 'moment';\n\nimport FormattedNumber from './FormattedNumber';\nimport SparklineCell from './SparklineCell';\nimport './TimeTable.less';import { jsx as ___EmotionJSX } from \"@emotion/react\";\n\nconst ACCESSIBLE_COLOR_BOUNDS = ['#ca0020', '#0571b0'];\n\nfunction colorFromBounds(value, bounds, colorBounds = ACCESSIBLE_COLOR_BOUNDS) {\n  if (bounds) {\n    const [min, max] = bounds;\n    const [minColor, maxColor] = colorBounds;\n    if (min !== null && max !== null) {\n      const colorScale = scaleLinear().\n      domain([min, (max + min) / 2, max]).\n      range([minColor, 'grey', maxColor]);\n      return colorScale(value);\n    }\n    if (min !== null) {\n      return value >= min ? maxColor : minColor;\n    }\n    if (max !== null) {\n      return value < max ? maxColor : minColor;\n    }\n  }\n  return null;\n}\n\nconst propTypes = {\n  className: PropTypes.string,\n  height: PropTypes.number,\n  // Example\n  // {'2018-04-14 00:00:00': { 'SUM(metric_value)': 80031779.40047 }}\n  data: PropTypes.objectOf(PropTypes.objectOf(PropTypes.number)).isRequired,\n  columnConfigs: PropTypes.arrayOf(\n  PropTypes.shape({\n    colType: PropTypes.string,\n    comparisonType: PropTypes.string,\n    d3format: PropTypes.string,\n    key: PropTypes.string,\n    label: PropTypes.string,\n    timeLag: PropTypes.number })).\n\n  isRequired,\n  rows: PropTypes.arrayOf(\n  PropTypes.oneOfType([\n  PropTypes.shape({\n    label: PropTypes.string }),\n\n  PropTypes.shape({\n    metric_name: PropTypes.string })])).\n\n\n  isRequired,\n  rowType: PropTypes.oneOf(['column', 'metric']).isRequired,\n  url: PropTypes.string };\n\nconst defaultProps = {\n  className: '',\n  height: undefined,\n  url: '' };\n\n\nconst TimeTableStyles = styled.div`\n  height: ${(props) => props.height}px;\n\n  th {\n    z-index: 1; // to cover sparkline\n  }\n`;\n\nconst TimeTable = ({\n  className,\n  height,\n  data,\n  columnConfigs,\n  rowType,\n  rows,\n  url }) =>\n{\n  const memoizedColumns = useMemo(\n  () => [\n  { accessor: 'metric', Header: 'Metric' },\n  ...columnConfigs.map((columnConfig, i) => ({\n    accessor: columnConfig.key,\n    cellProps: columnConfig.colType === 'spark' && {\n      style: { width: '1%' } },\n\n    Header: () =>\n    ___EmotionJSX(React.Fragment, null,\n    columnConfig.label, ' ',\n    columnConfig.tooltip &&\n    ___EmotionJSX(InfoTooltipWithTrigger, {\n      tooltip: columnConfig.tooltip,\n      label: `tt-col-${i}`,\n      placement: \"top\" })),\n\n\n\n\n    sortType: (rowA, rowB, columnId) => {\n      const rowAVal = rowA.values[columnId].props['data-value'];\n      const rowBVal = rowB.values[columnId].props['data-value'];\n      return rowAVal - rowBVal;\n    } }))],\n\n\n  [columnConfigs]);\n\n\n  const memoizedRows = useMemo(() => {\n    const renderSparklineCell = (valueField, column, entries) => {\n      let sparkData;\n      if (column.timeRatio) {\n        // Period ratio sparkline\n        sparkData = [];\n        for (let i = column.timeRatio; i < entries.length; i += 1) {\n          const prevData = entries[i - column.timeRatio][valueField];\n          if (prevData && prevData !== 0) {\n            sparkData.push(entries[i][valueField] / prevData);\n          } else {\n            sparkData.push(null);\n          }\n        }\n      } else {\n        sparkData = entries.map((d) => d[valueField]);\n      }\n\n      return (\n        ___EmotionJSX(SparklineCell, {\n          width: parseInt(column.width, 10) || 300,\n          height: parseInt(column.height, 10) || 50,\n          data: sparkData,\n          \"data-value\": sparkData[sparkData.length - 1],\n          ariaLabel: `spark-${valueField}`,\n          numberFormat: column.d3format,\n          yAxisBounds: column.yAxisBounds,\n          showYAxis: column.showYAxis,\n          renderTooltip: ({ index }) =>\n          ___EmotionJSX(\"div\", null,\n          ___EmotionJSX(\"strong\", null, formatNumber(column.d3format, sparkData[index])),\n          ___EmotionJSX(\"div\", null,\n          formatTime(\n          column.dateFormat,\n          moment.utc(entries[index].time).toDate()))) }));\n\n\n\n\n\n\n    };\n\n    const renderValueCell = (valueField, column, reversedEntries) => {\n      const recent = reversedEntries[0][valueField];\n      let v;\n      let errorMsg;\n      if (column.colType === 'time') {\n        // Time lag ratio\n        const timeLag = column.timeLag || 0;\n        const totalLag = Object.keys(reversedEntries).length;\n        if (timeLag >= totalLag) {\n          errorMsg = `The time lag set at ${timeLag} is too large for the length of data at ${reversedEntries.length}. No data available.`;\n        } else {\n          v = reversedEntries[timeLag][valueField];\n        }\n        if (column.comparisonType === 'diff') {\n          v = recent - v;\n        } else if (column.comparisonType === 'perc') {\n          v = recent / v;\n        } else if (column.comparisonType === 'perc_change') {\n          v = recent / v - 1;\n        }\n        v = v || 0;\n      } else if (column.colType === 'contrib') {\n        // contribution to column total\n        v =\n        recent /\n        Object.keys(reversedEntries[0]).\n        map((k) => k !== 'time' ? reversedEntries[0][k] : null).\n        reduce((a, b) => a + b);\n      } else if (column.colType === 'avg') {\n        // Average over the last {timeLag}\n        v = null;\n        if (reversedEntries.length > 0) {\n          const stats = reversedEntries.slice(undefined, column.timeLag).reduce(\n          function ({ count, sum }, entry) {\n            return entry[valueField] !== undefined &&\n            entry[valueField] !== null ?\n            { count: count + 1, sum: sum + entry[valueField] } :\n            { count, sum };\n          },\n          { count: 0, sum: 0 });\n\n          if (stats.count > 0) {\n            v = stats.sum / stats.count;\n          }\n        }\n      }\n\n      const color = colorFromBounds(v, column.bounds);\n\n      return (\n        ___EmotionJSX(\"span\", {\n          key: column.key,\n          \"data-value\": v,\n          style:\n          color && {\n            boxShadow: `inset 0px -2.5px 0px 0px ${color}`,\n            borderRight: '2px solid #fff' } },\n\n\n\n        errorMsg ||\n        ___EmotionJSX(\"span\", { style: { color } },\n        ___EmotionJSX(FormattedNumber, { num: v, format: column.d3format }))));\n\n\n\n\n    };\n\n    const renderLeftCell = (row) => {\n      const context = { metric: row };\n      const fullUrl = url ? Mustache.render(url, context) : null;\n\n      if (rowType === 'column') {\n        const column = row;\n        if (fullUrl) {\n          return (\n            ___EmotionJSX(\"a\", { href: fullUrl, rel: \"noopener noreferrer\", target: \"_blank\" },\n            column.label));\n\n\n        }\n        return column.label;\n      }\n\n      return (\n        ___EmotionJSX(MetricOption, {\n          metric: row,\n          url: fullUrl,\n          showFormula: false,\n          openInNewWindow: true }));\n\n\n    };\n\n    const entries = Object.keys(data).\n    sort().\n    map((time) => ({ ...data[time], time }));\n    const reversedEntries = entries.concat().reverse();\n\n    return rows.map((row) => {\n      const valueField = row.label || row.metric_name;\n      const cellValues = columnConfigs.reduce((acc, columnConfig) => {\n        if (columnConfig.colType === 'spark') {\n          return {\n            ...acc,\n            [columnConfig.key]: renderSparklineCell(\n            valueField,\n            columnConfig,\n            entries) };\n\n\n        }\n        return {\n          ...acc,\n          [columnConfig.key]: renderValueCell(\n          valueField,\n          columnConfig,\n          reversedEntries) };\n\n\n      }, {});\n      return { ...row, ...cellValues, metric: renderLeftCell(row) };\n    });\n  }, [columnConfigs, data, rowType, rows, url]);\n\n  const defaultSort =\n  rowType === 'column' && columnConfigs.length ?\n  [\n  {\n    id: columnConfigs[0].key,\n    desc: 'true' }] :\n\n\n  [];\n\n  return (\n    ___EmotionJSX(TimeTableStyles, { className: `time-table ${className}`, height: height },\n    ___EmotionJSX(TableView, {\n      className: \"table-no-hover\",\n      columns: memoizedColumns,\n      data: memoizedRows,\n      initialSortBy: defaultSort,\n      withPagination: false })));\n\n\n\n};\n\nTimeTable.propTypes = propTypes;\nTimeTable.defaultProps = defaultProps;\n\nexport default TimeTable;","map":null,"metadata":{},"sourceType":"module"}