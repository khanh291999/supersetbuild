{"ast":null,"code":"import _uniqWith from \"lodash/uniqWith\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport React, { useCallback, useEffect, useMemo, useState } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\n\nimport cx from 'classnames';\nimport Icons from 'src/components/Icons';\nimport { usePrevious } from 'src/common/hooks/usePrevious';\nimport DetailsPanelPopover from './DetailsPanel';\nimport { Pill } from './Styles';\nimport { IndicatorStatus, selectIndicatorsForChart, selectNativeIndicatorsForChart } from './selectors';\nimport { setDirectPathToChild } from '../../actions/dashboardState';import { jsx as ___EmotionJSX } from \"@emotion/react\";\nconst sortByStatus = (indicators) => {\n  const statuses = [\n  IndicatorStatus.Applied,\n  IndicatorStatus.Unset,\n  IndicatorStatus.Incompatible];\n\n  return indicators.sort((a, b) => statuses.indexOf(a.status) -\n  statuses.indexOf(b.status));\n};\nconst indicatorsInitialState = [];\nexport const FiltersBadge = ({ chartId }) => {var _dashboardInfo$metada, _dashboardInfo$metada4;\n  const dispatch = useDispatch();\n  const datasources = useSelector((state) => state.datasources);\n  const dashboardFilters = useSelector((state) => state.dashboardFilters);\n  const nativeFilters = useSelector((state) => {var _state$nativeFilters;return (_state$nativeFilters = state.nativeFilters) == null ? void 0 : _state$nativeFilters.filters;});\n  const dashboardInfo = useSelector((state) => state.dashboardInfo);\n  const charts = useSelector((state) => state.charts);\n  const present = useSelector((state) => state.dashboardLayout.present);\n  const dataMask = useSelector((state) => state.dataMask);\n  const [nativeIndicators, setNativeIndicators] = useState(indicatorsInitialState);\n  const [dashboardIndicators, setDashboardIndicators] = useState(indicatorsInitialState);\n  const onHighlightFilterSource = useCallback((path) => {\n    dispatch(setDirectPathToChild(path));\n  }, [dispatch]);\n  const chart = charts[chartId];\n  const prevChart = usePrevious(chart);\n  const prevChartStatus = prevChart == null ? void 0 : prevChart.chartStatus;\n  const prevDashboardFilters = usePrevious(dashboardFilters);\n  const prevDatasources = usePrevious(datasources);\n  const showIndicators = (chart == null ? void 0 : chart.chartStatus) && ['rendered', 'success'].includes(chart.chartStatus);\n  useEffect(() => {\n    if (!showIndicators && dashboardIndicators.length > 0) {\n      setDashboardIndicators(indicatorsInitialState);\n    } else\n    if (prevChartStatus !== 'success') {var _chart$queriesRespons, _chart$queriesRespons2, _prevChart$queriesRes, _prevChart$queriesRes2, _chart$queriesRespons3, _chart$queriesRespons4, _prevChart$queriesRes3, _prevChart$queriesRes4;\n      if ((chart == null ? void 0 : (_chart$queriesRespons = chart.queriesResponse) == null ? void 0 : (_chart$queriesRespons2 = _chart$queriesRespons[0]) == null ? void 0 : _chart$queriesRespons2.rejected_filters) !== (\n      prevChart == null ? void 0 : (_prevChart$queriesRes = prevChart.queriesResponse) == null ? void 0 : (_prevChart$queriesRes2 = _prevChart$queriesRes[0]) == null ? void 0 : _prevChart$queriesRes2.rejected_filters) ||\n      (chart == null ? void 0 : (_chart$queriesRespons3 = chart.queriesResponse) == null ? void 0 : (_chart$queriesRespons4 = _chart$queriesRespons3[0]) == null ? void 0 : _chart$queriesRespons4.applied_filters) !== (\n      prevChart == null ? void 0 : (_prevChart$queriesRes3 = prevChart.queriesResponse) == null ? void 0 : (_prevChart$queriesRes4 = _prevChart$queriesRes3[0]) == null ? void 0 : _prevChart$queriesRes4.applied_filters) ||\n      dashboardFilters !== prevDashboardFilters ||\n      datasources !== prevDatasources) {\n        setDashboardIndicators(selectIndicatorsForChart(chartId, dashboardFilters, datasources, chart));\n      }\n    }\n  }, [\n  chart,\n  chartId,\n  dashboardFilters,\n  dashboardIndicators.length,\n  datasources,\n  prevChart == null ? void 0 : prevChart.queriesResponse,\n  prevChartStatus,\n  prevDashboardFilters,\n  prevDatasources,\n  showIndicators]);\n\n  const prevNativeFilters = usePrevious(nativeFilters);\n  const prevDashboardLayout = usePrevious(present);\n  const prevDataMask = usePrevious(dataMask);\n  const prevChartConfig = usePrevious((_dashboardInfo$metada = dashboardInfo.metadata) == null ? void 0 : _dashboardInfo$metada.chart_configuration);\n  useEffect(() => {\n    if (!showIndicators && nativeIndicators.length > 0) {\n      setNativeIndicators(indicatorsInitialState);\n    } else\n    if (prevChartStatus !== 'success') {var _chart$queriesRespons5, _chart$queriesRespons6, _prevChart$queriesRes5, _prevChart$queriesRes6, _chart$queriesRespons7, _chart$queriesRespons8, _prevChart$queriesRes7, _prevChart$queriesRes8, _dashboardInfo$metada2;\n      if ((chart == null ? void 0 : (_chart$queriesRespons5 = chart.queriesResponse) == null ? void 0 : (_chart$queriesRespons6 = _chart$queriesRespons5[0]) == null ? void 0 : _chart$queriesRespons6.rejected_filters) !== (\n      prevChart == null ? void 0 : (_prevChart$queriesRes5 = prevChart.queriesResponse) == null ? void 0 : (_prevChart$queriesRes6 = _prevChart$queriesRes5[0]) == null ? void 0 : _prevChart$queriesRes6.rejected_filters) ||\n      (chart == null ? void 0 : (_chart$queriesRespons7 = chart.queriesResponse) == null ? void 0 : (_chart$queriesRespons8 = _chart$queriesRespons7[0]) == null ? void 0 : _chart$queriesRespons8.applied_filters) !== (\n      prevChart == null ? void 0 : (_prevChart$queriesRes7 = prevChart.queriesResponse) == null ? void 0 : (_prevChart$queriesRes8 = _prevChart$queriesRes7[0]) == null ? void 0 : _prevChart$queriesRes8.applied_filters) ||\n      nativeFilters !== prevNativeFilters ||\n      present !== prevDashboardLayout ||\n      dataMask !== prevDataMask ||\n      prevChartConfig !== ((_dashboardInfo$metada2 = dashboardInfo.metadata) == null ? void 0 : _dashboardInfo$metada2.chart_configuration)) {var _dashboardInfo$metada3;\n        setNativeIndicators(selectNativeIndicatorsForChart(nativeFilters, dataMask, chartId, chart, present, (_dashboardInfo$metada3 = dashboardInfo.metadata) == null ? void 0 : _dashboardInfo$metada3.chart_configuration));\n      }\n    }\n  }, [\n  chart,\n  chartId, (_dashboardInfo$metada4 =\n  dashboardInfo.metadata) == null ? void 0 : _dashboardInfo$metada4.chart_configuration,\n  dataMask,\n  nativeFilters,\n  nativeIndicators.length,\n  present,\n  prevChart == null ? void 0 : prevChart.queriesResponse,\n  prevChartConfig,\n  prevChartStatus,\n  prevDashboardLayout,\n  prevDataMask,\n  prevNativeFilters,\n  showIndicators]);\n\n  const indicators = useMemo(() => _uniqWith(sortByStatus([...dashboardIndicators, ...nativeIndicators]), (ind1, ind2) => ind1.column === ind2.column &&\n  ind1.name === ind2.name && (\n  ind1.status !== IndicatorStatus.Applied ||\n  ind2.status !== IndicatorStatus.Applied)), [dashboardIndicators, nativeIndicators]);\n  const appliedCrossFilterIndicators = useMemo(() => indicators.filter((indicator) => indicator.status === IndicatorStatus.CrossFilterApplied), [indicators]);\n  const appliedIndicators = useMemo(() => indicators.filter((indicator) => indicator.status === IndicatorStatus.Applied), [indicators]);\n  const unsetIndicators = useMemo(() => indicators.filter((indicator) => indicator.status === IndicatorStatus.Unset), [indicators]);\n  const incompatibleIndicators = useMemo(() => indicators.filter((indicator) => indicator.status === IndicatorStatus.Incompatible), [indicators]);\n  if (!appliedCrossFilterIndicators.length &&\n  !appliedIndicators.length &&\n  !incompatibleIndicators.length &&\n  !unsetIndicators.length) {\n    return null;\n  }\n  const isInactive = !appliedCrossFilterIndicators.length &&\n  !appliedIndicators.length &&\n  !incompatibleIndicators.length;\n  return ___EmotionJSX(DetailsPanelPopover, { appliedCrossFilterIndicators: appliedCrossFilterIndicators, appliedIndicators: appliedIndicators, unsetIndicators: unsetIndicators, incompatibleIndicators: incompatibleIndicators, onHighlightFilterSource: onHighlightFilterSource },\n  ___EmotionJSX(Pill, { className: cx('filter-counts', !!incompatibleIndicators.length && 'has-incompatible-filters', !!appliedCrossFilterIndicators.length && 'has-cross-filters', isInactive && 'filters-inactive') },\n  ___EmotionJSX(Icons.Filter, { iconSize: \"m\" }),\n  !isInactive && ___EmotionJSX(\"span\", null,\n  appliedIndicators.length + appliedCrossFilterIndicators.length),\n\n  incompatibleIndicators.length ? ___EmotionJSX(React.Fragment, null,\n  ' ',\n  ___EmotionJSX(Icons.AlertSolid, null),\n  ___EmotionJSX(\"span\", null,\n  incompatibleIndicators.length)) :\n\n  null));\n\n\n};\nexport default /*#__PURE__*/React.memo(FiltersBadge);","map":null,"metadata":{},"sourceType":"module"}