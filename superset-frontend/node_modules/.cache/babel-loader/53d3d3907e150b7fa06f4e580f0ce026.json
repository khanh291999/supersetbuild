{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport shortid from 'shortid';\nimport JSONbig from 'json-bigint';\nimport { t, SupersetClient } from '@superset-ui/core';\nimport invert from 'lodash/invert';\nimport mapKeys from 'lodash/mapKeys';\nimport { isFeatureEnabled, FeatureFlag } from 'src/featureFlags';\n\nimport { now } from 'src/modules/dates';\nimport {\naddDangerToast as addDangerToastAction,\naddInfoToast as addInfoToastAction,\naddSuccessToast as addSuccessToastAction,\naddWarningToast as addWarningToastAction } from\n'src/components/MessageToasts/actions';\nimport { getClientErrorObject } from 'src/utils/getClientErrorObject';\nimport COMMON_ERR_MESSAGES from 'src/utils/errorMessages';\n\nexport const RESET_STATE = 'RESET_STATE';\nexport const ADD_QUERY_EDITOR = 'ADD_QUERY_EDITOR';\nexport const UPDATE_QUERY_EDITOR = 'UPDATE_QUERY_EDITOR';\nexport const QUERY_EDITOR_SAVED = 'QUERY_EDITOR_SAVED';\nexport const CLONE_QUERY_TO_NEW_TAB = 'CLONE_QUERY_TO_NEW_TAB';\nexport const REMOVE_QUERY_EDITOR = 'REMOVE_QUERY_EDITOR';\nexport const MERGE_TABLE = 'MERGE_TABLE';\nexport const REMOVE_TABLE = 'REMOVE_TABLE';\nexport const END_QUERY = 'END_QUERY';\nexport const REMOVE_QUERY = 'REMOVE_QUERY';\nexport const EXPAND_TABLE = 'EXPAND_TABLE';\nexport const COLLAPSE_TABLE = 'COLLAPSE_TABLE';\nexport const QUERY_EDITOR_SETDB = 'QUERY_EDITOR_SETDB';\nexport const QUERY_EDITOR_SET_SCHEMA = 'QUERY_EDITOR_SET_SCHEMA';\nexport const QUERY_EDITOR_SET_SCHEMA_OPTIONS =\n'QUERY_EDITOR_SET_SCHEMA_OPTIONS';\nexport const QUERY_EDITOR_SET_TABLE_OPTIONS = 'QUERY_EDITOR_SET_TABLE_OPTIONS';\nexport const QUERY_EDITOR_SET_TITLE = 'QUERY_EDITOR_SET_TITLE';\nexport const QUERY_EDITOR_SET_AUTORUN = 'QUERY_EDITOR_SET_AUTORUN';\nexport const QUERY_EDITOR_SET_SQL = 'QUERY_EDITOR_SET_SQL';\nexport const QUERY_EDITOR_SET_QUERY_LIMIT = 'QUERY_EDITOR_SET_QUERY_LIMIT';\nexport const QUERY_EDITOR_SET_TEMPLATE_PARAMS =\n'QUERY_EDITOR_SET_TEMPLATE_PARAMS';\nexport const QUERY_EDITOR_SET_SELECTED_TEXT = 'QUERY_EDITOR_SET_SELECTED_TEXT';\nexport const QUERY_EDITOR_SET_FUNCTION_NAMES =\n'QUERY_EDITOR_SET_FUNCTION_NAMES';\nexport const QUERY_EDITOR_PERSIST_HEIGHT = 'QUERY_EDITOR_PERSIST_HEIGHT';\nexport const QUERY_EDITOR_TOGGLE_LEFT_BAR = 'QUERY_EDITOR_TOGGLE_LEFT_BAR';\nexport const MIGRATE_QUERY_EDITOR = 'MIGRATE_QUERY_EDITOR';\nexport const MIGRATE_TAB_HISTORY = 'MIGRATE_TAB_HISTORY';\nexport const MIGRATE_TABLE = 'MIGRATE_TABLE';\nexport const MIGRATE_QUERY = 'MIGRATE_QUERY';\n\nexport const SET_DATABASES = 'SET_DATABASES';\nexport const SET_ACTIVE_QUERY_EDITOR = 'SET_ACTIVE_QUERY_EDITOR';\nexport const LOAD_QUERY_EDITOR = 'LOAD_QUERY_EDITOR';\nexport const SET_TABLES = 'SET_TABLES';\nexport const SET_ACTIVE_SOUTHPANE_TAB = 'SET_ACTIVE_SOUTHPANE_TAB';\nexport const REFRESH_QUERIES = 'REFRESH_QUERIES';\nexport const SET_USER_OFFLINE = 'SET_USER_OFFLINE';\nexport const RUN_QUERY = 'RUN_QUERY';\nexport const START_QUERY = 'START_QUERY';\nexport const STOP_QUERY = 'STOP_QUERY';\nexport const REQUEST_QUERY_RESULTS = 'REQUEST_QUERY_RESULTS';\nexport const QUERY_SUCCESS = 'QUERY_SUCCESS';\nexport const QUERY_FAILED = 'QUERY_FAILED';\nexport const CLEAR_QUERY_RESULTS = 'CLEAR_QUERY_RESULTS';\nexport const REMOVE_DATA_PREVIEW = 'REMOVE_DATA_PREVIEW';\nexport const CHANGE_DATA_PREVIEW_ID = 'CHANGE_DATA_PREVIEW_ID';\n\nexport const START_QUERY_VALIDATION = 'START_QUERY_VALIDATION';\nexport const QUERY_VALIDATION_RETURNED = 'QUERY_VALIDATION_RETURNED';\nexport const QUERY_VALIDATION_FAILED = 'QUERY_VALIDATION_FAILED';\nexport const COST_ESTIMATE_STARTED = 'COST_ESTIMATE_STARTED';\nexport const COST_ESTIMATE_RETURNED = 'COST_ESTIMATE_RETURNED';\nexport const COST_ESTIMATE_FAILED = 'COST_ESTIMATE_FAILED';\n\nexport const CREATE_DATASOURCE_STARTED = 'CREATE_DATASOURCE_STARTED';\nexport const CREATE_DATASOURCE_SUCCESS = 'CREATE_DATASOURCE_SUCCESS';\nexport const CREATE_DATASOURCE_FAILED = 'CREATE_DATASOURCE_FAILED';\n\nexport const addInfoToast = addInfoToastAction;\nexport const addSuccessToast = addSuccessToastAction;\nexport const addDangerToast = addDangerToastAction;\nexport const addWarningToast = addWarningToastAction;\n\nexport const CtasEnum = {\n  TABLE: 'TABLE',\n  VIEW: 'VIEW' };\n\nconst ERR_MSG_CANT_LOAD_QUERY = t(\"The query couldn't be loaded\");\n\n// a map of SavedQuery field names to the different names used client-side,\n// because for now making the names consistent is too complicated\n// so it might as well only happen in one place\nconst queryClientMapping = {\n  id: 'remoteId',\n  db_id: 'dbId',\n  client_id: 'id',\n  label: 'title' };\n\nconst queryServerMapping = invert(queryClientMapping);\n\n// uses a mapping like those above to convert object key names to another style\nconst fieldConverter = (mapping) => (obj) =>\nmapKeys(obj, (value, key) => key in mapping ? mapping[key] : key);\n\nconst convertQueryToServer = fieldConverter(queryServerMapping);\nconst convertQueryToClient = fieldConverter(queryClientMapping);\n\nexport function resetState() {\n  return { type: RESET_STATE };\n}\n\nexport function startQueryValidation(query) {\n  Object.assign(query, {\n    id: query.id ? query.id : shortid.generate() });\n\n  return { type: START_QUERY_VALIDATION, query };\n}\n\nexport function queryValidationReturned(query, results) {\n  return { type: QUERY_VALIDATION_RETURNED, query, results };\n}\n\nexport function queryValidationFailed(query, message, error) {\n  return { type: QUERY_VALIDATION_FAILED, query, message, error };\n}\n\nexport function updateQueryEditor(alterations) {\n  return { type: UPDATE_QUERY_EDITOR, alterations };\n}\n\nexport function scheduleQuery(query) {\n  return (dispatch) =>\n  SupersetClient.post({\n    endpoint: '/savedqueryviewapi/api/create',\n    postPayload: query,\n    stringify: false }).\n\n  then(() =>\n  dispatch(\n  addSuccessToast(\n  t(\n  'Your query has been scheduled. To see details of your query, navigate to Saved queries')))).\n\n\n\n\n  catch(() =>\n  dispatch(addDangerToast(t('Your query could not be scheduled'))));\n\n}\n\nexport function estimateQueryCost(query) {\n  const { dbId, schema, sql, templateParams } = query;\n  const endpoint =\n  schema === null ?\n  `/superset/estimate_query_cost/${dbId}/` :\n  `/superset/estimate_query_cost/${dbId}/${schema}/`;\n  return (dispatch) =>\n  Promise.all([\n  dispatch({ type: COST_ESTIMATE_STARTED, query }),\n  SupersetClient.post({\n    endpoint,\n    postPayload: {\n      sql,\n      templateParams: JSON.parse(templateParams || '{}') } }).\n\n\n  then(({ json }) =>\n  dispatch({ type: COST_ESTIMATE_RETURNED, query, json })).\n\n  catch((response) =>\n  getClientErrorObject(response).then((error) => {\n    const message =\n    error.error ||\n    error.statusText ||\n    t('Failed at retrieving results');\n    return dispatch({\n      type: COST_ESTIMATE_FAILED,\n      query,\n      error: message });\n\n  }))]);\n\n\n}\n\nexport function startQuery(query) {\n  Object.assign(query, {\n    id: query.id ? query.id : shortid.generate(),\n    progress: 0,\n    startDttm: now(),\n    state: query.runAsync ? 'pending' : 'running',\n    cached: false });\n\n  return { type: START_QUERY, query };\n}\n\nexport function querySuccess(query, results) {\n  return function (dispatch) {\n    const sync =\n    !query.isDataPreview &&\n    isFeatureEnabled(FeatureFlag.SQLLAB_BACKEND_PERSISTENCE) ?\n    SupersetClient.put({\n      endpoint: encodeURI(`/tabstateview/${results.query.sqlEditorId}`),\n      postPayload: { latest_query_id: query.id } }) :\n\n    Promise.resolve();\n\n    return sync.\n    then(() => dispatch({ type: QUERY_SUCCESS, query, results })).\n    catch(() =>\n    dispatch(\n    addDangerToast(\n    t(\n    'An error occurred while storing the latest query id in the backend. ' +\n    'Please contact your administrator if this problem persists.'))));\n\n\n\n\n  };\n}\n\nexport function queryFailed(query, msg, link, errors) {\n  return function (dispatch) {\n    const sync =\n    !query.isDataPreview &&\n    isFeatureEnabled(FeatureFlag.SQLLAB_BACKEND_PERSISTENCE) ?\n    SupersetClient.put({\n      endpoint: encodeURI(`/tabstateview/${query.sqlEditorId}`),\n      postPayload: { latest_query_id: query.id } }) :\n\n    Promise.resolve();\n\n    return (\n      sync.\n      catch(() =>\n      dispatch(\n      addDangerToast(\n      t(\n      'An error occurred while storing the latest query id in the backend. ' +\n      'Please contact your administrator if this problem persists.'))))\n\n\n\n\n      // We should always show the error message, even if we couldn't sync the\n      // state to the backend\n      .then(() => dispatch({ type: QUERY_FAILED, query, msg, link, errors })));\n\n  };\n}\n\nexport function stopQuery(query) {\n  return { type: STOP_QUERY, query };\n}\n\nexport function clearQueryResults(query) {\n  return { type: CLEAR_QUERY_RESULTS, query };\n}\n\nexport function removeDataPreview(table) {\n  return { type: REMOVE_DATA_PREVIEW, table };\n}\n\nexport function requestQueryResults(query) {\n  return { type: REQUEST_QUERY_RESULTS, query };\n}\n\nexport function fetchQueryResults(query, displayLimit) {\n  return function (dispatch) {\n    dispatch(requestQueryResults(query));\n\n    return SupersetClient.get({\n      endpoint: `/superset/results/${query.resultsKey}/?rows=${displayLimit}`,\n      parseMethod: 'text' }).\n\n    then(({ text = '{}' }) => {\n      const bigIntJson = JSONbig.parse(text);\n      return dispatch(querySuccess(query, bigIntJson));\n    }).\n    catch((response) =>\n    getClientErrorObject(response).then((error) => {\n      const message =\n      error.error ||\n      error.statusText ||\n      t('Failed at retrieving results');\n\n      return dispatch(\n      queryFailed(query, message, error.link, error.errors));\n\n    }));\n\n  };\n}\n\nexport function runQuery(query) {\n  return function (dispatch) {\n    dispatch(startQuery(query));\n    const postPayload = {\n      client_id: query.id,\n      database_id: query.dbId,\n      json: true,\n      runAsync: query.runAsync,\n      schema: query.schema,\n      sql: query.sql,\n      sql_editor_id: query.sqlEditorId,\n      tab: query.tab,\n      tmp_table_name: query.tempTable,\n      select_as_cta: query.ctas,\n      ctas_method: query.ctas_method,\n      templateParams: query.templateParams,\n      queryLimit: query.queryLimit,\n      expand_data: true };\n\n\n    return SupersetClient.post({\n      endpoint: '/superset/sql_json/',\n      body: JSON.stringify(postPayload),\n      headers: { 'Content-Type': 'application/json' },\n      parseMethod: 'text' }).\n\n    then(({ text = '{}' }) => {\n      if (!query.runAsync) {\n        const bigIntJson = JSONbig.parse(text);\n        dispatch(querySuccess(query, bigIntJson));\n      }\n    }).\n    catch((response) =>\n    getClientErrorObject(response).then((error) => {\n      let message = error.error || error.statusText || t('Unknown error');\n      if (message.includes('CSRF token')) {\n        message = t(COMMON_ERR_MESSAGES.SESSION_TIMED_OUT);\n      }\n      dispatch(queryFailed(query, message, error.link, error.errors));\n    }));\n\n  };\n}\n\nexport function reRunQuery(query) {\n  // run Query with a new id\n  return function (dispatch) {\n    dispatch(runQuery({ ...query, id: shortid.generate() }));\n  };\n}\n\nexport function validateQuery(query) {\n  return function (dispatch) {\n    dispatch(startQueryValidation(query));\n\n    const postPayload = {\n      client_id: query.id,\n      database_id: query.dbId,\n      json: true,\n      schema: query.schema,\n      sql: query.sql,\n      sql_editor_id: query.sqlEditorId,\n      templateParams: query.templateParams,\n      validate_only: true };\n\n\n    return SupersetClient.post({\n      endpoint: `/superset/validate_sql_json/${window.location.search}`,\n      postPayload,\n      stringify: false }).\n\n    then(({ json }) => dispatch(queryValidationReturned(query, json))).\n    catch((response) =>\n    getClientErrorObject(response).then((error) => {\n      let message = error.error || error.statusText || t('Unknown error');\n      if (message.includes('CSRF token')) {\n        message = t(COMMON_ERR_MESSAGES.SESSION_TIMED_OUT);\n      }\n      dispatch(queryValidationFailed(query, message, error));\n    }));\n\n  };\n}\n\nexport function postStopQuery(query) {\n  return function (dispatch) {\n    return SupersetClient.post({\n      endpoint: '/superset/stop_query/',\n      postPayload: { client_id: query.id },\n      stringify: false }).\n\n    then(() => dispatch(stopQuery(query))).\n    then(() => dispatch(addSuccessToast(t('Query was stopped.')))).\n    catch(() =>\n    dispatch(\n    addDangerToast(`${t('Failed at stopping query. ')}'${query.id}'`)));\n\n\n  };\n}\n\nexport function setDatabases(databases) {\n  return { type: SET_DATABASES, databases };\n}\n\nfunction migrateTable(table, queryEditorId, dispatch) {\n  return SupersetClient.post({\n    endpoint: encodeURI('/tableschemaview/'),\n    postPayload: { table: { ...table, queryEditorId } } }).\n\n  then(({ json }) => {\n    const newTable = {\n      ...table,\n      id: json.id,\n      queryEditorId };\n\n    return dispatch({ type: MIGRATE_TABLE, oldTable: table, newTable });\n  }).\n  catch(() =>\n  dispatch(\n  addWarningToast(\n  t(\n  'Unable to migrate table schema state to backend. Superset will retry ' +\n  'later. Please contact your administrator if this problem persists.'))));\n\n\n\n\n}\n\nfunction migrateQuery(queryId, queryEditorId, dispatch) {\n  return SupersetClient.post({\n    endpoint: encodeURI(`/tabstateview/${queryEditorId}/migrate_query`),\n    postPayload: { queryId } }).\n\n  then(() => dispatch({ type: MIGRATE_QUERY, queryId, queryEditorId })).\n  catch(() =>\n  dispatch(\n  addWarningToast(\n  t(\n  'Unable to migrate query state to backend. Superset will retry later. ' +\n  'Please contact your administrator if this problem persists.'))));\n\n\n\n\n}\n\nexport function migrateQueryEditorFromLocalStorage(\nqueryEditor,\ntables,\nqueries)\n{\n  return function (dispatch) {\n    return SupersetClient.post({\n      endpoint: '/tabstateview/',\n      postPayload: { queryEditor } }).\n\n    then(({ json }) => {\n      const newQueryEditor = {\n        ...queryEditor,\n        id: json.id.toString() };\n\n      dispatch({\n        type: MIGRATE_QUERY_EDITOR,\n        oldQueryEditor: queryEditor,\n        newQueryEditor });\n\n      dispatch({\n        type: MIGRATE_TAB_HISTORY,\n        oldId: queryEditor.id,\n        newId: newQueryEditor.id });\n\n      return Promise.all([\n      ...tables.map((table) =>\n      migrateTable(table, newQueryEditor.id, dispatch)),\n\n      ...queries.map((query) =>\n      migrateQuery(query.id, newQueryEditor.id, dispatch))]);\n\n\n    }).\n    catch(() =>\n    dispatch(\n    addWarningToast(\n    t(\n    'Unable to migrate query editor state to backend. Superset will retry ' +\n    'later. Please contact your administrator if this problem persists.'))));\n\n\n\n\n  };\n}\n\nexport function addQueryEditor(queryEditor) {\n  return function (dispatch) {\n    const sync = isFeatureEnabled(FeatureFlag.SQLLAB_BACKEND_PERSISTENCE) ?\n    SupersetClient.post({\n      endpoint: '/tabstateview/',\n      postPayload: { queryEditor } }) :\n\n    Promise.resolve({ json: { id: shortid.generate() } });\n\n    return sync.\n    then(({ json }) => {\n      const newQueryEditor = {\n        ...queryEditor,\n        id: json.id.toString() };\n\n      return dispatch({\n        type: ADD_QUERY_EDITOR,\n        queryEditor: newQueryEditor });\n\n    }).\n    catch(() =>\n    dispatch(\n    addDangerToast(\n    t(\n    'Unable to add a new tab to the backend. Please contact your administrator.'))));\n\n\n\n\n  };\n}\n\nexport function cloneQueryToNewTab(query, autorun) {\n  return function (dispatch, getState) {\n    const state = getState();\n    const { queryEditors, tabHistory } = state.sqlLab;\n    const sourceQueryEditor = queryEditors.find(\n    (qe) => qe.id === tabHistory[tabHistory.length - 1]);\n\n    const queryEditor = {\n      title: t('Copy of %s', sourceQueryEditor.title),\n      dbId: query.dbId ? query.dbId : null,\n      schema: query.schema ? query.schema : null,\n      autorun,\n      sql: query.sql,\n      queryLimit: sourceQueryEditor.queryLimit,\n      maxRow: sourceQueryEditor.maxRow,\n      templateParams: sourceQueryEditor.templateParams };\n\n    return dispatch(addQueryEditor(queryEditor));\n  };\n}\n\nexport function setActiveQueryEditor(queryEditor) {\n  return function (dispatch) {\n    const sync = isFeatureEnabled(FeatureFlag.SQLLAB_BACKEND_PERSISTENCE) ?\n    SupersetClient.post({\n      endpoint: encodeURI(`/tabstateview/${queryEditor.id}/activate`) }) :\n\n    Promise.resolve();\n\n    return sync.\n    then(() => dispatch({ type: SET_ACTIVE_QUERY_EDITOR, queryEditor })).\n    catch((response) => {\n      if (response.status !== 404) {\n        return dispatch(\n        addDangerToast(\n        t(\n        'An error occurred while setting the active tab. Please contact ' +\n        'your administrator.')));\n\n\n\n      }\n      return dispatch({ type: REMOVE_QUERY_EDITOR, queryEditor });\n    });\n  };\n}\n\nexport function loadQueryEditor(queryEditor) {\n  return { type: LOAD_QUERY_EDITOR, queryEditor };\n}\n\nexport function setTables(tableSchemas) {\n  const tables = tableSchemas.\n  filter((tableSchema) => tableSchema.description !== null).\n  map((tableSchema) => {\n    const {\n      columns,\n      selectStar,\n      primaryKey,\n      foreignKeys,\n      indexes,\n      dataPreviewQueryId } =\n    tableSchema.description;\n    return {\n      dbId: tableSchema.database_id,\n      queryEditorId: tableSchema.tab_state_id.toString(),\n      schema: tableSchema.schema,\n      name: tableSchema.table,\n      expanded: tableSchema.expanded,\n      id: tableSchema.id,\n      dataPreviewQueryId,\n      columns,\n      selectStar,\n      primaryKey,\n      foreignKeys,\n      indexes,\n      isMetadataLoading: false,\n      isExtraMetadataLoading: false };\n\n  });\n  return { type: SET_TABLES, tables };\n}\n\nexport function switchQueryEditor(queryEditor, displayLimit) {\n  return function (dispatch) {\n    if (\n    isFeatureEnabled(FeatureFlag.SQLLAB_BACKEND_PERSISTENCE) &&\n    !queryEditor.loaded)\n    {\n      SupersetClient.get({\n        endpoint: encodeURI(`/tabstateview/${queryEditor.id}`) }).\n\n      then(({ json }) => {\n        const loadedQueryEditor = {\n          id: json.id.toString(),\n          loaded: true,\n          title: json.label,\n          sql: json.sql,\n          selectedText: null,\n          latestQueryId: json.latest_query ? json.latest_query.id : null,\n          autorun: json.autorun,\n          dbId: json.database_id,\n          templateParams: json.template_params,\n          schema: json.schema,\n          queryLimit: json.query_limit,\n          validationResult: {\n            id: null,\n            errors: [],\n            completed: false },\n\n          hideLeftBar: json.hide_left_bar };\n\n        dispatch(loadQueryEditor(loadedQueryEditor));\n        dispatch(setTables(json.table_schemas || []));\n        dispatch(setActiveQueryEditor(loadedQueryEditor));\n        if (json.latest_query && json.latest_query.resultsKey) {\n          dispatch(fetchQueryResults(json.latest_query, displayLimit));\n        }\n      }).\n      catch((response) => {\n        if (response.status !== 404) {\n          return dispatch(\n          addDangerToast(t('An error occurred while fetching tab state')));\n\n        }\n        return dispatch({ type: REMOVE_QUERY_EDITOR, queryEditor });\n      });\n    } else {\n      dispatch(setActiveQueryEditor(queryEditor));\n    }\n  };\n}\n\nexport function setActiveSouthPaneTab(tabId) {\n  return { type: SET_ACTIVE_SOUTHPANE_TAB, tabId };\n}\n\nexport function toggleLeftBar(queryEditor) {\n  const hideLeftBar = !queryEditor.hideLeftBar;\n  return function (dispatch) {\n    const sync = isFeatureEnabled(FeatureFlag.SQLLAB_BACKEND_PERSISTENCE) ?\n    SupersetClient.put({\n      endpoint: encodeURI(`/tabstateview/${queryEditor.id}`),\n      postPayload: { hide_left_bar: hideLeftBar } }) :\n\n    Promise.resolve();\n\n    return sync.\n    then(() =>\n    dispatch({\n      type: QUERY_EDITOR_TOGGLE_LEFT_BAR,\n      queryEditor,\n      hideLeftBar })).\n\n\n    catch(() =>\n    dispatch(\n    addDangerToast(\n    t(\n    'An error occurred while hiding the left bar. Please contact your administrator.'))));\n\n\n\n\n  };\n}\n\nexport function removeQueryEditor(queryEditor) {\n  return function (dispatch) {\n    const sync = isFeatureEnabled(FeatureFlag.SQLLAB_BACKEND_PERSISTENCE) ?\n    SupersetClient.delete({\n      endpoint: encodeURI(`/tabstateview/${queryEditor.id}`) }) :\n\n    Promise.resolve();\n\n    return sync.\n    then(() => dispatch({ type: REMOVE_QUERY_EDITOR, queryEditor })).\n    catch(() =>\n    dispatch(\n    addDangerToast(\n    t(\n    'An error occurred while removing tab. Please contact your administrator.'))));\n\n\n\n\n  };\n}\n\nexport function removeQuery(query) {\n  return function (dispatch) {\n    const sync = isFeatureEnabled(FeatureFlag.SQLLAB_BACKEND_PERSISTENCE) ?\n    SupersetClient.delete({\n      endpoint: encodeURI(\n      `/tabstateview/${query.sqlEditorId}/query/${query.id}`) }) :\n\n\n    Promise.resolve();\n\n    return sync.\n    then(() => dispatch({ type: REMOVE_QUERY, query })).\n    catch(() =>\n    dispatch(\n    addDangerToast(\n    t(\n    'An error occurred while removing query. Please contact your administrator.'))));\n\n\n\n\n  };\n}\n\nexport function queryEditorSetDb(queryEditor, dbId) {\n  return function (dispatch) {\n    const sync = isFeatureEnabled(FeatureFlag.SQLLAB_BACKEND_PERSISTENCE) ?\n    SupersetClient.put({\n      endpoint: encodeURI(`/tabstateview/${queryEditor.id}`),\n      postPayload: { database_id: dbId } }) :\n\n    Promise.resolve();\n\n    return sync.\n    then(() => dispatch({ type: QUERY_EDITOR_SETDB, queryEditor, dbId })).\n    catch(() =>\n    dispatch(\n    addDangerToast(\n    t(\n    'An error occurred while setting the tab database ID. Please contact your administrator.'))));\n\n\n\n\n  };\n}\n\nexport function queryEditorSetSchema(queryEditor, schema) {\n  return function (dispatch) {\n    const sync = isFeatureEnabled(FeatureFlag.SQLLAB_BACKEND_PERSISTENCE) ?\n    SupersetClient.put({\n      endpoint: encodeURI(`/tabstateview/${queryEditor.id}`),\n      postPayload: { schema } }) :\n\n    Promise.resolve();\n\n    return sync.\n    then(() =>\n    dispatch({ type: QUERY_EDITOR_SET_SCHEMA, queryEditor, schema })).\n\n    catch(() =>\n    dispatch(\n    addDangerToast(\n    t(\n    'An error occurred while setting the tab schema. Please contact your administrator.'))));\n\n\n\n\n  };\n}\n\nexport function queryEditorSetSchemaOptions(queryEditor, options) {\n  return { type: QUERY_EDITOR_SET_SCHEMA_OPTIONS, queryEditor, options };\n}\n\nexport function queryEditorSetTableOptions(queryEditor, options) {\n  return { type: QUERY_EDITOR_SET_TABLE_OPTIONS, queryEditor, options };\n}\n\nexport function queryEditorSetAutorun(queryEditor, autorun) {\n  return function (dispatch) {\n    const sync = isFeatureEnabled(FeatureFlag.SQLLAB_BACKEND_PERSISTENCE) ?\n    SupersetClient.put({\n      endpoint: encodeURI(`/tabstateview/${queryEditor.id}`),\n      postPayload: { autorun } }) :\n\n    Promise.resolve();\n\n    return sync.\n    then(() =>\n    dispatch({ type: QUERY_EDITOR_SET_AUTORUN, queryEditor, autorun })).\n\n    catch(() =>\n    dispatch(\n    addDangerToast(\n    t(\n    'An error occurred while setting the tab autorun. Please contact your administrator.'))));\n\n\n\n\n  };\n}\n\nexport function queryEditorSetTitle(queryEditor, title) {\n  return function (dispatch) {\n    const sync = isFeatureEnabled(FeatureFlag.SQLLAB_BACKEND_PERSISTENCE) ?\n    SupersetClient.put({\n      endpoint: encodeURI(`/tabstateview/${queryEditor.id}`),\n      postPayload: { label: title } }) :\n\n    Promise.resolve();\n\n    return sync.\n    then(() =>\n    dispatch({ type: QUERY_EDITOR_SET_TITLE, queryEditor, title })).\n\n    catch(() =>\n    dispatch(\n    addDangerToast(\n    t(\n    'An error occurred while setting the tab title. Please contact your administrator.'))));\n\n\n\n\n  };\n}\n\nexport function saveQuery(query) {\n  return (dispatch) =>\n  SupersetClient.post({\n    endpoint: '/savedqueryviewapi/api/create',\n    postPayload: convertQueryToServer(query),\n    stringify: false }).\n\n  then((result) => {\n    dispatch({\n      type: QUERY_EDITOR_SAVED,\n      query,\n      result: convertQueryToClient(result.json.item) });\n\n    dispatch(addSuccessToast(t('Your query was saved')));\n    dispatch(queryEditorSetTitle(query, query.title));\n  }).\n  catch(() =>\n  dispatch(addDangerToast(t('Your query could not be saved'))));\n\n}\n\nexport function updateSavedQuery(query) {\n  return (dispatch) =>\n  SupersetClient.put({\n    endpoint: `/savedqueryviewapi/api/update/${query.remoteId}`,\n    postPayload: convertQueryToServer(query),\n    stringify: false }).\n\n  then(() => {\n    dispatch(addSuccessToast(t('Your query was updated')));\n    dispatch(queryEditorSetTitle(query, query.title));\n  }).\n  catch(() =>\n  dispatch(addDangerToast(t('Your query could not be updated')))).\n\n  then(() => dispatch(updateQueryEditor(query)));\n}\n\nexport function queryEditorSetSql(queryEditor, sql) {\n  return function (dispatch) {\n    // saved query and set tab state use this action\n    dispatch({ type: QUERY_EDITOR_SET_SQL, queryEditor, sql });\n    if (isFeatureEnabled(FeatureFlag.SQLLAB_BACKEND_PERSISTENCE)) {\n      return SupersetClient.put({\n        endpoint: encodeURI(`/tabstateview/${queryEditor.id}`),\n        postPayload: { sql, latest_query_id: queryEditor.latestQueryId } }).\n      catch(() =>\n      dispatch(\n      addDangerToast(\n      t(\n      'An error occurred while storing your query in the backend. To ' +\n      'avoid losing your changes, please save your query using the ' +\n      '\"Save Query\" button.'))));\n\n\n\n\n    }\n    return Promise.resolve();\n  };\n}\n\nexport function queryEditorSetQueryLimit(queryEditor, queryLimit) {\n  return function (dispatch) {\n    const sync = isFeatureEnabled(FeatureFlag.SQLLAB_BACKEND_PERSISTENCE) ?\n    SupersetClient.put({\n      endpoint: encodeURI(`/tabstateview/${queryEditor.id}`),\n      postPayload: { query_limit: queryLimit } }) :\n\n    Promise.resolve();\n\n    return sync.\n    then(() =>\n    dispatch({\n      type: QUERY_EDITOR_SET_QUERY_LIMIT,\n      queryEditor,\n      queryLimit })).\n\n\n    catch(() =>\n    dispatch(\n    addDangerToast(\n    t(\n    'An error occurred while setting the tab title. Please contact your administrator.'))));\n\n\n\n\n  };\n}\n\nexport function queryEditorSetTemplateParams(queryEditor, templateParams) {\n  return function (dispatch) {\n    dispatch({\n      type: QUERY_EDITOR_SET_TEMPLATE_PARAMS,\n      queryEditor,\n      templateParams });\n\n    const sync = isFeatureEnabled(FeatureFlag.SQLLAB_BACKEND_PERSISTENCE) ?\n    SupersetClient.put({\n      endpoint: encodeURI(`/tabstateview/${queryEditor.id}`),\n      postPayload: { template_params: templateParams } }) :\n\n    Promise.resolve();\n\n    return sync.catch(() =>\n    dispatch(\n    addDangerToast(\n    t(\n    'An error occurred while setting the tab template parameters. ' +\n    'Please contact your administrator.'))));\n\n\n\n\n  };\n}\n\nexport function queryEditorSetSelectedText(queryEditor, sql) {\n  return { type: QUERY_EDITOR_SET_SELECTED_TEXT, queryEditor, sql };\n}\n\nexport function mergeTable(table, query) {\n  return { type: MERGE_TABLE, table, query };\n}\n\nfunction getTableMetadata(table, query, dispatch) {\n  return SupersetClient.get({\n    endpoint: encodeURI(\n    `/api/v1/database/${query.dbId}/table/${encodeURIComponent(\n    table.name)\n    }/${encodeURIComponent(table.schema)}/`) }).\n\n\n  then(({ json }) => {\n    const dataPreviewQuery = {\n      id: shortid.generate(),\n      dbId: query.dbId,\n      sql: json.selectStar,\n      tableName: table.name,\n      sqlEditorId: null,\n      tab: '',\n      runAsync: false,\n      ctas: false,\n      isDataPreview: true };\n\n    const newTable = {\n      ...table,\n      ...json,\n      expanded: true,\n      isMetadataLoading: false,\n      dataPreviewQueryId: dataPreviewQuery.id };\n\n    Promise.all([\n    dispatch(mergeTable(newTable, dataPreviewQuery)), // Merge table to tables in state\n    dispatch(runQuery(dataPreviewQuery)) // Run query to get preview data for table\n    ]);\n    return newTable;\n  }).\n  catch(() =>\n  Promise.all([\n  dispatch(\n  mergeTable({\n    ...table,\n    isMetadataLoading: false })),\n\n\n  dispatch(\n  addDangerToast(t('An error occurred while fetching table metadata')))]));\n\n\n\n}\n\nfunction getTableExtendedMetadata(table, query, dispatch) {\n  return SupersetClient.get({\n    endpoint: encodeURI(\n    `/superset/extra_table_metadata/${query.dbId}/` +\n    `${encodeURIComponent(table.name)}/${encodeURIComponent(\n    table.schema)\n    }/`) }).\n\n\n  then(({ json }) => {\n    dispatch(\n    mergeTable({ ...table, ...json, isExtraMetadataLoading: false }));\n\n    return json;\n  }).\n  catch(() =>\n  Promise.all([\n  dispatch(mergeTable({ ...table, isExtraMetadataLoading: false })),\n  dispatch(\n  addDangerToast(t('An error occurred while fetching table metadata')))]));\n\n\n\n}\n\nexport function addTable(query, tableName, schemaName) {\n  return function (dispatch) {\n    const table = {\n      dbId: query.dbId,\n      queryEditorId: query.id,\n      schema: schemaName,\n      name: tableName };\n\n    dispatch(\n    mergeTable({\n      ...table,\n      isMetadataLoading: true,\n      isExtraMetadataLoading: true,\n      expanded: true }));\n\n\n\n    return Promise.all([\n    getTableMetadata(table, query, dispatch),\n    getTableExtendedMetadata(table, query, dispatch)]).\n    then(([newTable, json]) => {\n      const sync = isFeatureEnabled(FeatureFlag.SQLLAB_BACKEND_PERSISTENCE) ?\n      SupersetClient.post({\n        endpoint: encodeURI('/tableschemaview/'),\n        postPayload: { table: { ...newTable, ...json } } }) :\n\n      Promise.resolve({ json: { id: shortid.generate() } });\n\n      return sync.\n      then(({ json: resultJson }) =>\n      dispatch(mergeTable({ ...table, id: resultJson.id }))).\n\n      catch(() =>\n      dispatch(\n      addDangerToast(\n      t(\n      'An error occurred while fetching table metadata. ' +\n      'Please contact your administrator.'))));\n\n\n\n\n    });\n  };\n}\n\nexport function changeDataPreviewId(oldQueryId, newQuery) {\n  return { type: CHANGE_DATA_PREVIEW_ID, oldQueryId, newQuery };\n}\n\nexport function reFetchQueryResults(query) {\n  return function (dispatch) {\n    const newQuery = {\n      id: shortid.generate(),\n      dbId: query.dbId,\n      sql: query.sql,\n      tableName: query.tableName,\n      sqlEditorId: null,\n      tab: '',\n      runAsync: false,\n      ctas: false,\n      queryLimit: query.queryLimit,\n      isDataPreview: query.isDataPreview };\n\n    dispatch(runQuery(newQuery));\n    dispatch(changeDataPreviewId(query.id, newQuery));\n  };\n}\n\nexport function expandTable(table) {\n  return function (dispatch) {\n    const sync = isFeatureEnabled(FeatureFlag.SQLLAB_BACKEND_PERSISTENCE) ?\n    SupersetClient.post({\n      endpoint: encodeURI(`/tableschemaview/${table.id}/expanded`),\n      postPayload: { expanded: true } }) :\n\n    Promise.resolve();\n\n    return sync.\n    then(() => dispatch({ type: EXPAND_TABLE, table })).\n    catch(() =>\n    dispatch(\n    addDangerToast(\n    t(\n    'An error occurred while expanding the table schema. ' +\n    'Please contact your administrator.'))));\n\n\n\n\n  };\n}\n\nexport function collapseTable(table) {\n  return function (dispatch) {\n    const sync = isFeatureEnabled(FeatureFlag.SQLLAB_BACKEND_PERSISTENCE) ?\n    SupersetClient.post({\n      endpoint: encodeURI(`/tableschemaview/${table.id}/expanded`),\n      postPayload: { expanded: false } }) :\n\n    Promise.resolve();\n\n    return sync.\n    then(() => dispatch({ type: COLLAPSE_TABLE, table })).\n    catch(() =>\n    dispatch(\n    addDangerToast(\n    t(\n    'An error occurred while collapsing the table schema. ' +\n    'Please contact your administrator.'))));\n\n\n\n\n  };\n}\n\nexport function removeTable(table) {\n  return function (dispatch) {\n    const sync = isFeatureEnabled(FeatureFlag.SQLLAB_BACKEND_PERSISTENCE) ?\n    SupersetClient.delete({\n      endpoint: encodeURI(`/tableschemaview/${table.id}`) }) :\n\n    Promise.resolve();\n\n    return sync.\n    then(() => dispatch({ type: REMOVE_TABLE, table })).\n    catch(() =>\n    dispatch(\n    addDangerToast(\n    t(\n    'An error occurred while removing the table schema. ' +\n    'Please contact your administrator.'))));\n\n\n\n\n  };\n}\n\nexport function refreshQueries(alteredQueries) {\n  return { type: REFRESH_QUERIES, alteredQueries };\n}\n\nexport function setUserOffline(offline) {\n  return { type: SET_USER_OFFLINE, offline };\n}\n\nexport function persistEditorHeight(queryEditor, northPercent, southPercent) {\n  return {\n    type: QUERY_EDITOR_PERSIST_HEIGHT,\n    queryEditor,\n    northPercent,\n    southPercent };\n\n}\n\nexport function popStoredQuery(urlId) {\n  return function (dispatch) {\n    return SupersetClient.get({ endpoint: `/kv/${urlId}` }).\n    then(({ json }) =>\n    dispatch(\n    addQueryEditor({\n      title: json.title ? json.title : t('Shared query'),\n      dbId: json.dbId ? parseInt(json.dbId, 10) : null,\n      schema: json.schema ? json.schema : null,\n      autorun: json.autorun ? json.autorun : false,\n      sql: json.sql ? json.sql : 'SELECT ...' }))).\n\n\n\n    catch(() => dispatch(addDangerToast(ERR_MSG_CANT_LOAD_QUERY)));\n  };\n}\nexport function popSavedQuery(saveQueryId) {\n  return function (dispatch) {\n    return SupersetClient.get({\n      endpoint: `/savedqueryviewapi/api/get/${saveQueryId}` }).\n\n    then(({ json }) => {\n      const queryEditorProps = {\n        ...convertQueryToClient(json.result),\n        autorun: false };\n\n      return dispatch(addQueryEditor(queryEditorProps));\n    }).\n    catch(() => dispatch(addDangerToast(ERR_MSG_CANT_LOAD_QUERY)));\n  };\n}\nexport function popQuery(queryId) {\n  return function (dispatch) {\n    return SupersetClient.get({\n      endpoint: `/api/v1/query/${queryId}` }).\n\n    then(({ json }) => {\n      const queryData = json.result;\n      const queryEditorProps = {\n        dbId: queryData.database.id,\n        schema: queryData.schema,\n        sql: queryData.sql,\n        title: `Copy of ${queryData.tab_name}`,\n        autorun: false };\n\n      return dispatch(addQueryEditor(queryEditorProps));\n    }).\n    catch(() => dispatch(addDangerToast(ERR_MSG_CANT_LOAD_QUERY)));\n  };\n}\nexport function popDatasourceQuery(datasourceKey, sql) {\n  return function (dispatch) {\n    return SupersetClient.get({\n      endpoint: `/superset/fetch_datasource_metadata?datasourceKey=${datasourceKey}` }).\n\n    then(({ json }) =>\n    dispatch(\n    addQueryEditor({\n      title: `Query ${json.name}`,\n      dbId: json.database.id,\n      schema: json.schema,\n      autorun: sql !== undefined,\n      sql: sql || json.select_star }))).\n\n\n\n    catch(() =>\n    dispatch(addDangerToast(t(\"The datasource couldn't be loaded\"))));\n\n  };\n}\nexport function createDatasourceStarted() {\n  return { type: CREATE_DATASOURCE_STARTED };\n}\nexport function createDatasourceSuccess(data) {\n  const datasource = `${data.table_id}__table`;\n  return { type: CREATE_DATASOURCE_SUCCESS, datasource };\n}\nexport function createDatasourceFailed(err) {\n  return { type: CREATE_DATASOURCE_FAILED, err };\n}\n\nexport function createDatasource(vizOptions) {\n  return (dispatch) => {\n    dispatch(createDatasourceStarted());\n    return SupersetClient.post({\n      endpoint: '/superset/sqllab_viz/',\n      postPayload: { data: vizOptions } }).\n\n    then(({ json }) => {\n      dispatch(createDatasourceSuccess(json));\n\n      return Promise.resolve(json);\n    }).\n    catch(() => {\n      dispatch(\n      createDatasourceFailed(\n      t('An error occurred while creating the data source')));\n\n\n\n      return Promise.reject();\n    });\n  };\n}\n\nexport function createCtasDatasource(vizOptions) {\n  return (dispatch) => {\n    dispatch(createDatasourceStarted());\n    return SupersetClient.post({\n      endpoint: '/superset/get_or_create_table/',\n      postPayload: { data: vizOptions } }).\n\n    then(({ json }) => {\n      dispatch(createDatasourceSuccess(json));\n\n      return json;\n    }).\n    catch(() => {\n      const errorMsg = t('An error occurred while creating the data source');\n      dispatch(createDatasourceFailed(errorMsg));\n      return Promise.reject(new Error(errorMsg));\n    });\n  };\n}\n\nexport function queryEditorSetFunctionNames(queryEditor, dbId) {\n  return function (dispatch) {\n    return SupersetClient.get({\n      endpoint: encodeURI(`/api/v1/database/${dbId}/function_names/`) }).\n\n    then(({ json }) =>\n    dispatch({\n      type: QUERY_EDITOR_SET_FUNCTION_NAMES,\n      queryEditor,\n      functionNames: json.function_names })).\n\n\n    catch(() =>\n    dispatch(\n    addDangerToast(t('An error occurred while fetching function names.'))));\n\n\n  };\n}","map":null,"metadata":{},"sourceType":"module"}