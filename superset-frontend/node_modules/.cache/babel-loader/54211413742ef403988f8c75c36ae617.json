{"ast":null,"code":"import _debounce from \"lodash/debounce\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport React from 'react';\nimport PropTypes from 'prop-types';\n\nimport { max as d3Max } from 'd3-array';\nimport { AsyncCreatableSelect, CreatableSelect } from 'src/components/Select';\nimport Button from 'src/components/Button';\nimport { t, SupersetClient, ensureIsArray } from '@superset-ui/core';\n\nimport {\nBOOL_FALSE_DISPLAY,\nBOOL_TRUE_DISPLAY,\nSLOW_DEBOUNCE } from\n'src/constants';\nimport { FormLabel } from 'src/components/Form';\nimport DateFilterControl from 'src/explore/components/controls/DateFilterControl';\nimport ControlRow from 'src/explore/components/ControlRow';\nimport Control from 'src/explore/components/Control';\nimport { controls } from 'src/explore/controls';\nimport { getExploreUrl } from 'src/explore/exploreUtils';\nimport OnPasteSelect from 'src/components/Select/OnPasteSelect';\nimport {\nFILTER_CONFIG_ATTRIBUTES,\nFILTER_OPTIONS_LIMIT,\nTIME_FILTER_LABELS,\nTIME_FILTER_MAP } from\n'src/explore/constants';\n\nimport './FilterBox.less';\n\n// a shortcut to a map key, used by many components\nimport { jsx as ___EmotionJSX } from \"@emotion/react\";export const TIME_RANGE = TIME_FILTER_MAP.time_range;\n\nconst propTypes = {\n  chartId: PropTypes.number.isRequired,\n  origSelectedValues: PropTypes.object,\n  datasource: PropTypes.object.isRequired,\n  instantFiltering: PropTypes.bool,\n  filtersFields: PropTypes.arrayOf(\n  PropTypes.shape({\n    field: PropTypes.string,\n    label: PropTypes.string })),\n\n\n  filtersChoices: PropTypes.objectOf(\n  PropTypes.arrayOf(\n  PropTypes.shape({\n    id: PropTypes.string,\n    text: PropTypes.string,\n    filter: PropTypes.string,\n    metric: PropTypes.number }))),\n\n\n\n  onChange: PropTypes.func,\n  onFilterMenuOpen: PropTypes.func,\n  onFilterMenuClose: PropTypes.func,\n  showDateFilter: PropTypes.bool,\n  showSqlaTimeGrain: PropTypes.bool,\n  showSqlaTimeColumn: PropTypes.bool,\n  showDruidTimeGrain: PropTypes.bool,\n  showDruidTimeOrigin: PropTypes.bool };\n\nconst defaultProps = {\n  origSelectedValues: {},\n  onChange: () => {},\n  onFilterMenuOpen: () => {},\n  onFilterMenuClose: () => {},\n  showDateFilter: false,\n  showSqlaTimeGrain: false,\n  showSqlaTimeColumn: false,\n  showDruidTimeGrain: false,\n  showDruidTimeOrigin: false,\n  instantFiltering: false };\n\n\nclass FilterBox extends React.PureComponent {\n  constructor(props) {\n    super(props);this.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    onCloseDateFilterControl = () => this.onFilterMenuClose(TIME_RANGE);this.state = { selectedValues: props.origSelectedValues, // this flag is used by non-instant filter, to make the apply button enabled/disabled\n      hasChanged: false };this.debouncerCache = {};this.maxValueCache = {};this.changeFilter = this.changeFilter.bind(this);this.onFilterMenuOpen = this.onFilterMenuOpen.bind(this);this.onOpenDateFilterControl = this.onOpenDateFilterControl.bind(this);this.onFilterMenuClose = this.onFilterMenuClose.bind(this);}onFilterMenuOpen(column) {return this.props.onFilterMenuOpen(this.props.chartId, column);}onFilterMenuClose(column) {return this.props.onFilterMenuClose(this.props.chartId, column);}onOpenDateFilterControl() {return this.onFilterMenuOpen(TIME_RANGE);}\n  getControlData(controlName) {\n    const { selectedValues } = this.state;\n    const control = {\n      ...controls[controlName], // TODO: make these controls ('druid_time_origin', 'granularity', 'granularity_sqla', 'time_grain_sqla') accessible from getControlsForVizType.\n      name: controlName,\n      key: `control-${controlName}`,\n      value: selectedValues[TIME_FILTER_MAP[controlName]],\n      actions: { setControlValue: this.changeFilter } };\n\n    const mapFunc = control.mapStateToProps;\n    return mapFunc ? { ...control, ...mapFunc(this.props) } : control;\n  }\n\n  /**\n   * Get known max value of a column\n   */\n  getKnownMax(key, choices) {\n    this.maxValueCache[key] = Math.max(\n    this.maxValueCache[key] || 0,\n    d3Max(choices || this.props.filtersChoices[key] || [], (x) => x.metric));\n\n    return this.maxValueCache[key];\n  }\n\n  clickApply() {\n    const { selectedValues } = this.state;\n    this.setState({ hasChanged: false }, () => {\n      this.props.onChange(selectedValues, false);\n    });\n  }\n\n  changeFilter(filter, options) {\n    const fltr = TIME_FILTER_MAP[filter] || filter;\n    let vals = null;\n    if (options !== null) {\n      if (Array.isArray(options)) {\n        vals = options.map((opt) => typeof opt === 'string' ? opt : opt.value);\n      } else if (Object.values(TIME_FILTER_MAP).includes(fltr)) {var _options$value;\n        vals = (_options$value = options.value) != null ? _options$value : options;\n      } else {var _options$value2;\n        // must use array member for legacy extra_filters's value\n        vals = ensureIsArray((_options$value2 = options.value) != null ? _options$value2 : options);\n      }\n    }\n\n    this.setState(\n    (prevState) => ({\n      selectedValues: {\n        ...prevState.selectedValues,\n        [fltr]: vals },\n\n      hasChanged: true }),\n\n    () => {\n      if (this.props.instantFiltering) {\n        this.props.onChange({ [fltr]: vals }, false);\n      }\n    });\n\n  }\n\n  /**\n   * Generate a debounce function that loads options for a specific column\n   */\n  debounceLoadOptions(key) {\n    if (!(key in this.debouncerCache)) {\n      this.debouncerCache[key] = _debounce((input, callback) => {\n        this.loadOptions(key, input).then(callback);\n      }, SLOW_DEBOUNCE);\n    }\n    return this.debouncerCache[key];\n  }\n\n  /**\n   * Transform select options, add bar background\n   */\n  transformOptions(options, max) {\n    const maxValue = max === undefined ? d3Max(options, (x) => x.metric) : max;\n    return options.map((opt) => {\n      const perc = Math.round(opt.metric / maxValue * 100);\n      const color = 'lightgrey';\n      const backgroundImage = `linear-gradient(to right, ${color}, ${color} ${perc}%, rgba(0,0,0,0) ${perc}%`;\n      const style = { backgroundImage };\n      let label = opt.id;\n      if (label === true) {\n        label = BOOL_TRUE_DISPLAY;\n      } else if (label === false) {\n        label = BOOL_FALSE_DISPLAY;\n      }\n      return { value: opt.id, label, style };\n    });\n  }\n\n  async loadOptions(key, inputValue = '') {var _json$data;\n    const input = inputValue.toLowerCase();\n    const sortAsc = this.props.filtersFields.find((x) => x.key === key).asc;\n    const formData = {\n      ...this.props.rawFormData,\n      adhoc_filters: inputValue ?\n      [\n      {\n        clause: 'WHERE',\n        expressionType: 'SIMPLE',\n        subject: key,\n        operator: 'ILIKE',\n        comparator: `%${input}%` }] :\n\n\n      null };\n\n\n    const { json } = await SupersetClient.get({\n      url: getExploreUrl({\n        formData,\n        endpointType: 'json',\n        method: 'GET' }) });\n\n\n    const options = ((json == null ? void 0 : (_json$data = json.data) == null ? void 0 : _json$data[key]) || []).filter((x) => x.id);\n    if (!options || options.length === 0) {\n      return [];\n    }\n    if (input) {\n      // sort those starts with search query to front\n      options.sort((a, b) => {\n        const labelA = a.id.toLowerCase();\n        const labelB = b.id.toLowerCase();\n        const textOrder = labelB.startsWith(input) - labelA.startsWith(input);\n        return textOrder === 0 ?\n        (a.metric - b.metric) * (sortAsc ? 1 : -1) :\n        textOrder;\n      });\n    }\n    return this.transformOptions(options, this.getKnownMax(key, options));\n  }\n\n  renderDateFilter() {\n    const { showDateFilter } = this.props;\n    const label = TIME_FILTER_LABELS.time_range;\n    if (showDateFilter) {\n      return (\n        ___EmotionJSX(\"div\", { className: \"row space-1\" },\n        ___EmotionJSX(\"div\", {\n          className: \"col-lg-12 col-xs-12\" },\n\n\n        ___EmotionJSX(DateFilterControl, {\n          name: TIME_RANGE,\n          label: label,\n          description: t('Select start and end date'),\n          onChange: (newValue) => {\n            this.changeFilter(TIME_RANGE, newValue);\n          },\n          onOpenDateFilterControl: this.onOpenDateFilterControl,\n          onCloseDateFilterControl: this.onCloseDateFilterControl,\n          value: this.state.selectedValues[TIME_RANGE] || 'No filter' }))));\n\n\n\n\n    }\n    return null;\n  }\n\n  renderDatasourceFilters() {\n    const {\n      showSqlaTimeGrain,\n      showSqlaTimeColumn,\n      showDruidTimeGrain,\n      showDruidTimeOrigin } =\n    this.props;\n    const datasourceFilters = [];\n    const sqlaFilters = [];\n    const druidFilters = [];\n    if (showSqlaTimeGrain) sqlaFilters.push('time_grain_sqla');\n    if (showSqlaTimeColumn) sqlaFilters.push('granularity_sqla');\n    if (showDruidTimeGrain) druidFilters.push('granularity');\n    if (showDruidTimeOrigin) druidFilters.push('druid_time_origin');\n    if (sqlaFilters.length) {\n      datasourceFilters.push(\n      ___EmotionJSX(ControlRow, {\n        key: \"sqla-filters\",\n        controls: sqlaFilters.map((control) =>\n        ___EmotionJSX(Control, this.getControlData(control))) }));\n\n\n\n    }\n    if (druidFilters.length) {\n      datasourceFilters.push(\n      ___EmotionJSX(ControlRow, {\n        key: \"druid-filters\",\n        controls: druidFilters.map((control) =>\n        ___EmotionJSX(Control, this.getControlData(control))) }));\n\n\n\n    }\n    return datasourceFilters;\n  }\n\n  renderSelect(filterConfig) {\n    const { filtersChoices } = this.props;\n    const { selectedValues } = this.state;\n    this.debouncerCache = {};\n    this.maxValueCache = {};\n\n    // Add created options to filtersChoices, even though it doesn't exist,\n    // or these options will exist in query sql but invisible to end user.\n    Object.keys(selectedValues).\n    filter((key) => key in filtersChoices).\n    forEach((key) => {\n      // empty values are ignored\n      if (!selectedValues[key]) {\n        return;\n      }\n      const choices = filtersChoices[key] || (filtersChoices[key] = []);\n      const choiceIds = new Set(choices.map((f) => f.id));\n      const selectedValuesForKey = Array.isArray(selectedValues[key]) ?\n      selectedValues[key] :\n      [selectedValues[key]];\n      selectedValuesForKey.\n      filter((value) => value !== null && !choiceIds.has(value)).\n      forEach((value) => {\n        choices.unshift({\n          filter: key,\n          id: value,\n          text: value,\n          metric: 0 });\n\n      });\n    });\n    const {\n      key,\n      label,\n      [FILTER_CONFIG_ATTRIBUTES.MULTIPLE]: isMultiple,\n      [FILTER_CONFIG_ATTRIBUTES.DEFAULT_VALUE]: defaultValue,\n      [FILTER_CONFIG_ATTRIBUTES.CLEARABLE]: isClearable,\n      [FILTER_CONFIG_ATTRIBUTES.SEARCH_ALL_OPTIONS]: searchAllOptions } =\n    filterConfig;\n    const data = filtersChoices[key] || [];\n    let value = selectedValues[key] || null;\n\n    // Assign default value if required\n    if (value === undefined && defaultValue) {\n      // multiple values are separated by semicolons\n      value = isMultiple ? defaultValue.split(';') : defaultValue;\n    }\n\n    return (\n      ___EmotionJSX(OnPasteSelect, {\n        cacheOptions: true,\n        loadOptions: this.debounceLoadOptions(key),\n        defaultOptions: this.transformOptions(data),\n        key: key,\n        placeholder: t('Type or Select [%s]', label),\n        isMulti: isMultiple,\n        isClearable: isClearable,\n        value: value,\n        options: this.transformOptions(data),\n        onChange: (newValue) => {\n          // avoid excessive re-renders\n          if (newValue !== value) {\n            this.changeFilter(key, newValue);\n          }\n        }\n        // TODO try putting this back once react-select is upgraded\n        // onFocus={() => this.onFilterMenuOpen(key)}\n        , onMenuOpen: () => this.onFilterMenuOpen(key),\n        onBlur: () => this.onFilterMenuClose(key),\n        onMenuClose: () => this.onFilterMenuClose(key),\n        selectWrap:\n        searchAllOptions && data.length >= FILTER_OPTIONS_LIMIT ?\n        AsyncCreatableSelect :\n        CreatableSelect,\n\n        noResultsText: t('No results found'),\n        forceOverflow: true }));\n\n\n  }\n\n  renderFilters() {\n    const { filtersFields = [] } = this.props;\n    return filtersFields.map((filterConfig) => {\n      const { label, key } = filterConfig;\n      return (\n        ___EmotionJSX(\"div\", { key: key, className: \"m-b-5 filter-container\" },\n        ___EmotionJSX(FormLabel, { htmlFor: `LABEL-${key}` }, label),\n        this.renderSelect(filterConfig)));\n\n\n    });\n  }\n\n  render() {\n    const { instantFiltering, width, height } = this.props;\n    return (\n      ___EmotionJSX(\"div\", { style: { width, height, overflow: 'auto' } },\n      this.renderDateFilter(),\n      this.renderDatasourceFilters(),\n      this.renderFilters(),\n      !instantFiltering &&\n      ___EmotionJSX(Button, {\n        buttonSize: \"small\",\n        buttonStyle: \"primary\",\n        onClick: this.clickApply.bind(this),\n        disabled: !this.state.hasChanged },\n\n      t('Apply'))));\n\n\n\n\n  }}\n\n\nFilterBox.propTypes = propTypes;\nFilterBox.defaultProps = defaultProps;\n\nexport default FilterBox;","map":null,"metadata":{},"sourceType":"module"}