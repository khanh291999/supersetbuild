{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint camelcase: 0 */\nimport { DYNAMIC_PLUGIN_CONTROLS_READY } from 'src/chart/chartAction';\nimport { DEFAULT_TIME_RANGE } from 'src/explore/constants';\nimport { getControlsState } from 'src/explore/store';\nimport {\ngetControlConfig,\ngetFormDataFromControls,\ngetControlStateFromControlConfig } from\n'src/explore/controlUtils';\nimport * as actions from 'src/explore/actions/exploreActions';\n\nexport default function exploreReducer(state = {}, action) {\n  const actionHandlers = {\n    [DYNAMIC_PLUGIN_CONTROLS_READY]() {\n      return {\n        ...state,\n        controls: action.controlsState };\n\n    },\n    [actions.TOGGLE_FAVE_STAR]() {\n      return {\n        ...state,\n        isStarred: action.isStarred };\n\n    },\n    [actions.POST_DATASOURCE_STARTED]() {\n      return {\n        ...state,\n        isDatasourceMetaLoading: true };\n\n    },\n    [actions.SET_DATASOURCE]() {\n      const newFormData = { ...state.form_data };\n      if (action.datasource.type !== state.datasource.type) {\n        if (action.datasource.type === 'table') {\n          newFormData.granularity_sqla = action.datasource.granularity_sqla;\n          newFormData.time_grain_sqla = action.datasource.time_grain_sqla;\n          delete newFormData.druid_time_origin;\n          delete newFormData.granularity;\n        } else {\n          newFormData.druid_time_origin = action.datasource.druid_time_origin;\n          newFormData.granularity = action.datasource.granularity;\n          delete newFormData.granularity_sqla;\n          delete newFormData.time_grain_sqla;\n        }\n      }\n\n      const controls = { ...state.controls };\n      if (\n      action.datasource.id !== state.datasource.id ||\n      action.datasource.type !== state.datasource.type)\n      {\n        // reset time range filter to default\n        newFormData.time_range = DEFAULT_TIME_RANGE;\n\n        // reset control values for column/metric related controls\n        Object.entries(controls).forEach(([controlName, controlState]) => {\n          if (\n          // for direct column select controls\n          controlState.valueKey === 'column_name' ||\n          // for all other controls\n          'columns' in controlState)\n          {\n            // if a control use datasource columns, reset its value to `undefined`,\n            // then `getControlsState` will pick up the default.\n            // TODO: filter out only invalid columns and keep others\n            controls[controlName] = {\n              ...controlState,\n              value: undefined };\n\n            newFormData[controlName] = undefined;\n          }\n        });\n      }\n\n      const newState = {\n        ...state,\n        controls,\n        datasource: action.datasource,\n        datasource_id: action.datasource.id,\n        datasource_type: action.datasource.type };\n\n      return {\n        ...newState,\n        form_data: newFormData,\n        controls: getControlsState(newState, newFormData) };\n\n    },\n    [actions.FETCH_DATASOURCES_STARTED]() {\n      return {\n        ...state,\n        isDatasourcesLoading: true };\n\n    },\n    [actions.SET_DATASOURCES]() {\n      return {\n        ...state,\n        datasources: action.datasources };\n\n    },\n    [actions.SET_FIELD_VALUE]() {\n      const new_form_data = state.form_data;\n      const { controlName, value, validationErrors } = action;\n      new_form_data[controlName] = value;\n\n      const vizType = new_form_data.viz_type;\n\n      // Use the processed control config (with overrides and everything)\n      // if `controlName` does not existing in current controls,\n      const controlConfig =\n      state.controls[action.controlName] ||\n      getControlConfig(action.controlName, vizType) ||\n      {};\n\n      // will call validators again\n      const control = {\n        ...getControlStateFromControlConfig(controlConfig, state, action.value) };\n\n\n      const newState = {\n        ...state,\n        controls: { ...state.controls, [action.controlName]: control } };\n\n\n      const rerenderedControls = {};\n      if (Array.isArray(control.rerender)) {\n        control.rerender.forEach((controlName) => {\n          rerenderedControls[controlName] = {\n            ...getControlStateFromControlConfig(\n            newState.controls[controlName],\n            newState,\n            newState.controls[controlName].value) };\n\n\n        });\n      }\n\n      // combine newly detected errors with errors from `onChange` event of\n      // each control component (passed via reducer action).\n      const errors = control.validationErrors || [];\n      (validationErrors || []).forEach((err) => {\n        // skip duplicated errors\n        if (!errors.includes(err)) {\n          errors.push(err);\n        }\n      });\n      const hasErrors = errors && errors.length > 0;\n\n      const currentControlsState =\n      action.controlName === 'viz_type' &&\n      action.value !== state.controls.viz_type.value ?\n      // rebuild the full control state if switching viz type\n      getControlsState(\n      state,\n      getFormDataFromControls({\n        ...state.controls,\n        viz_type: control })) :\n\n\n      state.controls;\n\n      return {\n        ...state,\n        form_data: new_form_data,\n        triggerRender: control.renderTrigger && !hasErrors,\n        controls: {\n          ...currentControlsState,\n          [action.controlName]: {\n            ...control,\n            validationErrors: errors },\n\n          ...rerenderedControls } };\n\n\n    },\n    [actions.SET_EXPLORE_CONTROLS]() {\n      return {\n        ...state,\n        controls: getControlsState(state, action.formData) };\n\n    },\n    [actions.UPDATE_CHART_TITLE]() {\n      return {\n        ...state,\n        sliceName: action.sliceName };\n\n    },\n    [actions.CREATE_NEW_SLICE]() {\n      return {\n        ...state,\n        slice: action.slice,\n        controls: getControlsState(state, action.form_data),\n        can_add: action.can_add,\n        can_download: action.can_download,\n        can_overwrite: action.can_overwrite };\n\n    },\n    [actions.SLICE_UPDATED]() {var _action$slice$owners, _action$slice$slice_n;\n      return {\n        ...state,\n        slice: {\n          ...state.slice,\n          ...action.slice,\n          owners: (_action$slice$owners = action.slice.owners) != null ? _action$slice$owners : null },\n\n        sliceName: (_action$slice$slice_n = action.slice.slice_name) != null ? _action$slice$slice_n : state.sliceName };\n\n    } };\n\n  if (action.type in actionHandlers) {\n    return actionHandlers[action.type]();\n  }\n  return state;\n}","map":null,"metadata":{},"sourceType":"module"}