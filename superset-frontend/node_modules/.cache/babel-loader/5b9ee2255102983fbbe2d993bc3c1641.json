{"ast":null,"code":"import _debounce from \"lodash/debounce\";import _sortBy from \"lodash/sortBy\";import _isEqual from \"lodash/isEqual\";import _uniq from \"lodash/uniq\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport React, { useEffect, useCallback, useMemo, useState, useRef } from 'react';\n\nimport { t, styled, SLOW_DEBOUNCE } from '@superset-ui/core';\nimport { Form } from 'src/common/components';\nimport { StyledModal } from 'src/components/Modal';\nimport ErrorBoundary from 'src/components/ErrorBoundary';\nimport { testWithId } from 'src/utils/testUtils';\nimport { useFilterConfigMap, useFilterConfiguration } from '../state';\nimport { validateForm, createHandleSave, createHandleTabEdit, generateFilterId, getFilterIds } from './utils';\nimport Footer from './Footer/Footer';\nimport FilterTabs from './FilterTabs';\nimport FiltersConfigForm from './FiltersConfigForm/FiltersConfigForm';\nimport { useOpenModal, useRemoveCurrentFilter } from './state';import { jsx as ___EmotionJSX } from \"@emotion/react\";\nconst StyledModalWrapper = styled(StyledModal)`\n  min-width: 700px;\n  .ant-modal-body {\n    padding: 0px;\n  }\n`;\nexport const StyledModalBody = styled.div`\n  display: flex;\n  height: 700px;\n  flex-direction: row;\n  .filters-list {\n    width: ${({ theme }) => theme.gridUnit * 50}px;\n    overflow: auto;\n  }\n`;\nexport const StyledForm = styled(Form)`\n  width: 100%;\n`;\nexport const FILTERS_CONFIG_MODAL_TEST_ID = 'filters-config-modal';\nexport const getFiltersConfigModalTestId = testWithId(FILTERS_CONFIG_MODAL_TEST_ID);\nexport const CASCADING_FILTERS = ['filter_select'];\n/**\n * This is the modal to configure all the dashboard-native filters.\n * Manages modal-level state, such as what filters are in the list,\n * and which filter is currently being edited.\n *\n * Calls the `save` callback with the new FilterConfiguration object\n * when the user saves the filters.\n */\nexport function FiltersConfigModal({ isOpen, initialFilterId, createNewOnOpen, onSave, onCancel }) {\n  const [form] = Form.useForm();\n  const configFormRef = useRef();\n  // the filter config from redux state, this does not change until modal is closed.\n  const filterConfig = useFilterConfiguration();\n  const filterConfigMap = useFilterConfigMap();\n  // new filter ids belong to filters have been added during\n  // this configuration session, and only exist in the form state until we submit.\n  const [newFilterIds, setNewFilterIds] = useState([]);\n  // store ids of filters that have been removed with the time they were removed\n  // so that we can disappear them after a few secs.\n  // filters are still kept in state until form is submitted.\n  const [removedFilters, setRemovedFilters] = useState({});\n  const [saveAlertVisible, setSaveAlertVisible] = useState(false);\n  // The full ordered set of ((original + new) - completely removed) filter ids\n  // Use this as the canonical list of what filters are being configured!\n  // This includes filter ids that are pending removal, so check for that.\n  const filterIds = useMemo(() => _uniq([...getFilterIds(filterConfig), ...newFilterIds]).filter((id) => {var _removedFilters$id;return !removedFilters[id] || ((_removedFilters$id = removedFilters[id]) == null ? void 0 : _removedFilters$id.isPending);}), [filterConfig, newFilterIds, removedFilters]);\n  // open the first filter in the list to start\n  const initialCurrentFilterId = initialFilterId != null ? initialFilterId : filterIds[0];\n  const [currentFilterId, setCurrentFilterId] = useState(initialCurrentFilterId);\n  const [erroredFilters, setErroredFilters] = useState([]);\n  // the form values are managed by the antd form, but we copy them to here\n  // so that we can display them (e.g. filter titles in the tab headers)\n  const [formValues, setFormValues] = useState({\n    filters: {} });\n\n  const unsavedFiltersIds = newFilterIds.filter((id) => !removedFilters[id]);\n  // brings back a filter that was previously removed (\"Undo\")\n  const restoreFilter = (id) => {\n    const removal = removedFilters[id];\n    // gotta clear the removal timeout to prevent the filter from getting deleted\n    if (removal != null && removal.isPending)\n    clearTimeout(removal.timerId);\n    setRemovedFilters((current) => ({ ...current, [id]: null }));\n  };\n  // generates a new filter id and appends it to the newFilterIds\n  const addFilter = useCallback(() => {\n    const newFilterId = generateFilterId();\n    setNewFilterIds([...newFilterIds, newFilterId]);\n    setCurrentFilterId(newFilterId);\n    setSaveAlertVisible(false);\n  }, [newFilterIds, setCurrentFilterId]);\n  useOpenModal(isOpen, addFilter, createNewOnOpen);\n  useRemoveCurrentFilter(removedFilters, currentFilterId, filterIds, setCurrentFilterId);\n  const handleTabEdit = createHandleTabEdit(setRemovedFilters, setSaveAlertVisible, addFilter);\n  // After this, it should be as if the modal was just opened fresh.\n  // Called when the modal is closed.\n  const resetForm = () => {\n    setNewFilterIds([]);\n    setCurrentFilterId(initialCurrentFilterId);\n    setRemovedFilters({});\n    setSaveAlertVisible(false);\n    setFormValues({ filters: {} });\n    form.setFieldsValue({ changed: false });\n    setErroredFilters([]);\n  };\n  const getFilterTitle = (id) => {var _formValues$filters$i, _filterConfigMap$id;return ((_formValues$filters$i = formValues.filters[id]) == null ? void 0 : _formValues$filters$i.name) || ((_filterConfigMap$id =\n    filterConfigMap[id]) == null ? void 0 : _filterConfigMap$id.name) ||\n    t('[untitled]');};\n  const getParentFilters = (id) => filterIds.\n  filter((filterId) => filterId !== id && !removedFilters[filterId]).\n  filter((filterId) => {var _filterConfigMap$filt;return CASCADING_FILTERS.includes(formValues.filters[filterId] ?\n    formValues.filters[filterId].filterType : (_filterConfigMap$filt =\n    filterConfigMap[filterId]) == null ? void 0 : _filterConfigMap$filt.filterType);}).\n  map((id) => ({\n    id,\n    title: getFilterTitle(id) }));\n\n  const cleanDeletedParents = (values) => {\n    Object.keys(filterConfigMap).forEach((key) => {var _filter$cascadeParent;\n      const filter = filterConfigMap[key];\n      const parentId = (_filter$cascadeParent = filter.cascadeParentIds) == null ? void 0 : _filter$cascadeParent[0];\n      if (parentId && removedFilters[parentId]) {\n        filter.cascadeParentIds = [];\n      }\n    });\n    const filters = values == null ? void 0 : values.filters;\n    if (filters) {\n      Object.keys(filters).forEach((key) => {var _filter$parentFilter;\n        const filter = filters[key];\n        const parentId = (_filter$parentFilter = filter.parentFilter) == null ? void 0 : _filter$parentFilter.value;\n        if (parentId && removedFilters[parentId]) {\n          filter.parentFilter = undefined;\n        }\n      });\n    }\n  };\n  const handleErroredFilters = useCallback(() => {\n    // managing left pane errored filters indicators\n    const formValidationFields = form.getFieldsError();\n    const erroredFiltersIds = [];\n    formValidationFields.forEach((field) => {\n      const filterId = field.name[1];\n      if (field.errors.length > 0 && !erroredFiltersIds.includes(filterId)) {\n        erroredFiltersIds.push(filterId);\n      }\n    });\n    // no form validation issues found, resets errored filters\n    if (!erroredFiltersIds.length && erroredFilters.length > 0) {\n      setErroredFilters([]);\n      return;\n    }\n    // form validation issues found, sets errored filters\n    if (erroredFiltersIds.length > 0 &&\n    !_isEqual(_sortBy(erroredFilters), _sortBy(erroredFiltersIds))) {\n      setErroredFilters(erroredFiltersIds);\n    }\n  }, [form, erroredFilters]);\n  const handleSave = async () => {\n    const values = await validateForm(form, currentFilterId, filterConfigMap, filterIds, removedFilters, setCurrentFilterId);\n    handleErroredFilters();\n    if (values) {\n      cleanDeletedParents(values);\n      createHandleSave(filterConfigMap, filterIds, removedFilters, onSave, values)();\n      resetForm();\n    } else\n    {\n      configFormRef.current.changeTab('configuration');\n    }\n  };\n  const handleConfirmCancel = () => {\n    resetForm();\n    onCancel();\n  };\n  const handleCancel = () => {\n    const changed = form.getFieldValue('changed');\n    if (unsavedFiltersIds.length > 0 || form.isFieldsTouched() || changed) {\n      setSaveAlertVisible(true);\n    } else\n    {\n      handleConfirmCancel();\n    }\n  };\n  const onValuesChange = useMemo(() => _debounce((changes, values) => {\n    if (changes.filters) {\n      if (Object.values(changes.filters).some((filter) => filter.name != null)) {\n        // we only need to set this if a name changed\n        setFormValues(values);\n      }\n      handleErroredFilters();\n    }\n    setSaveAlertVisible(false);\n  }, SLOW_DEBOUNCE), [handleErroredFilters]);\n  useEffect(() => {\n    setErroredFilters((prevErroredFilters) => prevErroredFilters.filter((f) => !removedFilters[f]));\n  }, [removedFilters]);\n  return ___EmotionJSX(StyledModalWrapper, { visible: isOpen, maskClosable: false, title: t('Filters configuration and scoping'), width: \"50%\", destroyOnClose: true, onCancel: handleCancel, onOk: handleSave, centered: true, footer: ___EmotionJSX(Footer, { onDismiss: () => setSaveAlertVisible(false), onCancel: handleCancel, handleSave: handleSave, canSave: !erroredFilters.length, saveAlertVisible: saveAlertVisible, onConfirmCancel: handleConfirmCancel }) },\n  ___EmotionJSX(ErrorBoundary, null,\n  ___EmotionJSX(StyledModalBody, null,\n  ___EmotionJSX(StyledForm, { preserve: false, form: form, onValuesChange: onValuesChange, layout: \"vertical\" },\n  ___EmotionJSX(FilterTabs, { erroredFilters: erroredFilters, onEdit: handleTabEdit, onChange: setCurrentFilterId, getFilterTitle: getFilterTitle, currentFilterId: currentFilterId, filterIds: filterIds, removedFilters: removedFilters, restoreFilter: restoreFilter },\n  (id) => ___EmotionJSX(FiltersConfigForm, { ref: configFormRef, form: form, filterId: id, filterToEdit: filterConfigMap[id], removedFilters: removedFilters, restoreFilter: restoreFilter, parentFilters: getParentFilters(id), setErroredFilters: setErroredFilters }))))));\n\n\n\n\n\n}","map":null,"metadata":{},"sourceType":"module"}