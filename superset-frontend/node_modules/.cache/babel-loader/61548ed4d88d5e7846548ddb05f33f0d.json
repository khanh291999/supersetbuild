{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-disable no-param-reassign */\nimport { useSelector } from 'react-redux';\nimport { useEffect, useState } from 'react';\nimport { NATIVE_FILTER_PREFIX } from '../FiltersConfigModal/utils';\nexport const useFilterSets = () => useSelector((state) => state.nativeFilters.filterSets || {});\nexport const useFilters = () => useSelector((state) => {var _state$dashboardState;\n  const preselectNativeFilters = ((_state$dashboardState = state.dashboardState) == null ? void 0 : _state$dashboardState.preselectNativeFilters) || {};\n  return Object.entries(state.nativeFilters.filters).reduce((acc, [filterId, filter]) => ({\n    ...acc,\n    [filterId]: {\n      ...filter,\n      preselect: preselectNativeFilters[filterId] } }),\n\n  {});\n});\nexport const useNativeFiltersDataMask = () => {\n  const dataMask = useSelector((state) => state.dataMask);\n  return Object.values(dataMask).\n  filter((item) => String(item.id).startsWith(NATIVE_FILTER_PREFIX)).\n  reduce((prev, next) => ({ ...prev, [next.id]: next }), {});\n};\nexport const useFilterUpdates = (dataMaskSelected, setDataMaskSelected) => {\n  const filters = useFilters();\n  const dataMaskApplied = useNativeFiltersDataMask();\n  useEffect(() => {\n    // Remove deleted filters from local state\n    Object.keys(dataMaskSelected).forEach((selectedId) => {\n      if (!filters[selectedId]) {\n        setDataMaskSelected((draft) => {\n          delete draft[selectedId];\n        });\n      }\n    });\n  }, [dataMaskApplied, dataMaskSelected, filters, setDataMaskSelected]);\n};\n// Load filters after charts loaded\nexport const useInitialization = () => {\n  const [isInitialized, setIsInitialized] = useState(false);\n  const filters = useFilters();\n  const charts = useSelector((state) => state.charts);\n  // We need to know how much charts now shown on dashboard to know how many of all charts should be loaded\n  let numberOfLoadingCharts = 0;\n  if (!isInitialized) {\n    numberOfLoadingCharts = document.querySelectorAll('[data-ui-anchor=\"chart\"]').length;\n  }\n  useEffect(() => {\n    if (isInitialized) {\n      return;\n    }\n    if (Object.values(filters).find(({ requiredFirst }) => requiredFirst)) {\n      setIsInitialized(true);\n      return;\n    }\n    // For some dashboards may be there are no charts on first page,\n    // so we check up to 1 sec if there is at least on chart to load\n    let filterTimeout;\n    if (numberOfLoadingCharts === 0) {\n      filterTimeout = setTimeout(() => {\n        setIsInitialized(true);\n      }, 1000);\n    }\n    // @ts-ignore\n    if (numberOfLoadingCharts > 0 && filterTimeout !== undefined) {\n      clearTimeout(filterTimeout);\n    }\n    const numberOfLoadedCharts = Object.values(charts).filter(({ chartStatus }) => chartStatus !== 'loading').length;\n    if (numberOfLoadingCharts > 0 &&\n    numberOfLoadedCharts >= numberOfLoadingCharts) {\n      setIsInitialized(true);\n    }\n  }, [charts, isInitialized, numberOfLoadingCharts]);\n  return isInitialized;\n};","map":null,"metadata":{},"sourceType":"module"}