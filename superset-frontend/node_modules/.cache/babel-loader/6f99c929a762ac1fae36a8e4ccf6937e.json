{"ast":null,"code":"import { CHART_TYPE, DASHBOARD_ROOT_TYPE, TAB_TYPE } from 'src/dashboard/util/componentTypes';\nimport { DASHBOARD_ROOT_ID } from 'src/dashboard/util/constants';\nimport { t } from '@superset-ui/core';\nexport const isShowTypeInTree = ({ type, meta }, charts) => {var _charts$meta$chartId, _charts$meta$chartId$;return (type === TAB_TYPE || type === CHART_TYPE || type === DASHBOARD_ROOT_TYPE) && (\n  !charts || ((_charts$meta$chartId = charts[meta == null ? void 0 : meta.chartId]) == null ? void 0 : (_charts$meta$chartId$ = _charts$meta$chartId.formData) == null ? void 0 : _charts$meta$chartId$.viz_type) !== 'filter_box');};\nexport const buildTree = (node, treeItem, layout, charts, validNodes, initiallyExcludedCharts, buildTreeLeafTitle) => {\n  let itemToPass = treeItem;\n  if (isShowTypeInTree(node, charts) &&\n  node.type !== DASHBOARD_ROOT_TYPE &&\n  validNodes.includes(node.id)) {var _node$meta;\n    const title = buildTreeLeafTitle(node.meta.sliceNameOverride ||\n    node.meta.sliceName ||\n    node.meta.text ||\n    node.meta.defaultText ||\n    node.id.toString(), initiallyExcludedCharts.includes((_node$meta = node.meta) == null ? void 0 : _node$meta.chartId), t(\"This chart might be incompatible with the filter (datasets don't match)\"));\n    const currentTreeItem = {\n      key: node.id,\n      title,\n      children: [] };\n\n    treeItem.children.push(currentTreeItem);\n    itemToPass = currentTreeItem;\n  }\n  node.children.forEach((child) => buildTree(layout[child], itemToPass, layout, charts, validNodes, initiallyExcludedCharts, buildTreeLeafTitle));\n};\nconst addInvisibleParents = (layout, item) => {var _layout$item;return [\n  ...(((_layout$item = layout[item]) == null ? void 0 : _layout$item.children) || []),\n  ...Object.values(layout).\n  filter((val) => val.parents &&\n  val.parents[val.parents.length - 1] === item &&\n  !isShowTypeInTree(layout[val.parents[val.parents.length - 1]])).\n  map(({ id }) => id)];};\n\n// Generate checked options for Ant tree from redux scope\nconst checkTreeItem = (checkedItems, layout, items, excluded) => {\n  items.forEach((item) => {var _layout$item2, _layout$item3;\n    checkTreeItem(checkedItems, layout, addInvisibleParents(layout, item), excluded);\n    if (((_layout$item2 = layout[item]) == null ? void 0 : _layout$item2.type) === CHART_TYPE &&\n    !excluded.includes((_layout$item3 = layout[item]) == null ? void 0 : _layout$item3.meta.chartId)) {\n      checkedItems.push(item);\n    }\n  });\n};\nexport const getTreeCheckedItems = (scope, layout) => {\n  const checkedItems = [];\n  checkTreeItem(checkedItems, layout, [...scope.rootPath], [...scope.excluded]);\n  return [...new Set(checkedItems)];\n};\n// Looking for first common parent for selected charts/tabs/tab\nexport const findFilterScope = (checkedKeys, layout) => {\n  if (!checkedKeys.length) {\n    return {\n      rootPath: [],\n      excluded: [] };\n\n  }\n  // Get arrays of parents for selected charts\n  const checkedItemParents = checkedKeys.\n  filter((item) => {var _layout$item4;return ((_layout$item4 = layout[item]) == null ? void 0 : _layout$item4.type) === CHART_TYPE;}).\n  map((key) => {var _layout$key;\n    const parents = [DASHBOARD_ROOT_ID, ...(((_layout$key = layout[key]) == null ? void 0 : _layout$key.parents) || [])];\n    return parents.filter((parent) => isShowTypeInTree(layout[parent]));\n  });\n  // Sort arrays of parents to get first shortest array of parents,\n  // that means on it's level of parents located common parent, from this place parents start be different\n  checkedItemParents.sort((p1, p2) => p1.length - p2.length);\n  const rootPath = checkedItemParents.map((parents) => parents[checkedItemParents[0].length - 1]);\n  const excluded = [];\n  const isExcluded = (parent, item) => rootPath.includes(parent) && !checkedKeys.includes(item);\n  // looking for charts to be excluded: iterate over all charts\n  // and looking for charts that have one of their parents in `rootPath` and not in selected items\n  Object.entries(layout).forEach(([key, value]) => {var _ref;\n    const parents = value.parents || [];\n    if (value.type === CHART_TYPE && (_ref =\n    [DASHBOARD_ROOT_ID, ...parents]) != null && _ref.find((parent) => isExcluded(parent, key))) {\n      excluded.push(value.meta.chartId);\n    }\n  });\n  return {\n    rootPath: [...new Set(rootPath)],\n    excluded };\n\n};\nexport const getDefaultScopeValue = (chartId, initiallyExcludedCharts = []) => ({\n  rootPath: [DASHBOARD_ROOT_ID],\n  excluded: chartId ?\n  [chartId, ...initiallyExcludedCharts] :\n  initiallyExcludedCharts });\n\nexport const isScopingAll = (scope, chartId) => !scope ||\nscope.rootPath[0] === DASHBOARD_ROOT_ID &&\n!scope.excluded.filter((item) => item !== chartId).length;","map":null,"metadata":{},"sourceType":"module"}