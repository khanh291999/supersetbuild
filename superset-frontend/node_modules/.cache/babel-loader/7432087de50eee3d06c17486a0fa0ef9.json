{"ast":null,"code":"import _extends from \"@babel/runtime-corejs3/helpers/extends\";import _isEqual from \"lodash/isEqual\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with work for additional information\n * regarding copyright ownership.  The ASF licenses file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport React, { useCallback, useEffect, useMemo, useState } from 'react';\nimport { ensureIsArray, FeatureFlag, GenericDataType, isFeatureEnabled, tn } from '@superset-ui/core';\n\nimport { usePrevious } from 'src/common/hooks/usePrevious';\nimport AdhocMetric from 'src/explore/components/controls/MetricControl/AdhocMetric';\nimport AdhocMetricPopoverTrigger from 'src/explore/components/controls/MetricControl/AdhocMetricPopoverTrigger';\nimport MetricDefinitionValue from 'src/explore/components/controls/MetricControl/MetricDefinitionValue';\nimport { isDatasourcePanelDndItem } from 'src/explore/components/DatasourcePanel/types';\nimport { DndItemType } from 'src/explore/components/DndItemType';\nimport DndSelectLabel from 'src/explore/components/controls/DndColumnSelectControl/DndSelectLabel';\nimport { AGGREGATES } from 'src/explore/constants';import { jsx as ___EmotionJSX } from \"@emotion/react\";\nconst EMPTY_OBJECT = {};\nconst DND_ACCEPTED_TYPES = [DndItemType.Column, DndItemType.Metric];\nconst isDictionaryForAdhocMetric = (value) => value && !(value instanceof AdhocMetric) && value.expressionType;\nconst coerceAdhocMetrics = (value) => {\n  if (!value) {\n    return [];\n  }\n  if (!Array.isArray(value)) {\n    if (isDictionaryForAdhocMetric(value)) {\n      return [new AdhocMetric(value)];\n    }\n    return [value];\n  }\n  return value.map((val) => {\n    if (isDictionaryForAdhocMetric(val)) {\n      return new AdhocMetric(val);\n    }\n    return val;\n  });\n};\nconst getOptionsForSavedMetrics = (savedMetrics, currentMetricValues, currentMetric) => {var _savedMetrics$filter;return (_savedMetrics$filter = savedMetrics == null ? void 0 : savedMetrics.filter((savedMetric) => {var _savedMetric$metric_n;return Array.isArray(currentMetricValues) ?\n    !currentMetricValues.includes((_savedMetric$metric_n = savedMetric.metric_name) != null ? _savedMetric$metric_n : '') ||\n    savedMetric.metric_name === currentMetric :\n    savedMetric;})) != null ? _savedMetrics$filter : [];};\n// TODO: use typeguards to distinguish saved metrics from adhoc metrics\nconst getMetricsMatchingCurrentDataset = (values, columns, savedMetrics, prevColumns, prevSavedMetrics) => {\n  const areSavedMetricsEqual = !prevSavedMetrics || _isEqual(prevSavedMetrics, savedMetrics);\n  const areColsEqual = !prevColumns || _isEqual(prevColumns, columns);\n  if (areColsEqual && areSavedMetricsEqual) {\n    return values;\n  }\n  return values.reduce((acc, metric) => {\n    if ((typeof metric === 'string' || metric.metric_name) && (\n    areSavedMetricsEqual ||\n    savedMetrics != null && savedMetrics.some((savedMetric) => savedMetric.metric_name === metric ||\n    savedMetric.metric_name === metric.metric_name))) {\n      acc.push(metric);\n      return acc;\n    }\n    if (!areColsEqual) {\n      const newCol = columns == null ? void 0 : columns.find((column) => {var _metric$column;return ((_metric$column = metric.column) == null ? void 0 : _metric$column.column_name) === column.column_name;});\n      if (newCol) {\n        acc.push({ ...metric, column: newCol });\n      }\n    } else\n    {\n      acc.push(metric);\n    }\n    return acc;\n  }, []);\n};\nexport const DndMetricSelect = (props) => {\n  const { onChange, multi, columns, savedMetrics } = props;\n  const handleChange = useCallback((opts) => {\n    // if clear out options\n    if (opts === null) {\n      onChange(null);\n      return;\n    }\n    const transformedOpts = ensureIsArray(opts);\n    const optionValues = transformedOpts.\n    map((option) => {\n      // pre-defined metric\n      if (option.metric_name) {\n        return option.metric_name;\n      }\n      return option;\n    }).\n    filter((option) => option);\n    onChange(multi ? optionValues : optionValues[0]);\n  }, [multi, onChange]);\n  const [value, setValue] = useState(coerceAdhocMetrics(props.value));\n  const [droppedItem, setDroppedItem] = useState({});\n  const [newMetricPopoverVisible, setNewMetricPopoverVisible] = useState(false);\n  const prevColumns = usePrevious(columns);\n  const prevSavedMetrics = usePrevious(savedMetrics);\n  useEffect(() => {\n    setValue(coerceAdhocMetrics(props.value));\n  }, [JSON.stringify(props.value)]);\n  useEffect(() => {\n    // Remove selected custom metrics that do not exist in the dataset anymore\n    // Remove selected adhoc metrics that use columns which do not exist in the dataset anymore\n    // Sync adhoc metrics with dataset columns when they are modified by the user\n    if (!props.value) {\n      return;\n    }\n    const propsValues = ensureIsArray(props.value);\n    const matchingMetrics = getMetricsMatchingCurrentDataset(propsValues, columns, savedMetrics, prevColumns, prevSavedMetrics);\n    if (!_isEqual(propsValues, matchingMetrics)) {\n      handleChange(matchingMetrics);\n    }\n  }, [columns, savedMetrics, handleChange]);\n  const canDrop = useCallback((item) => {\n    const isMetricAlreadyInValues = item.type === 'metric' ? value.includes(item.value.metric_name) : false;\n    return !isMetricAlreadyInValues;\n  }, [value]);\n  const onNewMetric = useCallback((newMetric) => {\n    const newValue = props.multi ? [...value, newMetric] : [newMetric];\n    setValue(newValue);\n    handleChange(newValue);\n  }, [handleChange, props.multi, value]);\n  const onMetricEdit = useCallback((changedMetric, oldMetric) => {\n    if (oldMetric instanceof AdhocMetric && oldMetric.equals(changedMetric)) {\n      return;\n    }\n    const newValue = value.map((value) => {\n      if (\n      // compare saved metrics\n      'metric_name' in oldMetric && value === oldMetric.metric_name ||\n      // compare adhoc metrics\n      typeof value.optionName !== 'undefined' ?\n      value.optionName ===\n      oldMetric.optionName :\n      false) {\n        return changedMetric;\n      }\n      return value;\n    });\n    setValue(newValue);\n    handleChange(newValue);\n  }, [handleChange, value]);\n  const onRemoveMetric = useCallback((index) => {\n    if (!Array.isArray(value)) {\n      return;\n    }\n    const valuesCopy = [...value];\n    valuesCopy.splice(index, 1);\n    setValue(valuesCopy);\n    onChange(valuesCopy);\n  }, [onChange, value]);\n  const moveLabel = useCallback((dragIndex, hoverIndex) => {\n    const newValues = [...value];\n    [newValues[hoverIndex], newValues[dragIndex]] = [\n    newValues[dragIndex],\n    newValues[hoverIndex]];\n\n    setValue(newValues);\n  }, [value]);\n  const newSavedMetricOptions = useMemo(() => getOptionsForSavedMetrics(props.savedMetrics, props.value), [props.savedMetrics, props.value]);\n  const getSavedMetricOptionsForMetric = useCallback((index) => {var _props$value;return getOptionsForSavedMetrics(props.savedMetrics, props.value, (_props$value = props.value) == null ? void 0 : _props$value[index]);}, [props.savedMetrics, props.value]);\n  const handleDropLabel = useCallback(() => onChange(multi ? value : value[0]), [multi, onChange, value]);\n  const valueRenderer = useCallback((option, index) => ___EmotionJSX(MetricDefinitionValue, { key: index, index: index, option: option, onMetricEdit: onMetricEdit, onRemoveMetric: onRemoveMetric, columns: props.columns, savedMetrics: props.savedMetrics, savedMetricsOptions: getSavedMetricOptionsForMetric(index), datasourceType: props.datasourceType, onMoveLabel: moveLabel, onDropLabel: handleDropLabel, type: `${DndItemType.AdhocMetricOption}_${props.name}_${props.label}`, multi: multi }), [\n  getSavedMetricOptionsForMetric,\n  handleDropLabel,\n  moveLabel,\n  multi,\n  onMetricEdit,\n  onRemoveMetric,\n  props.columns,\n  props.datasourceType,\n  props.label,\n  props.name,\n  props.savedMetrics]);\n\n  const valuesRenderer = useCallback(() => value.map((value, index) => valueRenderer(value, index)), [value, valueRenderer]);\n  const togglePopover = useCallback((visible) => {\n    setNewMetricPopoverVisible(visible);\n  }, []);\n  const closePopover = useCallback(() => {\n    togglePopover(false);\n  }, [togglePopover]);\n  const handleDrop = useCallback((item) => {\n    if (item.type === DndItemType.Metric) {\n      onNewMetric(item.value);\n    }\n    if (item.type === DndItemType.Column) {\n      setDroppedItem(item);\n      togglePopover(true);\n    }\n  }, [onNewMetric, togglePopover]);\n  const handleClickGhostButton = useCallback(() => {\n    setDroppedItem({});\n    togglePopover(true);\n  }, [togglePopover]);\n  const adhocMetric = useMemo(() => {\n    if (isDatasourcePanelDndItem(droppedItem) &&\n    droppedItem.type === DndItemType.Column) {\n      const itemValue = droppedItem.value;\n      const config = {\n        column: itemValue };\n\n      if (isFeatureEnabled(FeatureFlag.UX_BETA)) {\n        if (itemValue.type_generic === GenericDataType.NUMERIC) {\n          config.aggregate = AGGREGATES.SUM;\n        } else\n        if (itemValue.type_generic === GenericDataType.STRING ||\n        itemValue.type_generic === GenericDataType.BOOLEAN ||\n        itemValue.type_generic === GenericDataType.TEMPORAL) {\n          config.aggregate = AGGREGATES.COUNT_DISTINCT;\n        }\n      }\n      return new AdhocMetric(config);\n    }\n    return new AdhocMetric({ isNew: true });\n  }, [droppedItem]);\n  const ghostButtonText = isFeatureEnabled(FeatureFlag.ENABLE_DND_WITH_CLICK_UX) ?\n  tn('Drop a column/metric here or click', 'Drop columns/metrics here or click', multi ? 2 : 1) :\n  tn('Drop column or metric here', 'Drop columns or metrics here', multi ? 2 : 1);\n  return ___EmotionJSX(\"div\", { className: \"metrics-select\" },\n  ___EmotionJSX(DndSelectLabel, _extends({ onDrop: handleDrop, canDrop: canDrop, valuesRenderer: valuesRenderer, accept: DND_ACCEPTED_TYPES, ghostButtonText: ghostButtonText, displayGhostButton: multi || value.length === 0, onClickGhostButton: isFeatureEnabled(FeatureFlag.ENABLE_DND_WITH_CLICK_UX) ?\n    handleClickGhostButton :\n    undefined }, props)),\n  ___EmotionJSX(AdhocMetricPopoverTrigger, { adhocMetric: adhocMetric, onMetricEdit: onNewMetric, columns: props.columns, savedMetricsOptions: newSavedMetricOptions, savedMetric: EMPTY_OBJECT, datasourceType: props.datasourceType, isControlledComponent: true, visible: newMetricPopoverVisible, togglePopover: togglePopover, closePopover: closePopover },\n  ___EmotionJSX(\"div\", null)));\n\n\n};","map":null,"metadata":{},"sourceType":"module"}