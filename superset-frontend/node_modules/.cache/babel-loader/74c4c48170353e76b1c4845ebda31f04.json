{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport {\nt,\nlogging,\nSupersetClient,\nwithTheme,\nensureIsArray } from\n'@superset-ui/core';\n\nimport ControlHeader from 'src/explore/components/ControlHeader';\nimport adhocMetricType from 'src/explore/components/controls/MetricControl/adhocMetricType';\nimport savedMetricType from 'src/explore/components/controls/MetricControl/savedMetricType';\nimport AdhocMetric from 'src/explore/components/controls/MetricControl/AdhocMetric';\nimport {\nOperators,\nOPERATOR_ENUM_TO_OPERATOR_TYPE } from\n'src/explore/constants';\nimport FilterDefinitionOption from 'src/explore/components/controls/MetricControl/FilterDefinitionOption';\nimport {\nAddControlLabel,\nAddIconButton,\nHeaderContainer,\nLabelsContainer } from\n'src/explore/components/controls/OptionControls';\nimport Icons from 'src/components/Icons';\nimport AdhocFilterPopoverTrigger from 'src/explore/components/controls/FilterControl/AdhocFilterPopoverTrigger';\nimport AdhocFilterOption from 'src/explore/components/controls/FilterControl/AdhocFilterOption';\nimport AdhocFilter, {\nCLAUSES,\nEXPRESSION_TYPES } from\n'src/explore/components/controls/FilterControl/AdhocFilter';\nimport adhocFilterType from 'src/explore/components/controls/FilterControl/adhocFilterType';\nimport columnType from 'src/explore/components/controls/FilterControl/columnType';import { jsx as ___EmotionJSX } from \"@emotion/react\";\n\nconst selectedMetricType = PropTypes.oneOfType([\nPropTypes.string,\nadhocMetricType]);\n\n\nconst propTypes = {\n  label: PropTypes.oneOfType([PropTypes.object, PropTypes.string]),\n  name: PropTypes.string,\n  sections: PropTypes.arrayOf(PropTypes.string),\n  operators: PropTypes.arrayOf(PropTypes.string),\n  onChange: PropTypes.func,\n  value: PropTypes.arrayOf(adhocFilterType),\n  datasource: PropTypes.object,\n  columns: PropTypes.arrayOf(columnType),\n  savedMetrics: PropTypes.arrayOf(savedMetricType),\n  selectedMetrics: PropTypes.oneOfType([\n  selectedMetricType,\n  PropTypes.arrayOf(selectedMetricType)]),\n\n  isLoading: PropTypes.bool };\n\n\nconst defaultProps = {\n  name: '',\n  onChange: () => {},\n  columns: [],\n  savedMetrics: [],\n  selectedMetrics: [] };\n\n\nfunction isDictionaryForAdhocFilter(value) {\n  return value && !(value instanceof AdhocFilter) && value.expressionType;\n}\n\nclass AdhocFilterControl extends React.Component {\n  constructor(props) {\n    super(props);\n    this.optionsForSelect = this.optionsForSelect.bind(this);\n    this.onRemoveFilter = this.onRemoveFilter.bind(this);\n    this.onNewFilter = this.onNewFilter.bind(this);\n    this.onFilterEdit = this.onFilterEdit.bind(this);\n    this.moveLabel = this.moveLabel.bind(this);\n    this.onChange = this.onChange.bind(this);\n    this.mapOption = this.mapOption.bind(this);\n    this.getMetricExpression = this.getMetricExpression.bind(this);\n\n    const filters = (this.props.value || []).map((filter) =>\n    isDictionaryForAdhocFilter(filter) ? new AdhocFilter(filter) : filter);\n\n\n    this.optionRenderer = (option) => ___EmotionJSX(FilterDefinitionOption, { option: option });\n    this.valueRenderer = (adhocFilter, index) =>\n    ___EmotionJSX(AdhocFilterOption, {\n      key: index,\n      index: index,\n      adhocFilter: adhocFilter,\n      onFilterEdit: this.onFilterEdit,\n      options: this.state.options,\n      sections: this.props.sections,\n      operators: this.props.operators,\n      datasource: this.props.datasource,\n      onRemoveFilter: () => this.onRemoveFilter(index),\n      onMoveLabel: this.moveLabel,\n      onDropLabel: () => this.props.onChange(this.state.values),\n      partitionColumn: this.state.partitionColumn });\n\n\n    this.state = {\n      values: filters,\n      options: this.optionsForSelect(this.props),\n      partitionColumn: null };\n\n  }\n\n  componentDidMount() {\n    const { datasource } = this.props;\n    if (datasource && datasource.type === 'table') {var _datasource$database;\n      const dbId = (_datasource$database = datasource.database) == null ? void 0 : _datasource$database.id;\n      const {\n        datasource_name: name,\n        schema,\n        is_sqllab_view: isSqllabView } =\n      datasource;\n\n      if (!isSqllabView && dbId && name && schema) {\n        SupersetClient.get({\n          endpoint: `/superset/extra_table_metadata/${dbId}/${name}/${schema}/` }).\n\n        then(({ json }) => {\n          if (json && json.partitions) {\n            const { partitions } = json;\n            // for now only show latest_partition option\n            // when table datasource has only 1 partition key.\n            if (\n            partitions &&\n            partitions.cols &&\n            Object.keys(partitions.cols).length === 1)\n            {\n              this.setState({ partitionColumn: partitions.cols[0] });\n            }\n          }\n        }).\n        catch((error) => {\n          logging.error('fetch extra_table_metadata:', error.statusText);\n        });\n      }\n    }\n  }\n\n  UNSAFE_componentWillReceiveProps(nextProps) {\n    if (this.props.columns !== nextProps.columns) {\n      this.setState({ options: this.optionsForSelect(nextProps) });\n    }\n    if (this.props.value !== nextProps.value) {\n      this.setState({\n        values: (nextProps.value || []).map((filter) =>\n        isDictionaryForAdhocFilter(filter) ? new AdhocFilter(filter) : filter) });\n\n\n    }\n  }\n\n  onRemoveFilter(index) {\n    const valuesCopy = [...this.state.values];\n    valuesCopy.splice(index, 1);\n    this.setState((prevState) => ({\n      ...prevState,\n      values: valuesCopy }));\n\n    this.props.onChange(valuesCopy);\n  }\n\n  onNewFilter(newFilter) {\n    const mappedOption = this.mapOption(newFilter);\n    if (mappedOption) {\n      this.setState(\n      (prevState) => ({\n        ...prevState,\n        values: [...prevState.values, mappedOption] }),\n\n      () => {\n        this.props.onChange(this.state.values);\n      });\n\n    }\n  }\n\n  onFilterEdit(changedFilter) {\n    this.props.onChange(\n    this.state.values.map((value) => {\n      if (value.filterOptionName === changedFilter.filterOptionName) {\n        return changedFilter;\n      }\n      return value;\n    }));\n\n  }\n\n  onChange(opts) {\n    const options = (opts || []).\n    map((option) => this.mapOption(option)).\n    filter((option) => option);\n    this.props.onChange(options);\n  }\n\n  getMetricExpression(savedMetricName) {\n    return this.props.savedMetrics.find(\n    (savedMetric) => savedMetric.metric_name === savedMetricName).\n    expression;\n  }\n\n  moveLabel(dragIndex, hoverIndex) {\n    const { values } = this.state;\n\n    const newValues = [...values];\n    [newValues[hoverIndex], newValues[dragIndex]] = [\n    newValues[dragIndex],\n    newValues[hoverIndex]];\n\n    this.setState({ values: newValues });\n  }\n\n  mapOption(option) {\n    // already a AdhocFilter, skip\n    if (option instanceof AdhocFilter) {\n      return option;\n    }\n    // via datasource saved metric\n    if (option.saved_metric_name) {\n      return new AdhocFilter({\n        expressionType:\n        this.props.datasource.type === 'druid' ?\n        EXPRESSION_TYPES.SIMPLE :\n        EXPRESSION_TYPES.SQL,\n        subject:\n        this.props.datasource.type === 'druid' ?\n        option.saved_metric_name :\n        this.getMetricExpression(option.saved_metric_name),\n        operator:\n        OPERATOR_ENUM_TO_OPERATOR_TYPE[Operators.GREATER_THAN].operation,\n        comparator: 0,\n        clause: CLAUSES.HAVING });\n\n    }\n    // has a custom label, meaning it's custom column\n    if (option.label) {\n      return new AdhocFilter({\n        expressionType:\n        this.props.datasource.type === 'druid' ?\n        EXPRESSION_TYPES.SIMPLE :\n        EXPRESSION_TYPES.SQL,\n        subject:\n        this.props.datasource.type === 'druid' ?\n        option.label :\n        new AdhocMetric(option).translateToSql(),\n        operator:\n        OPERATOR_ENUM_TO_OPERATOR_TYPE[Operators.GREATER_THAN].operation,\n        comparator: 0,\n        clause: CLAUSES.HAVING });\n\n    }\n    // add a new filter item\n    if (option.column_name) {\n      return new AdhocFilter({\n        expressionType: EXPRESSION_TYPES.SIMPLE,\n        subject: option.column_name,\n        operator: OPERATOR_ENUM_TO_OPERATOR_TYPE[Operators.EQUALS].operation,\n        comparator: '',\n        clause: CLAUSES.WHERE,\n        isNew: true });\n\n    }\n    return null;\n  }\n\n  optionsForSelect(props) {\n    const options = [\n    ...props.columns,\n    ...ensureIsArray(props.selectedMetrics).map(\n    (metric) =>\n    metric && (\n    typeof metric === 'string' ?\n    { saved_metric_name: metric } :\n    new AdhocMetric(metric)))].\n\n    filter((option) => option);\n\n    return options.\n    reduce((results, option) => {\n      if (option.saved_metric_name) {\n        results.push({\n          ...option,\n          filterOptionName: option.saved_metric_name });\n\n      } else if (option.column_name) {\n        results.push({\n          ...option,\n          filterOptionName: `_col_${option.column_name}` });\n\n      } else if (option instanceof AdhocMetric) {\n        results.push({\n          ...option,\n          filterOptionName: `_adhocmetric_${option.label}` });\n\n      }\n      return results;\n    }, []).\n    sort((a, b) =>\n    (a.saved_metric_name || a.column_name || a.label).localeCompare(\n    b.saved_metric_name || b.column_name || b.label));\n\n\n  }\n\n  addNewFilterPopoverTrigger(trigger) {\n    return (\n      ___EmotionJSX(AdhocFilterPopoverTrigger, {\n        operators: this.props.operators,\n        sections: this.props.sections,\n        adhocFilter: new AdhocFilter({}),\n        datasource: this.props.datasource,\n        options: this.state.options,\n        onFilterEdit: this.onNewFilter,\n        partitionColumn: this.state.partitionColumn },\n\n      trigger));\n\n\n  }\n\n  render() {\n    const { theme } = this.props;\n    return (\n      ___EmotionJSX(\"div\", { className: \"metrics-select\" },\n      ___EmotionJSX(HeaderContainer, null,\n      ___EmotionJSX(ControlHeader, this.props),\n      this.addNewFilterPopoverTrigger(\n      ___EmotionJSX(AddIconButton, null,\n      ___EmotionJSX(Icons.PlusLarge, {\n        iconSize: \"s\",\n        iconColor: theme.colors.grayscale.light5 })))),\n\n\n\n\n      ___EmotionJSX(LabelsContainer, null,\n      this.state.values.length > 0 ?\n      this.state.values.map((value, index) =>\n      this.valueRenderer(value, index)) :\n\n      this.addNewFilterPopoverTrigger(\n      ___EmotionJSX(AddControlLabel, null,\n      ___EmotionJSX(Icons.PlusSmall, { iconColor: theme.colors.grayscale.light1 }),\n      t('Add filter'))))));\n\n\n\n\n\n  }}\n\n\nAdhocFilterControl.propTypes = propTypes;\nAdhocFilterControl.defaultProps = defaultProps;\n\nexport default withTheme(AdhocFilterControl);","map":null,"metadata":{},"sourceType":"module"}