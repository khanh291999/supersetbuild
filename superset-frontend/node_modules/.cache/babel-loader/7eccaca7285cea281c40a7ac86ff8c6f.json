{"ast":null,"code":"import { ensureIsArray } from '@superset-ui/core';\nimport { getSectionsToRender } from './getSectionsToRender';\nimport { getControlConfig } from './getControlConfig';\nfunction execControlValidator(control, processedState) {\n  const validators = control.validators;\n  const { externalValidationErrors = [] } = control;\n  const errors = [];\n  if (validators && validators.length > 0) {\n    validators.forEach((validator) => {\n      const error = validator.call(control, control.value, processedState);\n      if (error) {\n        errors.push(error);\n      }\n    });\n  }\n  const validationErrors = [...errors, ...externalValidationErrors];\n  // always reset validation errors even when there is no validator\n  return { ...control, validationErrors };\n}\n/**\n * Clear control values that are no longer in the `choices` list.\n */\nfunction handleMissingChoice(control) {\n  // If the value is not valid anymore based on choices, clear it\n  if (control.type === 'SelectControl' &&\n  !control.freeForm &&\n  control.choices &&\n  control.value) {\n    const alteredControl = { ...control };\n    const choices = control.choices;\n    const value = ensureIsArray(control.value);\n    const choiceValues = choices.map((c) => c[0]);\n    if (control.multi && value.length > 0) {\n      alteredControl.value = value.filter((el) => choiceValues.includes(el));\n      return alteredControl;\n    }\n    if (!control.multi && !choiceValues.includes(value[0])) {\n      alteredControl.value = null;\n      return alteredControl;\n    }\n  }\n  return control;\n}\nexport function applyMapStateToPropsToControl(controlState, controlPanelState) {\n  const { mapStateToProps } = controlState;\n  let state = { ...controlState };\n  let { value } = state; // value is current user-input value\n  if (mapStateToProps && controlPanelState) {\n    state = {\n      ...controlState,\n      ...mapStateToProps.call(controlState, controlPanelState, controlState) };\n\n    // `mapStateToProps` may also provide a value\n    value = value || state.value;\n  }\n  // If default is a function, evaluate it\n  if (typeof state.default === 'function') {\n    state.default = state.default(state, controlPanelState);\n    // if default is still a function, discard\n    if (typeof state.default === 'function') {\n      delete state.default;\n    }\n  }\n  // If no current value, set it as default\n  if (state.default && value === undefined) {\n    value = state.default;\n  }\n  // If a choice control went from multi=false to true, wrap value in array\n  if (value && state.multi && !Array.isArray(value)) {\n    value = [value];\n  }\n  state.value = value;\n  return execControlValidator(handleMissingChoice(state), state);\n}\nexport function getControlStateFromControlConfig(controlConfig, controlPanelState, value) {\n  // skip invalid config values\n  if (!controlConfig) {\n    return null;\n  }\n  const controlState = { ...controlConfig, value };\n  // only apply mapStateToProps when control states have been initialized\n  // or when explicitly didn't provide control panel state (mostly for testing)\n  if (controlPanelState && controlPanelState.controls ||\n  controlPanelState === null) {\n    return applyMapStateToPropsToControl(controlState, controlPanelState);\n  }\n  return controlState;\n}\nexport function getControlState(controlKey, vizType, state, value) {\n  return getControlStateFromControlConfig(getControlConfig(controlKey, vizType), state, value);\n}\nexport function getAllControlsState(vizType, datasourceType, state, formData) {\n  const controlsState = {};\n  getSectionsToRender(vizType, datasourceType).forEach((section) => section.controlSetRows.forEach((fieldsetRow) => fieldsetRow.forEach((field) => {\n    if (field && 'config' in field && field.config && field.name) {\n      const { config, name } = field;\n      controlsState[name] = getControlStateFromControlConfig(config, state, formData[name]);\n    }\n  })));\n  return controlsState;\n}","map":null,"metadata":{},"sourceType":"module"}