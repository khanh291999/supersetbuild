{"ast":null,"code":"import _isEqual from \"lodash/isEqual\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport React, { useCallback, useEffect, useMemo, useState } from 'react';\nimport PropTypes from 'prop-types';\nimport { ensureIsArray, t, useTheme } from '@superset-ui/core';\n\nimport ControlHeader from 'src/explore/components/ControlHeader';\nimport Icons from 'src/components/Icons';\nimport {\nAddIconButton,\nAddControlLabel,\nHeaderContainer,\nLabelsContainer } from\n'src/explore/components/controls/OptionControls';\nimport { usePrevious } from 'src/common/hooks/usePrevious';\nimport columnType from './columnType';\nimport MetricDefinitionValue from './MetricDefinitionValue';\nimport AdhocMetric from './AdhocMetric';\nimport savedMetricType from './savedMetricType';\nimport adhocMetricType from './adhocMetricType';\nimport AdhocMetricPopoverTrigger from './AdhocMetricPopoverTrigger';import { jsx as ___EmotionJSX } from \"@emotion/react\";\n\nconst propTypes = {\n  name: PropTypes.string.isRequired,\n  onChange: PropTypes.func,\n  value: PropTypes.oneOfType([\n  PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, adhocMetricType])),\n  PropTypes.oneOfType([PropTypes.string, adhocMetricType])]),\n\n  columns: PropTypes.arrayOf(columnType),\n  savedMetrics: PropTypes.arrayOf(savedMetricType),\n  isLoading: PropTypes.bool,\n  multi: PropTypes.bool,\n  clearable: PropTypes.bool,\n  datasourceType: PropTypes.string };\n\n\nconst defaultProps = {\n  onChange: () => {},\n  clearable: true,\n  savedMetrics: [],\n  columns: [] };\n\n\nfunction getOptionsForSavedMetrics(\nsavedMetrics,\ncurrentMetricValues,\ncurrentMetric)\n{var _savedMetrics$filter;\n  return (_savedMetrics$filter =\n  savedMetrics == null ? void 0 : savedMetrics.filter((savedMetric) =>\n  Array.isArray(currentMetricValues) ?\n  !currentMetricValues.includes(savedMetric.metric_name) ||\n  savedMetric.metric_name === currentMetric :\n  savedMetric)) != null ? _savedMetrics$filter :\n  [];\n\n}\n\nfunction isDictionaryForAdhocMetric(value) {\n  return value && !(value instanceof AdhocMetric) && value.expressionType;\n}\n\n// adhoc metrics are stored as dictionaries in URL params. We convert them back into the\n// AdhocMetric class for typechecking, consistency and instance method access.\nfunction coerceAdhocMetrics(value) {\n  if (!value) {\n    return [];\n  }\n  if (!Array.isArray(value)) {\n    if (isDictionaryForAdhocMetric(value)) {\n      return [new AdhocMetric(value)];\n    }\n    return [value];\n  }\n  return value.map((val) => {\n    if (isDictionaryForAdhocMetric(val)) {\n      return new AdhocMetric(val);\n    }\n    return val;\n  });\n}\n\nconst emptySavedMetric = { metric_name: '', expression: '' };\n\n// TODO: use typeguards to distinguish saved metrics from adhoc metrics\nconst getMetricsMatchingCurrentDataset = (value, columns, savedMetrics) =>\nensureIsArray(value).filter((metric) => {\n  if (typeof metric === 'string' || metric.metric_name) {\n    return savedMetrics == null ? void 0 : savedMetrics.some(\n    (savedMetric) =>\n    savedMetric.metric_name === metric ||\n    savedMetric.metric_name === metric.metric_name);\n\n  }\n  return columns == null ? void 0 : columns.some(\n  (column) =>\n  !metric.column || metric.column.column_name === column.column_name);\n\n});\n\nconst MetricsControl = ({\n  onChange,\n  multi,\n  value: propsValue,\n  columns,\n  savedMetrics,\n  datasource,\n  datasourceType,\n  ...props }) =>\n{\n  const [value, setValue] = useState(coerceAdhocMetrics(propsValue));\n  const theme = useTheme();\n  const prevColumns = usePrevious(columns);\n  const prevSavedMetrics = usePrevious(savedMetrics);\n\n  const handleChange = useCallback(\n  (opts) => {\n    // if clear out options\n    if (opts === null) {\n      onChange(null);\n      return;\n    }\n\n    const transformedOpts = ensureIsArray(opts);\n    const optionValues = transformedOpts.\n    map((option) => {\n      // pre-defined metric\n      if (option.metric_name) {\n        return option.metric_name;\n      }\n      return option;\n    }).\n    filter((option) => option);\n    onChange(multi ? optionValues : optionValues[0]);\n  },\n  [multi, onChange]);\n\n\n  const onNewMetric = useCallback(\n  (newMetric) => {\n    const newValue = [...value, newMetric];\n    setValue(newValue);\n    handleChange(newValue);\n  },\n  [handleChange, value]);\n\n\n  const onMetricEdit = useCallback(\n  (changedMetric, oldMetric) => {\n    const newValue = value.map((val) => {\n      if (\n      // compare saved metrics\n      val === oldMetric.metric_name ||\n      // compare adhoc metrics\n      typeof val.optionName !== 'undefined' ?\n      val.optionName === oldMetric.optionName :\n      false)\n      {\n        return changedMetric;\n      }\n      return val;\n    });\n    setValue(newValue);\n    handleChange(newValue);\n  },\n  [handleChange, value]);\n\n\n  const onRemoveMetric = useCallback(\n  (index) => {\n    if (!Array.isArray(value)) {\n      return;\n    }\n    const valuesCopy = [...value];\n    valuesCopy.splice(index, 1);\n    setValue(valuesCopy);\n    handleChange(valuesCopy);\n  },\n  [handleChange, value]);\n\n\n  const moveLabel = useCallback(\n  (dragIndex, hoverIndex) => {\n    const newValues = [...value];\n    [newValues[hoverIndex], newValues[dragIndex]] = [\n    newValues[dragIndex],\n    newValues[hoverIndex]];\n\n    setValue(newValues);\n  },\n  [value]);\n\n\n  const isAddNewMetricDisabled = useCallback(() => !multi && value.length > 0, [\n  multi,\n  value.length]);\n\n\n  const savedMetricOptions = useMemo(\n  () => getOptionsForSavedMetrics(savedMetrics, propsValue, null),\n  [propsValue, savedMetrics]);\n\n\n  const newAdhocMetric = useMemo(() => new AdhocMetric({ isNew: true }), [\n  value]);\n\n  const addNewMetricPopoverTrigger = useCallback(\n  (trigger) => {\n    if (isAddNewMetricDisabled()) {\n      return trigger;\n    }\n    return (\n      ___EmotionJSX(AdhocMetricPopoverTrigger, {\n        adhocMetric: newAdhocMetric,\n        onMetricEdit: onNewMetric,\n        columns: columns,\n        savedMetricsOptions: savedMetricOptions,\n        datasource: datasource,\n        savedMetric: emptySavedMetric,\n        datasourceType: datasourceType },\n\n      trigger));\n\n\n  },\n  [\n  columns,\n  datasource,\n  datasourceType,\n  isAddNewMetricDisabled,\n  newAdhocMetric,\n  onNewMetric,\n  savedMetricOptions]);\n\n\n\n  useEffect(() => {\n    // Remove selected custom metrics that do not exist in the dataset anymore\n    // Remove selected adhoc metrics that use columns which do not exist in the dataset anymore\n    if (\n    propsValue && (\n    !_isEqual(prevColumns, columns) ||\n    !_isEqual(prevSavedMetrics, savedMetrics)))\n    {\n      const matchingMetrics = getMetricsMatchingCurrentDataset(\n      propsValue,\n      columns,\n      savedMetrics);\n\n      if (!_isEqual(matchingMetrics, propsValue)) {\n        handleChange(matchingMetrics);\n      }\n    }\n  }, [columns, handleChange, savedMetrics]);\n\n  useEffect(() => {\n    setValue(coerceAdhocMetrics(propsValue));\n  }, [propsValue]);\n\n  const onDropLabel = useCallback(() => handleChange(value), [\n  handleChange,\n  value]);\n\n\n  const valueRenderer = useCallback(\n  (option, index) =>\n  ___EmotionJSX(MetricDefinitionValue, {\n    key: index,\n    index: index,\n    option: option,\n    onMetricEdit: onMetricEdit,\n    onRemoveMetric: onRemoveMetric,\n    columns: columns,\n    datasource: datasource,\n    savedMetrics: savedMetrics,\n    savedMetricsOptions: getOptionsForSavedMetrics(\n    savedMetrics,\n    value,\n    value == null ? void 0 : value[index]),\n\n    datasourceType: datasourceType,\n    onMoveLabel: moveLabel,\n    onDropLabel: onDropLabel,\n    multi: multi }),\n\n\n  [\n  columns,\n  datasource,\n  datasourceType,\n  moveLabel,\n  multi,\n  onDropLabel,\n  onMetricEdit,\n  onRemoveMetric,\n  savedMetrics,\n  value]);\n\n\n\n  return (\n    ___EmotionJSX(\"div\", { className: \"metrics-select\" },\n    ___EmotionJSX(HeaderContainer, null,\n    ___EmotionJSX(ControlHeader, props),\n    addNewMetricPopoverTrigger(\n    ___EmotionJSX(AddIconButton, {\n      disabled: isAddNewMetricDisabled() },\n\n\n    ___EmotionJSX(Icons.PlusLarge, {\n      iconSize: \"s\",\n      iconColor: theme.colors.grayscale.light5 })))),\n\n\n\n\n    ___EmotionJSX(LabelsContainer, null,\n    value.length > 0 ?\n    value.map((value, index) => valueRenderer(value, index)) :\n    addNewMetricPopoverTrigger(\n    ___EmotionJSX(AddControlLabel, null,\n    ___EmotionJSX(Icons.PlusSmall, { iconColor: theme.colors.grayscale.light1 }),\n    t('Add metric'))))));\n\n\n\n\n\n};\n\nMetricsControl.propTypes = propTypes;\nMetricsControl.defaultProps = defaultProps;\n\nexport default MetricsControl;","map":null,"metadata":{},"sourceType":"module"}