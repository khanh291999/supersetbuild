{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport { isFeatureEnabled, t, FeatureFlag } from '@superset-ui/core';\n\nimport { PluginContext } from 'src/components/DynamicPlugins';\nimport Loading from 'src/components/Loading';\nimport getChartIdsFromLayout from '../util/getChartIdsFromLayout';\nimport getLayoutComponentFromChartId from '../util/getLayoutComponentFromChartId';\nimport DashboardBuilder from './DashboardBuilder/DashboardBuilder';\nimport {\nchartPropShape,\nslicePropShape,\ndashboardInfoPropShape,\ndashboardStatePropShape } from\n'../util/propShapes';\nimport {\nLOG_ACTIONS_HIDE_BROWSER_TAB,\nLOG_ACTIONS_MOUNT_DASHBOARD,\nLogger } from\n'../../logger/LogUtils';\nimport OmniContainer from '../../components/OmniContainer';\nimport { areObjectsEqual } from '../../reduxUtils';\n\nimport '../stylesheets/index.less';\nimport getLocationHash from '../util/getLocationHash';\nimport isDashboardEmpty from '../util/isDashboardEmpty';\nimport { getAffectedOwnDataCharts } from '../util/charts/getOwnDataCharts';import { jsx as ___EmotionJSX } from \"@emotion/react\";\n\nconst propTypes = {\n  actions: PropTypes.shape({\n    addSliceToDashboard: PropTypes.func.isRequired,\n    removeSliceFromDashboard: PropTypes.func.isRequired,\n    triggerQuery: PropTypes.func.isRequired,\n    logEvent: PropTypes.func.isRequired,\n    clearDataMaskState: PropTypes.func.isRequired }).\n  isRequired,\n  dashboardInfo: dashboardInfoPropShape.isRequired,\n  dashboardState: dashboardStatePropShape.isRequired,\n  charts: PropTypes.objectOf(chartPropShape).isRequired,\n  slices: PropTypes.objectOf(slicePropShape).isRequired,\n  activeFilters: PropTypes.object.isRequired,\n  chartConfiguration: PropTypes.object.isRequired,\n  datasources: PropTypes.object.isRequired,\n  ownDataCharts: PropTypes.object.isRequired,\n  layout: PropTypes.object.isRequired,\n  impressionId: PropTypes.string.isRequired,\n  initMessages: PropTypes.array,\n  timeout: PropTypes.number,\n  userId: PropTypes.string };\n\n\nconst defaultProps = {\n  initMessages: [],\n  timeout: 60,\n  userId: '' };\n\n\nclass Dashboard extends React.PureComponent {\n\n\n  static onBeforeUnload(hasChanged) {\n    if (hasChanged) {\n      window.addEventListener('beforeunload', Dashboard.unload);\n    } else {\n      window.removeEventListener('beforeunload', Dashboard.unload);\n    }\n  }\n\n  static unload() {\n    const message = t('You have unsaved changes.');\n    window.event.returnValue = message; // Gecko + IE\n    return message; // Gecko + Webkit, Safari, Chrome etc.\n  }\n\n  constructor(props) {var _props$activeFilters, _props$ownDataCharts;\n    super(props);\n    this.appliedFilters = (_props$activeFilters = props.activeFilters) != null ? _props$activeFilters : {};\n    this.appliedOwnDataCharts = (_props$ownDataCharts = props.ownDataCharts) != null ? _props$ownDataCharts : {};\n    this.onVisibilityChange = this.onVisibilityChange.bind(this);\n  }\n\n  componentDidMount() {\n    const appContainer = document.getElementById('app');\n    const bootstrapData = (appContainer == null ? void 0 : appContainer.getAttribute('data-bootstrap')) || '';\n    const { dashboardState, layout } = this.props;\n    const eventData = {\n      is_soft_navigation: Logger.timeOriginOffset > 0,\n      is_edit_mode: dashboardState.editMode,\n      mount_duration: Logger.getTimestamp(),\n      is_empty: isDashboardEmpty(layout),\n      is_published: dashboardState.isPublished,\n      bootstrap_data_length: bootstrapData.length };\n\n    const directLinkComponentId = getLocationHash();\n    if (directLinkComponentId) {\n      eventData.target_id = directLinkComponentId;\n    }\n    this.props.actions.logEvent(LOG_ACTIONS_MOUNT_DASHBOARD, eventData);\n\n    // Handle browser tab visibility change\n    if (document.visibilityState === 'hidden') {\n      this.visibilityEventData = {\n        start_offset: Logger.getTimestamp(),\n        ts: new Date().getTime() };\n\n    }\n    window.addEventListener('visibilitychange', this.onVisibilityChange);\n    this.applyCharts();\n  }\n\n  componentDidUpdate() {\n    this.applyCharts();\n  }\n\n  UNSAFE_componentWillReceiveProps(nextProps) {\n    const currentChartIds = getChartIdsFromLayout(this.props.layout);\n    const nextChartIds = getChartIdsFromLayout(nextProps.layout);\n\n    if (this.props.dashboardInfo.id !== nextProps.dashboardInfo.id) {\n      // single-page-app navigation check\n      return;\n    }\n\n    if (currentChartIds.length < nextChartIds.length) {\n      const newChartIds = nextChartIds.filter(\n      (key) => currentChartIds.indexOf(key) === -1);\n\n      newChartIds.forEach((newChartId) =>\n      this.props.actions.addSliceToDashboard(\n      newChartId,\n      getLayoutComponentFromChartId(nextProps.layout, newChartId)));\n\n\n    } else if (currentChartIds.length > nextChartIds.length) {\n      // remove chart\n      const removedChartIds = currentChartIds.filter(\n      (key) => nextChartIds.indexOf(key) === -1);\n\n      removedChartIds.forEach((removedChartId) =>\n      this.props.actions.removeSliceFromDashboard(removedChartId));\n\n    }\n  }\n\n  applyCharts() {\n    const { hasUnsavedChanges, editMode } = this.props.dashboardState;\n\n    const { appliedFilters, appliedOwnDataCharts } = this;\n    const { activeFilters, ownDataCharts, chartConfiguration } = this.props;\n    if (\n    isFeatureEnabled(FeatureFlag.DASHBOARD_CROSS_FILTERS) &&\n    !chartConfiguration)\n    {\n      // For a first loading we need to wait for cross filters charts data loaded to get all active filters\n      // for correct comparing  of filters to avoid unnecessary requests\n      return;\n    }\n\n    if (\n    !editMode && (\n    !areObjectsEqual(appliedOwnDataCharts, ownDataCharts, {\n      ignoreUndefined: true }) ||\n\n    !areObjectsEqual(appliedFilters, activeFilters, {\n      ignoreUndefined: true })))\n\n    {\n      this.applyFilters();\n    }\n\n    if (hasUnsavedChanges) {\n      Dashboard.onBeforeUnload(true);\n    } else {\n      Dashboard.onBeforeUnload(false);\n    }\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('visibilitychange', this.onVisibilityChange);\n    this.props.actions.clearDataMaskState();\n  }\n\n  onVisibilityChange() {\n    if (document.visibilityState === 'hidden') {\n      // from visible to hidden\n      this.visibilityEventData = {\n        start_offset: Logger.getTimestamp(),\n        ts: new Date().getTime() };\n\n    } else if (document.visibilityState === 'visible') {\n      // from hidden to visible\n      const logStart = this.visibilityEventData.start_offset;\n      this.props.actions.logEvent(LOG_ACTIONS_HIDE_BROWSER_TAB, {\n        ...this.visibilityEventData,\n        duration: Logger.getTimestamp() - logStart });\n\n    }\n  }\n\n  // return charts in array\n  getAllCharts() {\n    return Object.values(this.props.charts);\n  }\n\n  applyFilters() {\n    const { appliedFilters } = this;\n    const { activeFilters, ownDataCharts } = this.props;\n\n    // refresh charts if a filter was removed, added, or changed\n    const currFilterKeys = Object.keys(activeFilters);\n    const appliedFilterKeys = Object.keys(appliedFilters);\n\n    const allKeys = new Set(currFilterKeys.concat(appliedFilterKeys));\n    const affectedChartIds = getAffectedOwnDataCharts(\n    ownDataCharts,\n    this.appliedOwnDataCharts);\n\n    [...allKeys].forEach((filterKey) => {\n      if (\n      !currFilterKeys.includes(filterKey) &&\n      appliedFilterKeys.includes(filterKey))\n      {\n        // filterKey is removed?\n        affectedChartIds.push(...appliedFilters[filterKey].scope);\n      } else if (!appliedFilterKeys.includes(filterKey)) {\n        // filterKey is newly added?\n        affectedChartIds.push(...activeFilters[filterKey].scope);\n      } else {\n        // if filterKey changes value,\n        // update charts in its scope\n        if (\n        !areObjectsEqual(\n        appliedFilters[filterKey].values,\n        activeFilters[filterKey].values,\n        {\n          ignoreUndefined: true }))\n\n\n        {\n          affectedChartIds.push(...activeFilters[filterKey].scope);\n        }\n\n        // if filterKey changes scope,\n        // update all charts in its scope\n        if (\n        !areObjectsEqual(\n        appliedFilters[filterKey].scope,\n        activeFilters[filterKey].scope))\n\n        {\n          const chartsInScope = (activeFilters[filterKey].scope || []).concat(\n          appliedFilters[filterKey].scope || []);\n\n          affectedChartIds.push(...chartsInScope);\n        }\n      }\n    });\n\n    // remove dup in affectedChartIds\n    this.refreshCharts([...new Set(affectedChartIds)]);\n    this.appliedFilters = activeFilters;\n    this.appliedOwnDataCharts = ownDataCharts;\n  }\n\n  refreshCharts(ids) {\n    ids.forEach((id) => {\n      this.props.actions.triggerQuery(true, id);\n    });\n  }\n\n  render() {\n    if (this.context.loading) {\n      return ___EmotionJSX(Loading, null);\n    }\n    return (\n      ___EmotionJSX(React.Fragment, null,\n      ___EmotionJSX(OmniContainer, null),\n      ___EmotionJSX(DashboardBuilder, null)));\n\n\n  }}Dashboard.contextType = PluginContext;\n\n\nDashboard.propTypes = propTypes;\nDashboard.defaultProps = defaultProps;\n\nexport default Dashboard;","map":null,"metadata":{},"sourceType":"module"}