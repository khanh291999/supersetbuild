{"ast":null,"code":"import _URL from \"@babel/runtime-corejs3/core-js-stable/url\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-env browser */\nimport moment from 'moment';\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport { styled, t } from '@superset-ui/core';\nimport ButtonGroup from 'src/components/ButtonGroup';\nimport CertifiedIcon from 'src/components/CertifiedIcon';\n\nimport {\nLOG_ACTIONS_PERIODIC_RENDER_DASHBOARD,\nLOG_ACTIONS_FORCE_REFRESH_DASHBOARD,\nLOG_ACTIONS_TOGGLE_EDIT_DASHBOARD } from\n'src/logger/LogUtils';\nimport { isFeatureEnabled, FeatureFlag } from 'src/featureFlags';\n\nimport Icons from 'src/components/Icons';\nimport Button from 'src/components/Button';\nimport EditableTitle from 'src/components/EditableTitle';\nimport FaveStar from 'src/components/FaveStar';\nimport { safeStringify } from 'src/utils/safeStringify';\nimport HeaderActionsDropdown from 'src/dashboard/components/Header/HeaderActionsDropdown';\nimport HeaderReportActionsDropdown from 'src/components/ReportModal/HeaderReportActionsDropdown';\nimport PublishedStatus from 'src/dashboard/components/PublishedStatus';\nimport UndoRedoKeyListeners from 'src/dashboard/components/UndoRedoKeyListeners';\nimport PropertiesModal from 'src/dashboard/components/PropertiesModal';\nimport ReportModal from 'src/components/ReportModal';\nimport { chartPropShape } from 'src/dashboard/util/propShapes';\nimport { UserWithPermissionsAndRoles } from 'src/types/bootstrapTypes';\nimport {\nUNDO_LIMIT,\nSAVE_TYPE_OVERWRITE,\nDASHBOARD_POSITION_DATA_LIMIT } from\n'src/dashboard/util/constants';\nimport setPeriodicRunner, {\nstopPeriodicRender } from\n'src/dashboard/util/setPeriodicRunner';\nimport { options as PeriodicRefreshOptions } from 'src/dashboard/components/RefreshIntervalModal';import { jsx as ___EmotionJSX } from \"@emotion/react\";\n\nconst propTypes = {\n  addSuccessToast: PropTypes.func.isRequired,\n  addDangerToast: PropTypes.func.isRequired,\n  addWarningToast: PropTypes.func.isRequired,\n  user: UserWithPermissionsAndRoles,\n  dashboardInfo: PropTypes.object.isRequired,\n  dashboardTitle: PropTypes.string.isRequired,\n  dataMask: PropTypes.object.isRequired,\n  charts: PropTypes.objectOf(chartPropShape).isRequired,\n  layout: PropTypes.object.isRequired,\n  expandedSlices: PropTypes.object.isRequired,\n  customCss: PropTypes.string.isRequired,\n  colorNamespace: PropTypes.string,\n  colorScheme: PropTypes.string,\n  setColorSchemeAndUnsavedChanges: PropTypes.func.isRequired,\n  isStarred: PropTypes.bool.isRequired,\n  isPublished: PropTypes.bool.isRequired,\n  isLoading: PropTypes.bool.isRequired,\n  onSave: PropTypes.func.isRequired,\n  onChange: PropTypes.func.isRequired,\n  fetchFaveStar: PropTypes.func.isRequired,\n  fetchCharts: PropTypes.func.isRequired,\n  fetchUISpecificReport: PropTypes.func.isRequired,\n  saveFaveStar: PropTypes.func.isRequired,\n  savePublished: PropTypes.func.isRequired,\n  updateDashboardTitle: PropTypes.func.isRequired,\n  editMode: PropTypes.bool.isRequired,\n  setEditMode: PropTypes.func.isRequired,\n  showBuilderPane: PropTypes.func.isRequired,\n  updateCss: PropTypes.func.isRequired,\n  logEvent: PropTypes.func.isRequired,\n  hasUnsavedChanges: PropTypes.bool.isRequired,\n  maxUndoHistoryExceeded: PropTypes.bool.isRequired,\n  lastModifiedTime: PropTypes.number.isRequired,\n\n  // redux\n  onRefresh: PropTypes.func.isRequired,\n  onUndo: PropTypes.func.isRequired,\n  onRedo: PropTypes.func.isRequired,\n  undoLength: PropTypes.number.isRequired,\n  redoLength: PropTypes.number.isRequired,\n  setMaxUndoHistoryExceeded: PropTypes.func.isRequired,\n  maxUndoHistoryToast: PropTypes.func.isRequired,\n  refreshFrequency: PropTypes.number.isRequired,\n  shouldPersistRefreshFrequency: PropTypes.bool.isRequired,\n  setRefreshFrequency: PropTypes.func.isRequired,\n  dashboardInfoChanged: PropTypes.func.isRequired,\n  dashboardTitleChanged: PropTypes.func.isRequired };\n\n\nconst defaultProps = {\n  colorNamespace: undefined,\n  colorScheme: undefined };\n\n\n// Styled Components\nconst StyledDashboardHeader = styled.div`\n  background: ${({ theme }) => theme.colors.grayscale.light5};\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  justify-content: space-between;\n  padding: 0 ${({ theme }) => theme.gridUnit * 6}px;\n  border-bottom: 1px solid ${({ theme }) => theme.colors.grayscale.light2};\n\n  .action-button > span {\n    color: ${({ theme }) => theme.colors.grayscale.base};\n  }\n  button,\n  .fave-unfave-icon {\n    margin-left: ${({ theme }) => theme.gridUnit * 2}px;\n  }\n  .button-container {\n    display: flex;\n    flex-direction: row;\n    flex-wrap: nowrap;\n    .action-button {\n      font-size: ${({ theme }) => theme.typography.sizes.xl}px;\n      margin-left: ${({ theme }) => theme.gridUnit * 2.5}px;\n    }\n  }\n`;\n\nclass Header extends React.PureComponent {\n  static discardChanges() {\n    const url = new _URL(window.location.href);\n\n    url.searchParams.delete('edit');\n    window.location.assign(url);\n  }\n\n  constructor(props) {\n    super(props);\n    this.state = {\n      didNotifyMaxUndoHistoryToast: false,\n      emphasizeUndo: false,\n      showingPropertiesModal: false,\n      showingReportModal: false };\n\n\n    this.handleChangeText = this.handleChangeText.bind(this);\n    this.handleCtrlZ = this.handleCtrlZ.bind(this);\n    this.handleCtrlY = this.handleCtrlY.bind(this);\n    this.toggleEditMode = this.toggleEditMode.bind(this);\n    this.forceRefresh = this.forceRefresh.bind(this);\n    this.startPeriodicRender = this.startPeriodicRender.bind(this);\n    this.overwriteDashboard = this.overwriteDashboard.bind(this);\n    this.showPropertiesModal = this.showPropertiesModal.bind(this);\n    this.hidePropertiesModal = this.hidePropertiesModal.bind(this);\n    this.showReportModal = this.showReportModal.bind(this);\n    this.hideReportModal = this.hideReportModal.bind(this);\n    this.renderReportModal = this.renderReportModal.bind(this);\n  }\n\n  componentDidMount() {\n    const { refreshFrequency, user, dashboardInfo } = this.props;\n    this.startPeriodicRender(refreshFrequency * 1000);\n    if (this.canAddReports()) {\n      // this is in case there is an anonymous user.\n      this.props.fetchUISpecificReport(\n      user.userId,\n      'dashboard_id',\n      'dashboards',\n      dashboardInfo.id,\n      user.email);\n\n    }\n  }\n\n  UNSAFE_componentWillReceiveProps(nextProps) {\n    const { user } = this.props;\n    if (\n    UNDO_LIMIT - nextProps.undoLength <= 0 &&\n    !this.state.didNotifyMaxUndoHistoryToast)\n    {\n      this.setState(() => ({ didNotifyMaxUndoHistoryToast: true }));\n      this.props.maxUndoHistoryToast();\n    }\n    if (\n    nextProps.undoLength > UNDO_LIMIT &&\n    !this.props.maxUndoHistoryExceeded)\n    {\n      this.props.setMaxUndoHistoryExceeded();\n    }\n    if (\n    this.canAddReports() &&\n    nextProps.dashboardInfo.id !== this.props.dashboardInfo.id)\n    {\n      // this is in case there is an anonymous user.\n      this.props.fetchUISpecificReport(\n      user.userId,\n      'dashboard_id',\n      'dashboards',\n      nextProps.dashboardInfo.id,\n      user.email);\n\n    }\n  }\n\n  componentWillUnmount() {\n    stopPeriodicRender(this.refreshTimer);\n    this.props.setRefreshFrequency(0);\n    clearTimeout(this.ctrlYTimeout);\n    clearTimeout(this.ctrlZTimeout);\n  }\n\n  handleChangeText(nextText) {\n    const { updateDashboardTitle, onChange } = this.props;\n    if (nextText && this.props.dashboardTitle !== nextText) {\n      updateDashboardTitle(nextText);\n      onChange();\n    }\n  }\n\n  handleCtrlY() {\n    this.props.onRedo();\n    this.setState({ emphasizeRedo: true }, () => {\n      if (this.ctrlYTimeout) clearTimeout(this.ctrlYTimeout);\n      this.ctrlYTimeout = setTimeout(() => {\n        this.setState({ emphasizeRedo: false });\n      }, 100);\n    });\n  }\n\n  handleCtrlZ() {\n    this.props.onUndo();\n    this.setState({ emphasizeUndo: true }, () => {\n      if (this.ctrlZTimeout) clearTimeout(this.ctrlZTimeout);\n      this.ctrlZTimeout = setTimeout(() => {\n        this.setState({ emphasizeUndo: false });\n      }, 100);\n    });\n  }\n\n  forceRefresh() {\n    if (!this.props.isLoading) {\n      const chartList = Object.keys(this.props.charts);\n      this.props.logEvent(LOG_ACTIONS_FORCE_REFRESH_DASHBOARD, {\n        force: true,\n        interval: 0,\n        chartCount: chartList.length });\n\n      return this.props.onRefresh(\n      chartList,\n      true,\n      0,\n      this.props.dashboardInfo.id);\n\n    }\n    return false;\n  }\n\n  startPeriodicRender(interval) {\n    let intervalMessage;\n    if (interval) {\n      const predefinedValue = PeriodicRefreshOptions.find(\n      (option) => option.value === interval / 1000);\n\n      if (predefinedValue) {\n        intervalMessage = predefinedValue.label;\n      } else {\n        intervalMessage = moment.duration(interval, 'millisecond').humanize();\n      }\n    }\n\n    const periodicRender = () => {\n      const { fetchCharts, logEvent, charts, dashboardInfo } = this.props;\n      const { metadata } = dashboardInfo;\n      const immune = metadata.timed_refresh_immune_slices || [];\n      const affectedCharts = Object.values(charts).\n      filter((chart) => immune.indexOf(chart.id) === -1).\n      map((chart) => chart.id);\n\n      logEvent(LOG_ACTIONS_PERIODIC_RENDER_DASHBOARD, {\n        interval,\n        chartCount: affectedCharts.length });\n\n      this.props.addWarningToast(\n      t(\n      `This dashboard is currently force refreshing; the next force refresh will be in %s.`,\n      intervalMessage));\n\n\n\n      return fetchCharts(\n      affectedCharts,\n      true,\n      interval * 0.2,\n      dashboardInfo.id);\n\n    };\n\n    this.refreshTimer = setPeriodicRunner({\n      interval,\n      periodicRender,\n      refreshTimer: this.refreshTimer });\n\n  }\n\n  toggleEditMode() {\n    this.props.logEvent(LOG_ACTIONS_TOGGLE_EDIT_DASHBOARD, {\n      edit_mode: !this.props.editMode });\n\n    this.props.setEditMode(!this.props.editMode);\n  }\n\n  overwriteDashboard() {var _dashboardInfo$metada, _dashboardInfo$metada2, _dashboardInfo$metada3;\n    const {\n      dashboardTitle,\n      layout: positions,\n      colorScheme,\n      colorNamespace,\n      customCss,\n      dashboardInfo,\n      refreshFrequency: currentRefreshFrequency,\n      shouldPersistRefreshFrequency,\n      lastModifiedTime,\n      slug } =\n    this.props;\n\n    // check refresh frequency is for current session or persist\n    const refreshFrequency = shouldPersistRefreshFrequency ?\n    currentRefreshFrequency : (_dashboardInfo$metada =\n    dashboardInfo.metadata) == null ? void 0 : _dashboardInfo$metada.refresh_frequency;\n\n    const data = {\n      certified_by: dashboardInfo.certified_by,\n      certification_details: dashboardInfo.certification_details,\n      css: customCss,\n      dashboard_title: dashboardTitle,\n      last_modified_time: lastModifiedTime,\n      owners: dashboardInfo.owners,\n      roles: dashboardInfo.roles,\n      slug,\n      metadata: {\n        ...(dashboardInfo == null ? void 0 : dashboardInfo.metadata),\n        color_namespace:\n        (dashboardInfo == null ? void 0 : (_dashboardInfo$metada2 = dashboardInfo.metadata) == null ? void 0 : _dashboardInfo$metada2.color_namespace) || colorNamespace,\n        color_scheme: (dashboardInfo == null ? void 0 : (_dashboardInfo$metada3 = dashboardInfo.metadata) == null ? void 0 : _dashboardInfo$metada3.color_scheme) || colorScheme,\n        positions,\n        refresh_frequency: refreshFrequency } };\n\n\n\n    // make sure positions data less than DB storage limitation:\n    const positionJSONLength = safeStringify(positions).length;\n    const limit =\n    dashboardInfo.common.conf.SUPERSET_DASHBOARD_POSITION_DATA_LIMIT ||\n    DASHBOARD_POSITION_DATA_LIMIT;\n    if (positionJSONLength >= limit) {\n      this.props.addDangerToast(\n      t(\n      'Your dashboard is too large. Please reduce its size before saving it.'));\n\n\n    } else {\n      if (positionJSONLength >= limit * 0.9) {\n        this.props.addWarningToast('Your dashboard is near the size limit.');\n      }\n\n      this.props.onSave(data, dashboardInfo.id, SAVE_TYPE_OVERWRITE);\n    }\n  }\n\n  showPropertiesModal() {\n    this.setState({ showingPropertiesModal: true });\n  }\n\n  hidePropertiesModal() {\n    this.setState({ showingPropertiesModal: false });\n  }\n\n  showReportModal() {\n    this.setState({ showingReportModal: true });\n  }\n\n  hideReportModal() {\n    this.setState({ showingReportModal: false });\n  }\n\n  renderReportModal() {\n    const attachedReportExists = !!Object.keys(this.props.reports).length;\n    return attachedReportExists ?\n    ___EmotionJSX(HeaderReportActionsDropdown, {\n      showReportModal: this.showReportModal,\n      toggleActive: this.props.toggleActive,\n      deleteActiveReport: this.props.deleteActiveReport }) :\n\n\n    ___EmotionJSX(React.Fragment, null,\n    ___EmotionJSX(\"span\", {\n      role: \"button\",\n      title: t('Schedule email report'),\n      tabIndex: 0,\n      className: \"action-button\",\n      onClick: this.showReportModal },\n\n    ___EmotionJSX(Icons.Calendar, null)));\n\n\n\n  }\n\n  canAddReports() {\n    if (!isFeatureEnabled(FeatureFlag.ALERT_REPORTS)) {\n      return false;\n    }\n    const { user } = this.props;\n    if (!user) {\n      // this is in the case that there is an anonymous user.\n      return false;\n    }\n    const roles = Object.keys(user.roles || []);\n    const permissions = roles.map((key) =>\n    user.roles[key].filter(\n    (perms) => perms[0] === 'menu_access' && perms[1] === 'Manage'));\n\n\n    return permissions[0].length > 0;\n  }\n\n  render() {\n    const {\n      dashboardTitle,\n      layout,\n      expandedSlices,\n      customCss,\n      colorNamespace,\n      dataMask,\n      setColorSchemeAndUnsavedChanges,\n      colorScheme,\n      onUndo,\n      onRedo,\n      undoLength,\n      redoLength,\n      onChange,\n      onSave,\n      updateCss,\n      editMode,\n      isPublished,\n      user,\n      dashboardInfo,\n      hasUnsavedChanges,\n      isLoading,\n      refreshFrequency,\n      shouldPersistRefreshFrequency,\n      setRefreshFrequency,\n      lastModifiedTime } =\n    this.props;\n    const userCanEdit = dashboardInfo.dash_edit_perm;\n    const userCanShare = dashboardInfo.dash_share_perm;\n    const userCanSaveAs = dashboardInfo.dash_save_perm;\n    const shouldShowReport = !editMode && this.canAddReports();\n    const refreshLimit =\n    dashboardInfo.common.conf.SUPERSET_DASHBOARD_PERIODICAL_REFRESH_LIMIT;\n    const refreshWarning =\n    dashboardInfo.common.conf.\n    SUPERSET_DASHBOARD_PERIODICAL_REFRESH_WARNING_MESSAGE;\n\n    const handleOnPropertiesChange = (updates) => {\n      const { dashboardInfoChanged, dashboardTitleChanged } = this.props;\n      dashboardInfoChanged({\n        slug: updates.slug,\n        metadata: JSON.parse(updates.jsonMetadata || '{}'),\n        certified_by: updates.certifiedBy,\n        certification_details: updates.certificationDetails,\n        owners: updates.owners,\n        roles: updates.roles });\n\n      setColorSchemeAndUnsavedChanges(updates.colorScheme);\n      dashboardTitleChanged(updates.title);\n    };\n\n    return (\n      ___EmotionJSX(StyledDashboardHeader, {\n        className: \"dashboard-header\",\n\n        \"data-test-id\": `${dashboardInfo.id}` },\n\n      ___EmotionJSX(\"div\", { className: \"dashboard-component-header header-large\" },\n      dashboardInfo.certified_by &&\n      ___EmotionJSX(React.Fragment, null,\n      ___EmotionJSX(CertifiedIcon, {\n        certifiedBy: dashboardInfo.certified_by,\n        details: dashboardInfo.certification_details }),\n      ' '),\n\n\n      ___EmotionJSX(EditableTitle, {\n        title: dashboardTitle,\n        canEdit: userCanEdit && editMode,\n        onSaveTitle: this.handleChangeText,\n        showTooltip: false }),\n\n      ___EmotionJSX(PublishedStatus, {\n        dashboardId: dashboardInfo.id,\n        isPublished: isPublished,\n        savePublished: this.props.savePublished,\n        canEdit: userCanEdit,\n        canSave: userCanSaveAs }),\n\n      (user == null ? void 0 : user.userId) &&\n      ___EmotionJSX(FaveStar, {\n        itemId: dashboardInfo.id,\n        fetchFaveStar: this.props.fetchFaveStar,\n        saveFaveStar: this.props.saveFaveStar,\n        isStarred: this.props.isStarred,\n        showTooltip: true })),\n\n\n\n\n      ___EmotionJSX(\"div\", { className: \"button-container\" },\n      userCanSaveAs &&\n      ___EmotionJSX(\"div\", {\n        className: \"button-container\" },\n\n\n      editMode &&\n      ___EmotionJSX(React.Fragment, null,\n      ___EmotionJSX(ButtonGroup, { className: \"m-r-5\" },\n      ___EmotionJSX(Button, {\n        buttonSize: \"small\",\n        onClick: onUndo,\n        disabled: undoLength < 1,\n        buttonStyle:\n        this.state.emphasizeUndo ? 'primary' : undefined,\n\n        showMarginRight: false },\n\n      ___EmotionJSX(\"i\", {\n        title: \"Undo\",\n        className: \"undo-action fa fa-reply\" }), \"\\xA0\"),\n\n\n\n\n      ___EmotionJSX(Button, {\n        buttonSize: \"small\",\n        onClick: onRedo,\n        disabled: redoLength < 1,\n        buttonStyle:\n        this.state.emphasizeRedo ? 'primary' : undefined,\n\n        showMarginRight: false }, \"\\xA0\",\n\n\n      ___EmotionJSX(\"i\", { title: \"Redo\", className: \"redo-action fa fa-share\" }))),\n\n\n      ___EmotionJSX(Button, {\n        buttonSize: \"small\",\n        className: \"m-r-5\",\n        onClick: this.constructor.discardChanges,\n        buttonStyle: \"default\" },\n\n\n      t('Discard changes')),\n\n      ___EmotionJSX(Button, {\n        buttonSize: \"small\",\n        disabled: !hasUnsavedChanges,\n        buttonStyle: \"primary\",\n        onClick: this.overwriteDashboard },\n\n\n      t('Save')))),\n\n\n\n\n\n      editMode &&\n      ___EmotionJSX(UndoRedoKeyListeners, {\n        onUndo: this.handleCtrlZ,\n        onRedo: this.handleCtrlY }),\n\n\n\n      !editMode && userCanEdit &&\n      ___EmotionJSX(React.Fragment, null,\n      ___EmotionJSX(\"span\", {\n        role: \"button\",\n        title: t('Edit dashboard'),\n        tabIndex: 0,\n        className: \"action-button\",\n        onClick: this.toggleEditMode },\n\n      ___EmotionJSX(Icons.EditAlt, null))),\n\n\n\n      shouldShowReport && this.renderReportModal(),\n\n      ___EmotionJSX(PropertiesModal, {\n        dashboardId: dashboardInfo.id,\n        dashboardInfo: dashboardInfo,\n        dashboardTitle: dashboardTitle,\n        show: this.state.showingPropertiesModal,\n        onHide: this.hidePropertiesModal,\n        colorScheme: this.props.colorScheme,\n        onSubmit: handleOnPropertiesChange,\n        onlyApply: true }),\n\n\n      this.state.showingReportModal &&\n      ___EmotionJSX(ReportModal, {\n        show: this.state.showingReportModal,\n        onHide: this.hideReportModal,\n        props: {\n          userId: user.userId,\n          userEmail: user.email,\n          dashboardId: dashboardInfo.id,\n          creationMethod: 'dashboards' } }),\n\n\n\n\n      ___EmotionJSX(HeaderActionsDropdown, {\n        addSuccessToast: this.props.addSuccessToast,\n        addDangerToast: this.props.addDangerToast,\n        dashboardId: dashboardInfo.id,\n        dashboardTitle: dashboardTitle,\n        dashboardInfo: dashboardInfo,\n        dataMask: dataMask,\n        layout: layout,\n        expandedSlices: expandedSlices,\n        customCss: customCss,\n        colorNamespace: colorNamespace,\n        colorScheme: colorScheme,\n        onSave: onSave,\n        onChange: onChange,\n        forceRefreshAllCharts: this.forceRefresh,\n        startPeriodicRender: this.startPeriodicRender,\n        refreshFrequency: refreshFrequency,\n        shouldPersistRefreshFrequency: shouldPersistRefreshFrequency,\n        setRefreshFrequency: setRefreshFrequency,\n        updateCss: updateCss,\n        editMode: editMode,\n        hasUnsavedChanges: hasUnsavedChanges,\n        userCanEdit: userCanEdit,\n        userCanShare: userCanShare,\n        userCanSave: userCanSaveAs,\n        isLoading: isLoading,\n        showPropertiesModal: this.showPropertiesModal,\n        refreshLimit: refreshLimit,\n        refreshWarning: refreshWarning,\n        lastModifiedTime: lastModifiedTime }))));\n\n\n\n\n  }}\n\n\nHeader.propTypes = propTypes;\nHeader.defaultProps = defaultProps;\n\nexport default Header;","map":null,"metadata":{},"sourceType":"module"}