{"ast":null,"code":"import _isUndefined from \"lodash/isUndefined\";import _omitBy from \"lodash/omitBy\";import _isEqual from \"lodash/isEqual\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport shortid from 'shortid';\nimport { compose } from 'redux';\nimport persistState from 'redux-localstorage';\n\nexport function addToObject(state, arrKey, obj) {\n  const newObject = { ...state[arrKey] };\n  const copiedObject = { ...obj };\n  if (!copiedObject.id) {\n    copiedObject.id = shortid.generate();\n  }\n  newObject[copiedObject.id] = copiedObject;\n  return { ...state, [arrKey]: newObject };\n}\nexport function alterInObject(state, arrKey, obj, alterations) {\n  const newObject = { ...state[arrKey] };\n  newObject[obj.id] = { ...newObject[obj.id], ...alterations };\n  return { ...state, [arrKey]: newObject };\n}\nexport function alterInArr(state, arrKey, obj, alterations, idKey = 'id') {\n  // Finds an item in an array in the state and replaces it with a\n  // new object with an altered property\n  const newArr = [];\n  state[arrKey].forEach((arrItem) => {\n    if (obj[idKey] === arrItem[idKey]) {\n      newArr.push({ ...arrItem, ...alterations });\n    } else\n    {\n      newArr.push(arrItem);\n    }\n  });\n  return { ...state, [arrKey]: newArr };\n}\nexport function removeFromArr(state, arrKey, obj, idKey = 'id') {\n  const newArr = [];\n  state[arrKey].forEach((arrItem) => {\n    if (!(obj[idKey] === arrItem[idKey])) {\n      newArr.push(arrItem);\n    }\n  });\n  return { ...state, [arrKey]: newArr };\n}\nexport function getFromArr(arr, id) {\n  let obj;\n  arr.forEach((o) => {\n    if (o.id === id) {\n      obj = o;\n    }\n  });\n  return obj;\n}\nexport function addToArr(state, arrKey, obj, prepend = false) {\n  const newObj = { ...obj };\n  if (!newObj.id) {\n    newObj.id = shortid.generate();\n  }\n  const newState = {};\n  if (prepend) {\n    newState[arrKey] = [newObj, ...state[arrKey]];\n  } else\n  {\n    newState[arrKey] = [...state[arrKey], newObj];\n  }\n  return { ...state, ...newState };\n}\nexport function extendArr(state, arrKey, arr, prepend = false) {\n  const newArr = [...arr];\n  newArr.forEach((el) => {\n    if (!el.id) {\n      /* eslint-disable no-param-reassign */\n      el.id = shortid.generate();\n    }\n  });\n  const newState = {};\n  if (prepend) {\n    newState[arrKey] = [...newArr, ...state[arrKey]];\n  } else\n  {\n    newState[arrKey] = [...state[arrKey], ...newArr];\n  }\n  return { ...state, ...newState };\n}\nexport function initEnhancer(persist = true, persistConfig = {}) {\n  const { paths, config } = persistConfig;\n  const composeEnhancers = process.env.WEBPACK_MODE === 'development' ?\n  /* eslint-disable-next-line no-underscore-dangle, dot-notation */\n  window['__REDUX_DEVTOOLS_EXTENSION_COMPOSE__'] ?\n  /* eslint-disable-next-line no-underscore-dangle, dot-notation */\n  window['__REDUX_DEVTOOLS_EXTENSION_COMPOSE__']({\n    trace: true }) :\n\n  compose :\n  compose;\n  return persist ?\n  composeEnhancers(persistState(paths, config)) :\n  composeEnhancers();\n}\nexport function areArraysShallowEqual(arr1, arr2) {\n  // returns whether 2 arrays are shallow equal\n  // used in shouldComponentUpdate when denormalizing arrays\n  // where the array object is different every time, but the content might\n  // be the same\n  if (!arr1 || !arr2) {\n    return false;\n  }\n  if (arr1.length !== arr2.length) {\n    return false;\n  }\n  const { length } = arr1;\n  for (let i = 0; i < length; i += 1) {\n    if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nexport function areObjectsEqual(obj1, obj2, opts = { ignoreUndefined: false }) {\n  let comp1 = obj1;\n  let comp2 = obj2;\n  if (opts.ignoreUndefined) {\n    comp1 = _omitBy(obj1, _isUndefined);\n    comp2 = _omitBy(obj2, _isUndefined);\n  }\n  return _isEqual(comp1, comp2);\n}","map":null,"metadata":{},"sourceType":"module"}