{"ast":null,"code":"import _extends from \"@babel/runtime-corejs3/helpers/extends\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with work for additional information\n * regarding copyright ownership.  The ASF licenses file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport React, { useCallback, useEffect, useMemo, useState } from 'react';\nimport { FeatureFlag, isFeatureEnabled, logging, SupersetClient, t } from '@superset-ui/core';\nimport { OPERATOR_ENUM_TO_OPERATOR_TYPE, Operators } from 'src/explore/constants';\nimport AdhocFilterPopoverTrigger from 'src/explore/components/controls/FilterControl/AdhocFilterPopoverTrigger';\nimport OptionWrapper from 'src/explore/components/controls/DndColumnSelectControl/OptionWrapper';\nimport DndSelectLabel from 'src/explore/components/controls/DndColumnSelectControl/DndSelectLabel';\nimport AdhocFilter, { CLAUSES, EXPRESSION_TYPES } from 'src/explore/components/controls/FilterControl/AdhocFilter';\nimport AdhocMetric from 'src/explore/components/controls/MetricControl/AdhocMetric';\nimport { isSavedMetric } from 'src/explore/components/DatasourcePanel/types';\nimport { DndItemType } from 'src/explore/components/DndItemType';import { jsx as ___EmotionJSX } from \"@emotion/react\";\nconst EMPTY_OBJECT = {};\nconst DND_ACCEPTED_TYPES = [\nDndItemType.Column,\nDndItemType.Metric,\nDndItemType.MetricOption,\nDndItemType.AdhocMetricOption];\n\nconst isDictionaryForAdhocFilter = (value) => !(value instanceof AdhocFilter) && (value == null ? void 0 : value.expressionType);\nexport const DndFilterSelect = (props) => {var _props$value;\n  const { datasource, onChange = () => {}, name: controlName } = props;\n  const propsValues = Array.from((_props$value = props.value) != null ? _props$value : []);\n  const [values, setValues] = useState(propsValues.map((filter) => isDictionaryForAdhocFilter(filter) ? new AdhocFilter(filter) : filter));\n  const [partitionColumn, setPartitionColumn] = useState(undefined);\n  const [newFilterPopoverVisible, setNewFilterPopoverVisible] = useState(false);\n  const [droppedItem, setDroppedItem] = useState({});\n  const optionsForSelect = (columns, formData) => {\n    const options = [\n    ...columns,\n    ...[...((formData == null ? void 0 : formData.metrics) || []), formData == null ? void 0 : formData.metric].map((metric) => metric && (\n    typeof metric === 'string' ?\n    { saved_metric_name: metric } :\n    new AdhocMetric(metric)))].\n    filter((option) => option);\n    return options.\n    reduce((results, option) => {\n      if ('saved_metric_name' in option && option.saved_metric_name) {\n        results.push({\n          ...option,\n          filterOptionName: option.saved_metric_name });\n\n      } else\n      if ('column_name' in option && option.column_name) {\n        results.push({\n          ...option,\n          filterOptionName: `_col_${option.column_name}` });\n\n      } else\n      if (option instanceof AdhocMetric) {\n        results.push({\n          ...option,\n          filterOptionName: `_adhocmetric_${option.label}` });\n\n      }\n      return results;\n    }, []).\n    sort((a, b) => {var _localeCompare, _ref;return (_localeCompare = (_ref = a.saved_metric_name || a.column_name || a.label) == null ? void 0 : _ref.localeCompare(b.saved_metric_name || b.column_name || b.label || '')) != null ? _localeCompare : 0;});\n  };\n  const [options, setOptions] = useState(optionsForSelect(props.columns, props.formData));\n  useEffect(() => {\n    if (datasource && datasource.type === 'table') {var _datasource$database;\n      const dbId = (_datasource$database = datasource.database) == null ? void 0 : _datasource$database.id;\n      const { datasource_name: name, schema, is_sqllab_view: isSqllabView } = datasource;\n      if (!isSqllabView && dbId && name && schema) {\n        SupersetClient.get({\n          endpoint: `/superset/extra_table_metadata/${dbId}/${name}/${schema}/` }).\n\n        then(({ json }) => {\n          if (json && json.partitions) {\n            const { partitions } = json;\n            // for now only show latest_partition option\n            // when table datasource has only 1 partition key.\n            if (partitions &&\n            partitions.cols &&\n            Object.keys(partitions.cols).length === 1) {\n              setPartitionColumn(partitions.cols[0]);\n            }\n          }\n        }).\n        catch((error) => {\n          logging.error('fetch extra_table_metadata:', error.statusText);\n        });\n      }\n    }\n  }, [datasource]);\n  useEffect(() => {\n    setOptions(optionsForSelect(props.columns, props.formData));\n  }, [props.columns, props.formData]);\n  useEffect(() => {\n    setValues((props.value || []).map((filter) => isDictionaryForAdhocFilter(filter) ? new AdhocFilter(filter) : filter));\n  }, [props.value]);\n  const onClickClose = useCallback((index) => {\n    const valuesCopy = [...values];\n    valuesCopy.splice(index, 1);\n    setValues(valuesCopy);\n    onChange(valuesCopy);\n  }, [onChange, values]);\n  const onShiftOptions = useCallback((dragIndex, hoverIndex) => {\n    const newValues = [...values];\n    [newValues[hoverIndex], newValues[dragIndex]] = [\n    newValues[dragIndex],\n    newValues[hoverIndex]];\n\n    setValues(newValues);\n  }, [values]);\n  const getMetricExpression = useCallback((savedMetricName) => {var _props$savedMetrics$f;return (_props$savedMetrics$f = props.savedMetrics.find((savedMetric) => savedMetric.metric_name === savedMetricName)) == null ? void 0 : _props$savedMetrics$f.expression;}, [props.savedMetrics]);\n  const mapOption = useCallback((option) => {\n    // already a AdhocFilter, skip\n    if (option instanceof AdhocFilter) {\n      return option;\n    }\n    const filterOptions = option;\n    // via datasource saved metric\n    if (filterOptions.saved_metric_name) {\n      return new AdhocFilter({\n        expressionType: datasource.type === 'druid' ?\n        EXPRESSION_TYPES.SIMPLE :\n        EXPRESSION_TYPES.SQL,\n        subject: datasource.type === 'druid' ?\n        filterOptions.saved_metric_name :\n        getMetricExpression(filterOptions.saved_metric_name),\n        operator: OPERATOR_ENUM_TO_OPERATOR_TYPE[Operators.GREATER_THAN].operation,\n        operatorId: Operators.GREATER_THAN,\n        comparator: 0,\n        clause: CLAUSES.HAVING });\n\n    }\n    // has a custom label, meaning it's custom column\n    if (filterOptions.label) {\n      return new AdhocFilter({\n        expressionType: datasource.type === 'druid' ?\n        EXPRESSION_TYPES.SIMPLE :\n        EXPRESSION_TYPES.SQL,\n        subject: datasource.type === 'druid' ?\n        filterOptions.label :\n        new AdhocMetric(option).translateToSql(),\n        operator: OPERATOR_ENUM_TO_OPERATOR_TYPE[Operators.GREATER_THAN].operation,\n        operatorId: Operators.GREATER_THAN,\n        comparator: 0,\n        clause: CLAUSES.HAVING });\n\n    }\n    // add a new filter item\n    if (filterOptions.column_name) {\n      return new AdhocFilter({\n        expressionType: EXPRESSION_TYPES.SIMPLE,\n        subject: filterOptions.column_name,\n        operator: OPERATOR_ENUM_TO_OPERATOR_TYPE[Operators.EQUALS].operation,\n        operatorId: Operators.EQUALS,\n        comparator: '',\n        clause: CLAUSES.WHERE,\n        isNew: true });\n\n    }\n    return null;\n  }, [datasource.type, getMetricExpression]);\n  const onFilterEdit = useCallback((changedFilter) => {\n    onChange(values.map((value) => {\n      if (value.filterOptionName === changedFilter.filterOptionName) {\n        return changedFilter;\n      }\n      return value;\n    }));\n  }, [onChange, values]);\n  const onNewFilter = useCallback((newFilter) => {\n    const mappedOption = mapOption(newFilter);\n    if (mappedOption) {\n      const newValues = [...values, mappedOption];\n      setValues(newValues);\n      onChange(newValues);\n    }\n  }, [mapOption, onChange, values]);\n  const togglePopover = useCallback((visible) => {\n    setNewFilterPopoverVisible(visible);\n  }, []);\n  const closePopover = useCallback(() => {\n    togglePopover(false);\n  }, [togglePopover]);\n  const valuesRenderer = useCallback(() => values.map((adhocFilter, index) => {\n    const label = adhocFilter.getDefaultLabel();\n    const tooltipTitle = adhocFilter.getTooltipTitle();\n    return ___EmotionJSX(AdhocFilterPopoverTrigger, { key: index, adhocFilter: adhocFilter, options: options, datasource: datasource, onFilterEdit: onFilterEdit, partitionColumn: partitionColumn },\n    ___EmotionJSX(OptionWrapper, { key: index, index: index, label: label, tooltipTitle: tooltipTitle, clickClose: onClickClose, onShiftOptions: onShiftOptions, type: DndItemType.FilterOption, withCaret: true, isExtra: adhocFilter.isExtra }));\n\n  }), [\n  onClickClose,\n  onFilterEdit,\n  onShiftOptions,\n  options,\n  partitionColumn,\n  datasource,\n  values]);\n\n  const handleClickGhostButton = useCallback(() => {\n    setDroppedItem({});\n    togglePopover(true);\n  }, [togglePopover]);\n  const adhocFilter = useMemo(() => {\n    if (isSavedMetric(droppedItem)) {\n      return new AdhocFilter({\n        expressionType: EXPRESSION_TYPES.SQL,\n        clause: CLAUSES.HAVING,\n        sqlExpression: droppedItem == null ? void 0 : droppedItem.expression });\n\n    }\n    if (droppedItem instanceof AdhocMetric) {\n      return new AdhocFilter({\n        expressionType: EXPRESSION_TYPES.SQL,\n        clause: CLAUSES.HAVING,\n        sqlExpression: droppedItem == null ? void 0 : droppedItem.translateToSql() });\n\n    }\n    const config = {\n      subject: droppedItem == null ? void 0 : droppedItem.column_name };\n\n    if (config.subject && isFeatureEnabled(FeatureFlag.UX_BETA)) {\n      config.operator = OPERATOR_ENUM_TO_OPERATOR_TYPE[Operators.IN].operation;\n      config.operatorId = Operators.IN;\n    }\n    return new AdhocFilter(config);\n  }, [droppedItem]);\n  const canDrop = useCallback(() => true, []);\n  const handleDrop = useCallback((item) => {\n    setDroppedItem(item.value);\n    togglePopover(true);\n  }, [controlName, togglePopover]);\n  const ghostButtonText = isFeatureEnabled(FeatureFlag.ENABLE_DND_WITH_CLICK_UX) ?\n  t('Drop columns/metrics here or click') :\n  t('Drop columns or metrics here');\n  return ___EmotionJSX(React.Fragment, null,\n  ___EmotionJSX(DndSelectLabel, _extends({ onDrop: handleDrop, canDrop: canDrop, valuesRenderer: valuesRenderer, accept: DND_ACCEPTED_TYPES, ghostButtonText: ghostButtonText, onClickGhostButton: isFeatureEnabled(FeatureFlag.ENABLE_DND_WITH_CLICK_UX) ?\n    handleClickGhostButton :\n    undefined }, props)),\n  ___EmotionJSX(AdhocFilterPopoverTrigger, { adhocFilter: adhocFilter, options: options, datasource: datasource, onFilterEdit: onNewFilter, partitionColumn: partitionColumn, isControlledComponent: true, visible: newFilterPopoverVisible, togglePopover: togglePopover, closePopover: closePopover },\n  ___EmotionJSX(\"div\", null)));\n\n\n};","map":null,"metadata":{},"sourceType":"module"}