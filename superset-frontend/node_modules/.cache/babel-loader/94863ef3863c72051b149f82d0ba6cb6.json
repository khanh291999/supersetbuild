{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport React, { useCallback, useEffect, useState } from 'react';\nimport { styled, css, t, useTheme } from '@superset-ui/core';\nimport Icons from 'src/components/Icons';\nimport ControlHeader from 'src/explore/components/ControlHeader';\nimport { useComponentDidUpdate } from 'src/common/hooks/useComponentDidUpdate';\nimport { FormattingPopover } from './FormattingPopover';\nimport { COMPARATOR } from './types';\nimport { AddControlLabel, CaretContainer, Label, OptionControlContainer } from '../OptionControls';import { jsx as ___EmotionJSX } from \"@emotion/react\";\nconst FormattersContainer = styled.div`\n  ${({ theme }) => css`\n    padding: ${theme.gridUnit}px;\n    border: solid 1px ${theme.colors.grayscale.light2};\n    border-radius: ${theme.gridUnit}px;\n  `}\n`;\nexport const FormatterContainer = styled(OptionControlContainer)`\n  &,\n  & > div {\n    margin-bottom: ${({ theme }) => theme.gridUnit}px;\n    :last-child {\n      margin-bottom: 0;\n    }\n  }\n`;\nexport const CloseButton = styled.button`\n  ${({ theme }) => css`\n    color: ${theme.colors.grayscale.light1};\n    height: 100%;\n    width: ${theme.gridUnit * 6}px;\n    border: none;\n    border-right: solid 1px ${theme.colors.grayscale.dark2}0C;\n    padding: 0;\n    outline: none;\n    border-bottom-left-radius: 3px;\n    border-top-left-radius: 3px;\n  `}\n`;\nconst ConditionalFormattingControl = ({ value, onChange, columnOptions, verboseMap, ...props }) => {\n  const theme = useTheme();\n  const [conditionalFormattingConfigs, setConditionalFormattingConfigs] = useState(value != null ? value : []);\n  useEffect(() => {\n    if (onChange) {\n      onChange(conditionalFormattingConfigs);\n    }\n  }, [conditionalFormattingConfigs, onChange]);\n  // remove formatter when corresponding column is removed from controls\n  const removeFormattersWhenColumnsChange = useCallback(() => {\n    const newFormattingConfigs = conditionalFormattingConfigs.filter((config) => columnOptions.some((option) => (option == null ? void 0 : option.value) === (config == null ? void 0 : config.column)));\n    if (newFormattingConfigs.length !== conditionalFormattingConfigs.length &&\n    onChange) {\n      setConditionalFormattingConfigs(newFormattingConfigs);\n      onChange(newFormattingConfigs);\n    }\n  }, [JSON.stringify(columnOptions)]);\n  useComponentDidUpdate(removeFormattersWhenColumnsChange);\n  const onDelete = (index) => {\n    setConditionalFormattingConfigs((prevConfigs) => prevConfigs.filter((_, i) => i !== index));\n  };\n  const onSave = (config) => {\n    setConditionalFormattingConfigs((prevConfigs) => [...prevConfigs, config]);\n  };\n  const onEdit = (newConfig, index) => {\n    const newConfigs = [...conditionalFormattingConfigs];\n    newConfigs.splice(index, 1, newConfig);\n    setConditionalFormattingConfigs(newConfigs);\n  };\n  const createLabel = ({ column, operator, targetValue, targetValueLeft, targetValueRight }) => {var _ref;\n    const columnName = (_ref = column && (verboseMap == null ? void 0 : verboseMap[column])) != null ? _ref : column;\n    switch (operator) {\n      case COMPARATOR.NONE:\n        return `${columnName}`;\n      case COMPARATOR.BETWEEN:\n        return `${targetValueLeft} ${COMPARATOR.LESS_THAN} ${columnName} ${COMPARATOR.LESS_THAN} ${targetValueRight}`;\n      case COMPARATOR.BETWEEN_OR_EQUAL:\n        return `${targetValueLeft} ${COMPARATOR.LESS_OR_EQUAL} ${columnName} ${COMPARATOR.LESS_OR_EQUAL} ${targetValueRight}`;\n      case COMPARATOR.BETWEEN_OR_LEFT_EQUAL:\n        return `${targetValueLeft} ${COMPARATOR.LESS_OR_EQUAL} ${columnName} ${COMPARATOR.LESS_THAN} ${targetValueRight}`;\n      case COMPARATOR.BETWEEN_OR_RIGHT_EQUAL:\n        return `${targetValueLeft} ${COMPARATOR.LESS_THAN} ${columnName} ${COMPARATOR.LESS_OR_EQUAL} ${targetValueRight}`;\n      default:\n        return `${columnName} ${operator} ${targetValue}`;}\n\n  };\n  return ___EmotionJSX(\"div\", null,\n  ___EmotionJSX(ControlHeader, props),\n  ___EmotionJSX(FormattersContainer, null,\n  conditionalFormattingConfigs.map((config, index) => ___EmotionJSX(FormatterContainer, { key: index },\n  ___EmotionJSX(CloseButton, { onClick: () => onDelete(index) },\n  ___EmotionJSX(Icons.XSmall, { iconColor: theme.colors.grayscale.light1 })),\n\n  ___EmotionJSX(FormattingPopover, { title: t('Edit formatter'), config: config, columns: columnOptions, onChange: (newConfig) => onEdit(newConfig, index), destroyTooltipOnHide: true },\n  ___EmotionJSX(OptionControlContainer, { withCaret: true },\n  ___EmotionJSX(Label, null, createLabel(config)),\n  ___EmotionJSX(CaretContainer, null,\n  ___EmotionJSX(Icons.CaretRight, { iconColor: theme.colors.grayscale.light1 })))))),\n\n\n\n\n  ___EmotionJSX(FormattingPopover, { title: t('Add new formatter'), columns: columnOptions, onChange: onSave, destroyTooltipOnHide: true },\n  ___EmotionJSX(AddControlLabel, null,\n  ___EmotionJSX(Icons.PlusSmall, { iconColor: theme.colors.grayscale.light1 }),\n  t('Add new color formatter')))));\n\n\n\n\n};\nexport default ConditionalFormattingControl;","map":null,"metadata":{},"sourceType":"module"}