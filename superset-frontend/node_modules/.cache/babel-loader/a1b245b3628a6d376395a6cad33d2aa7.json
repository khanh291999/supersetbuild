{"ast":null,"code":"import _extends from \"@babel/runtime-corejs3/helpers/extends\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { ensureIsArray, t, tn } from '@superset-ui/core';\nimport React, { useEffect, useState } from 'react';\nimport { Select } from 'src/components';\nimport { FilterPluginStyle, StyledFormItem, StatusMessage } from '../common';import { jsx as ___EmotionJSX } from \"@emotion/react\";\nexport default function PluginFilterGroupBy(props) {var _formData$groupby, _formData$groupby$, _formData$groupby2;\n  const { data, formData, height, width, setDataMask, setFocusedFilter, unsetFocusedFilter, filterState } = props;\n  const { defaultValue, inputRef, multiSelect } = formData;\n  const [value, setValue] = useState(defaultValue != null ? defaultValue : []);\n  const handleChange = (value) => {\n    const resultValue = ensureIsArray(value);\n    setValue(resultValue);\n    const extraFormData = {};\n    if (resultValue.length) {\n      extraFormData.interactive_groupby = resultValue;\n    }\n    setDataMask({\n      filterState: { value: resultValue.length ? resultValue : null },\n      extraFormData });\n\n  };\n  useEffect(() => {\n    handleChange(filterState.value);\n  }, [JSON.stringify(filterState.value), multiSelect]);\n  useEffect(() => {\n    handleChange(defaultValue != null ? defaultValue : null);\n    // I think after Config Modal update some filter it re-creates default value for all other filters\n    // so we can process it like this `JSON.stringify` or start to use `Immer`\n  }, [JSON.stringify(defaultValue), multiSelect]);\n  const groupby = formData != null && (_formData$groupby = formData.groupby) != null && (_formData$groupby$ = _formData$groupby[0]) != null && _formData$groupby$.length ?\n  formData == null ? void 0 : (_formData$groupby2 = formData.groupby) == null ? void 0 : _formData$groupby2[0] :\n  null;\n  const withData = groupby ?\n  data.filter((dataItem) =>\n  // @ts-ignore\n  groupby.includes(dataItem.column_name)) :\n  data;\n  const columns = data ? withData : [];\n  const placeholderText = columns.length === 0 ?\n  t('No columns') :\n  tn('%s option', '%s options', columns.length, columns.length);\n  const formItemData = {};\n  if (filterState.validateMessage) {\n    formItemData.extra = ___EmotionJSX(StatusMessage, { status: filterState.validateStatus },\n    filterState.validateMessage);\n\n  }\n  const options = columns.map((row) => {\n    const { column_name: columnName, verbose_name: verboseName } = row;\n    return {\n      label: verboseName != null ? verboseName : columnName,\n      value: columnName };\n\n  });\n  return ___EmotionJSX(FilterPluginStyle, { height: height, width: width },\n  ___EmotionJSX(StyledFormItem, _extends({ validateStatus: filterState.validateStatus }, formItemData),\n  ___EmotionJSX(Select, { allowClear: true, value: value, placeholder: placeholderText, mode: multiSelect ? 'multiple' : undefined\n    // @ts-ignore\n    , onChange: handleChange, onBlur: unsetFocusedFilter, onFocus: setFocusedFilter, ref: inputRef, options: options })));\n\n\n}","map":null,"metadata":{},"sourceType":"module"}