{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport { bindActionCreators } from 'redux';\nimport { connect } from 'react-redux';\nimport { SupersetClient } from '@superset-ui/core';\nimport * as Actions from 'src/SqlLab/actions/sqlLab';\n\nconst QUERY_UPDATE_FREQ = 2000;\nconst QUERY_UPDATE_BUFFER_MS = 5000;\nconst MAX_QUERY_AGE_TO_POLL = 21600000;\nconst QUERY_TIMEOUT_LIMIT = 10000;\n\nclass QueryAutoRefresh extends React.PureComponent {\n  constructor(props) {\n    super(props);\n    this.state = {\n      offline: props.offline };\n\n  }\n\n  UNSAFE_componentWillMount() {\n    this.startTimer();\n  }\n\n  componentDidUpdate(prevProps) {\n    if (prevProps.offline !== this.state.offline) {\n      this.props.actions.setUserOffline(this.state.offline);\n    }\n  }\n\n  componentWillUnmount() {\n    this.stopTimer();\n  }\n\n  shouldCheckForQueries() {\n    // if there are started or running queries, this method should return true\n    const { queries } = this.props;\n    const now = new Date().getTime();\n    const isQueryRunning = (q) =>\n    ['running', 'started', 'pending', 'fetching'].indexOf(q.state) >= 0;\n\n    return Object.values(queries).some(\n    (q) => isQueryRunning(q) && now - q.startDttm < MAX_QUERY_AGE_TO_POLL);\n\n  }\n\n  startTimer() {\n    if (!this.timer) {\n      this.timer = setInterval(this.stopwatch.bind(this), QUERY_UPDATE_FREQ);\n    }\n  }\n\n  stopTimer() {\n    clearInterval(this.timer);\n    this.timer = null;\n  }\n\n  stopwatch() {\n    // only poll /superset/queries/ if there are started or running queries\n    if (this.shouldCheckForQueries()) {\n      SupersetClient.get({\n        endpoint: `/superset/queries/${\n        this.props.queriesLastUpdate - QUERY_UPDATE_BUFFER_MS\n        }`,\n        timeout: QUERY_TIMEOUT_LIMIT }).\n\n      then(({ json }) => {\n        if (Object.keys(json).length > 0) {\n          this.props.actions.refreshQueries(json);\n        }\n        this.setState({ offline: false });\n      }).\n      catch(() => {\n        this.setState({ offline: true });\n      });\n    } else {\n      this.setState({ offline: false });\n    }\n  }\n\n  render() {\n    return null;\n  }}\n\nQueryAutoRefresh.propTypes = {\n  offline: PropTypes.bool.isRequired,\n  queries: PropTypes.object.isRequired,\n  actions: PropTypes.object.isRequired,\n  queriesLastUpdate: PropTypes.number.isRequired };\n\n\nfunction mapStateToProps({ sqlLab }) {\n  return {\n    offline: sqlLab.offline,\n    queries: sqlLab.queries,\n    queriesLastUpdate: sqlLab.queriesLastUpdate };\n\n}\n\nfunction mapDispatchToProps(dispatch) {\n  return {\n    actions: bindActionCreators(Actions, dispatch) };\n\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(QueryAutoRefresh);","map":null,"metadata":{},"sourceType":"module"}