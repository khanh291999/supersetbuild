{"ast":null,"code":"import _omitBy from \"lodash/omitBy\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport React, { useContext, useEffect, useReducer } from 'react';\nimport { defineSharedModules, getChartMetadataRegistry, logging, makeApi } from '@superset-ui/core';\nimport { FeatureFlag, isFeatureEnabled } from 'src/featureFlags';import { jsx as ___EmotionJSX } from \"@emotion/react\";\n\nconst metadataRegistry = getChartMetadataRegistry();\nconst dummyPluginContext = {\n  loading: true,\n  dynamicPlugins: {},\n  keys: [],\n  mountedPluginMetadata: {},\n  fetchAll: () => {} };\n\n/**\n * It is highly recommended to use the usePluginContext hook instead.\n * @see usePluginContext\n */\nexport const PluginContext = /*#__PURE__*/React.createContext(dummyPluginContext);\n/**\n * The plugin context provides info about what dynamic plugins are available.\n * It also provides loading info for the plugins' javascript bundles.\n *\n * Note: This does not include any information about static plugins.\n * Those are compiled into the Superset bundle at build time.\n * Dynamic plugins are added by the end user and can be any webhosted javascript.\n */\nexport const usePluginContext = () => useContext(PluginContext);\nfunction getRegistryData() {\n  return {\n    keys: metadataRegistry.keys(),\n    mountedPluginMetadata: _omitBy(metadataRegistry.getMap(), (value) => value === undefined) // cast required to get rid of undefined values\n  };\n}\nfunction pluginContextReducer(state, action) {\n  switch (action.type) {\n    case 'begin':{\n        const plugins = { ...state.dynamicPlugins };\n        action.keys.forEach((key) => {\n          plugins[key] = { key, error: null, mounting: true };\n        });\n        return {\n          ...state,\n          loading: action.keys.length > 0,\n          dynamicPlugins: plugins };\n\n      }\n    case 'complete':{\n        return {\n          ...state,\n          loading: Object.values(state.dynamicPlugins).some((plugin) => plugin.mounting && plugin.key !== action.key),\n          dynamicPlugins: {\n            ...state.dynamicPlugins,\n            [action.key]: {\n              key: action.key,\n              mounting: false,\n              error: action.error } } };\n\n\n\n      }\n    case 'changed keys':{\n        return {\n          ...state,\n          ...getRegistryData() };\n\n      }\n    default:\n      return state;}\n\n}\nconst pluginApi = makeApi({\n  method: 'GET',\n  endpoint: '/dynamic-plugins/api/read' });\n\nconst sharedModules = {\n  react: () => import('react'),\n  lodash: () => import('lodash'),\n  'react-dom': () => import('react-dom'),\n  '@superset-ui/chart-controls': () => import('@superset-ui/chart-controls'),\n  '@superset-ui/core': () => import('@superset-ui/core') };\n\nexport const DynamicPluginProvider = ({ children }) => {\n  const [pluginState, dispatch] = useReducer(pluginContextReducer, dummyPluginContext, (state) => ({\n    ...state,\n    ...getRegistryData(),\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    fetchAll,\n    loading: isFeatureEnabled(FeatureFlag.DYNAMIC_PLUGINS)\n    // TODO: Write fetchByKeys\n  }));\n  // For now, we fetch all the plugins at the same time.\n  // In the future it would be nice to fetch on an as-needed basis.\n  // That will most likely depend on having a json manifest for each plugin.\n  async function fetchAll() {\n    try {\n      await defineSharedModules(sharedModules);\n      const { result: plugins } = await pluginApi({});\n      dispatch({ type: 'begin', keys: plugins.map((plugin) => plugin.key) });\n      await Promise.all(plugins.map(async (plugin) => {\n        let error = null;\n        try {\n          await import( /* webpackIgnore: true */plugin.bundle_url);\n        }\n        catch (err) {\n          logging.error(`Failed to load plugin ${plugin.key} with the following error:`, err.stack);\n          error = err;\n        }\n        dispatch({\n          type: 'complete',\n          key: plugin.key,\n          error });\n\n      }));\n    }\n    catch (error) {\n      logging.error('Failed to load dynamic plugins', error.stack || error);\n    }\n  }\n  useEffect(() => {\n    if (isFeatureEnabled(FeatureFlag.DYNAMIC_PLUGINS)) {\n      fetchAll();\n    }\n    const registryListener = () => {\n      dispatch({ type: 'changed keys' });\n    };\n    metadataRegistry.addListener(registryListener);\n    return () => {\n      metadataRegistry.removeListener(registryListener);\n    };\n  }, []);\n  return ___EmotionJSX(PluginContext.Provider, { value: pluginState },\n  children);\n\n};","map":null,"metadata":{},"sourceType":"module"}