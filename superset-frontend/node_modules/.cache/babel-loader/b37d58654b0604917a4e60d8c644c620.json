{"ast":null,"code":"import _debounce from \"lodash/debounce\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport React from 'react';\nimport ButtonGroup from 'src/components/ButtonGroup';\nimport Alert from 'src/components/Alert';\nimport ProgressBar from 'src/components/ProgressBar';\nimport moment from 'moment';\nimport Button from 'src/components/Button';\nimport shortid from 'shortid';\nimport rison from 'rison';\nimport { styled, t, makeApi, SupersetClient } from '@superset-ui/core';\n\nimport ErrorMessageWithStackTrace from 'src/components/ErrorMessage/ErrorMessageWithStackTrace';\nimport { SaveDatasetModal } from 'src/SqlLab/components/SaveDatasetModal';\nimport Loading from 'src/components/Loading';\nimport FilterableTable from 'src/components/FilterableTable/FilterableTable';\nimport CopyToClipboard from 'src/components/CopyToClipboard';\nimport { prepareCopyToClipboardTabularData } from 'src/utils/common';\nimport { exploreChart } from 'src/explore/exploreUtils';\nimport { CtasEnum } from 'src/SqlLab/actions/sqlLab';\nimport ExploreCtasResultsButton from '../ExploreCtasResultsButton';\nimport ExploreResultsButton from '../ExploreResultsButton';\nimport HighlightedSql from '../HighlightedSql';\nimport QueryStateLabel from '../QueryStateLabel';import { jsx as ___EmotionJSX } from \"@emotion/react\";\nvar DatasetRadioState;\n(function (DatasetRadioState) {\n  DatasetRadioState[DatasetRadioState[\"SAVE_NEW\"] = 1] = \"SAVE_NEW\";\n  DatasetRadioState[DatasetRadioState[\"OVERWRITE_DATASET\"] = 2] = \"OVERWRITE_DATASET\";\n})(DatasetRadioState || (DatasetRadioState = {}));\nconst EXPLORE_CHART_DEFAULT = {\n  metrics: [],\n  groupby: [],\n  time_range: 'No filter',\n  viz_type: 'table' };\n\nvar LIMITING_FACTOR;\n(function (LIMITING_FACTOR) {\n  LIMITING_FACTOR[\"QUERY\"] = \"QUERY\";\n  LIMITING_FACTOR[\"QUERY_AND_DROPDOWN\"] = \"QUERY_AND_DROPDOWN\";\n  LIMITING_FACTOR[\"DROPDOWN\"] = \"DROPDOWN\";\n  LIMITING_FACTOR[\"NOT_LIMITED\"] = \"NOT_LIMITED\";\n})(LIMITING_FACTOR || (LIMITING_FACTOR = {}));\nconst LOADING_STYLES = { position: 'relative', minHeight: 100 };\n// Making text render line breaks/tabs as is as monospace,\n// but wrapping text too so text doesn't overflow\nconst MonospaceDiv = styled.div`\n  font-family: ${({ theme }) => theme.typography.families.monospace};\n  white-space: pre;\n  word-break: break-word;\n  overflow-x: auto;\n  white-space: pre-wrap;\n`;\nconst ReturnedRows = styled.div`\n  font-size: 13px;\n  line-height: 24px;\n  .limitMessage {\n    color: ${({ theme }) => theme.colors.secondary.light1};\n    margin-left: ${({ theme }) => theme.gridUnit * 2}px;\n  }\n`;\nconst ResultSetControls = styled.div`\n  display: flex;\n  justify-content: space-between;\n  padding: ${({ theme }) => 2 * theme.gridUnit}px 0;\n`;\nconst ResultSetButtons = styled.div`\n  display: grid;\n  grid-auto-flow: column;\n  padding-right: ${({ theme }) => 2 * theme.gridUnit}px;\n`;\nconst ResultSetErrorMessage = styled.div`\n  padding-top: ${({ theme }) => 4 * theme.gridUnit}px;\n`;\nconst updateDataset = async (datasetId, sql, columns, owners, overrideColumns) => {\n  const endpoint = `api/v1/dataset/${datasetId}?override_columns=${overrideColumns}`;\n  const headers = { 'Content-Type': 'application/json' };\n  const body = JSON.stringify({\n    sql,\n    columns,\n    owners });\n\n  const data = await SupersetClient.put({\n    endpoint,\n    headers,\n    body });\n\n  return data.json.result;\n};\nexport default class ResultSet extends React.PureComponent {\n\n\n\n\n\n\n\n\n  constructor(props) {\n    super(props);this.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    calculateAlertRefHeight = (alertElement) => {\n      if (alertElement) {\n        this.setState({ alertIsOpen: true });\n      } else\n      {\n        this.setState({ alertIsOpen: false });\n      }\n    };this.\n    getDefaultDatasetName = () => `${this.props.query.tab} ${moment().format('MM/DD/YYYY HH:mm:ss')}`;this.\n    handleOnChangeAutoComplete = () => {\n      this.setState({ datasetToOverwrite: {} });\n    };this.\n    handleOverwriteDataset = async () => {\n      const { sql, results } = this.props.query;\n      const { datasetToOverwrite } = this.state;\n      await updateDataset(datasetToOverwrite.datasetId, sql, results.selected_columns.map((d) => ({ column_name: d.name })), datasetToOverwrite.owners.map((o) => o.id), true);\n      this.setState({\n        showSaveDatasetModal: false,\n        shouldOverwriteDataSet: false,\n        datasetToOverwrite: {},\n        newSaveDatasetName: this.getDefaultDatasetName() });\n\n      exploreChart({\n        ...EXPLORE_CHART_DEFAULT,\n        datasource: `${datasetToOverwrite.datasetId}__table`,\n        all_columns: results.selected_columns.map((d) => d.name) });\n\n    };this.\n    handleSaveInDataset = () => {var _this$props$query, _this$props$query$res;\n      // if user wants to overwrite a dataset we need to prompt them\n      if (this.state.saveDatasetRadioBtnState ===\n      DatasetRadioState.OVERWRITE_DATASET) {\n        this.setState({ shouldOverwriteDataSet: true });\n        return;\n      }\n      const { schema, sql, dbId } = this.props.query;\n      let { templateParams } = this.props.query;\n      const selectedColumns = ((_this$props$query = this.props.query) == null ? void 0 : (_this$props$query$res = _this$props$query.results) == null ? void 0 : _this$props$query$res.selected_columns) || [];\n      // The filters param is only used to test jinja templates.\n      // Remove the special filters entry from the templateParams\n      // before saving the dataset.\n      if (templateParams) {\n        const p = JSON.parse(templateParams);\n        /* eslint-disable-next-line no-underscore-dangle */\n        if (p._filters) {\n          /* eslint-disable-next-line no-underscore-dangle */\n          delete p._filters;\n          templateParams = JSON.stringify(p);\n        }\n      }\n      this.props.actions.\n      createDatasource({\n        schema,\n        sql,\n        dbId,\n        templateParams,\n        datasourceName: this.state.newSaveDatasetName,\n        columns: selectedColumns }).\n\n      then((data) => {\n        exploreChart({\n          datasource: `${data.table_id}__table`,\n          metrics: [],\n          groupby: [],\n          time_range: 'No filter',\n          viz_type: 'table',\n          all_columns: selectedColumns.map((c) => c.name),\n          row_limit: 1000 });\n\n      }).\n      catch(() => {\n        this.props.actions.addDangerToast(t('An error occurred saving dataset'));\n      });\n      this.setState({\n        showSaveDatasetModal: false,\n        newSaveDatasetName: this.getDefaultDatasetName() });\n\n    };this.\n    handleOverwriteDatasetOption = (_data, option) => {\n      this.setState({ datasetToOverwrite: option });\n    };this.\n    handleDatasetNameChange = (e) => {\n      // @ts-expect-error\n      this.setState({ newSaveDatasetName: e.target.value });\n    };this.\n    handleHideSaveModal = () => {\n      this.setState({\n        showSaveDatasetModal: false,\n        shouldOverwriteDataSet: false });\n\n    };this.\n    handleSaveDatasetRadioBtnState = (e) => {\n      this.setState({ saveDatasetRadioBtnState: Number(e.target.value) });\n    };this.\n    handleOverwriteCancel = () => {\n      this.setState({ shouldOverwriteDataSet: false, datasetToOverwrite: {} });\n    };this.\n    handleExploreBtnClick = () => {\n      this.setState({\n        showSaveDatasetModal: true });\n\n    };this.\n    getUserDatasets = async (searchText = '') => {\n      // Making sure that autocomplete input has a value before rendering the dropdown\n      // Transforming the userDatasetsOwned data for SaveModalComponent)\n      const { userId } = this.props.user;\n      if (userId) {\n        const queryParams = rison.encode({\n          filters: [\n          {\n            col: 'table_name',\n            opr: 'ct',\n            value: searchText },\n\n          {\n            col: 'owners',\n            opr: 'rel_m_m',\n            value: userId }],\n\n\n          order_column: 'changed_on_delta_humanized',\n          order_direction: 'desc' });\n\n        const response = await makeApi({\n          method: 'GET',\n          endpoint: '/api/v1/dataset' })(\n        `q=${queryParams}`);\n        return response.result.map((r) => ({\n          value: r.table_name,\n          datasetId: r.id,\n          owners: r.owners }));\n\n      }\n      return null;\n    };this.\n    handleSaveDatasetModalSearch = async (searchText) => {\n      const userDatasetsOwned = await this.getUserDatasets(searchText);\n      this.setState({ userDatasetOptions: userDatasetsOwned });\n    };this.\n    handleFilterAutocompleteOption = (inputValue, option) => option.value.toLowerCase().includes(inputValue.toLowerCase());this.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    onAlertClose = () => {\n      this.setState({ alertIsOpen: false });\n    };this.state = { searchText: '', showExploreResultsButton: false, data: [], showSaveDatasetModal: false, newSaveDatasetName: this.getDefaultDatasetName(), saveDatasetRadioBtnState: DatasetRadioState.SAVE_NEW, shouldOverwriteDataSet: false, datasetToOverwrite: {}, saveModalAutocompleteValue: '', userDatasetOptions: [], alertIsOpen: false };this.changeSearch = this.changeSearch.bind(this);this.fetchResults = this.fetchResults.bind(this);this.popSelectStar = this.popSelectStar.bind(this);this.reFetchQueryResults = this.reFetchQueryResults.bind(this);this.toggleExploreResultsButton = this.toggleExploreResultsButton.bind(this);this.handleSaveInDataset = this.handleSaveInDataset.bind(this);this.handleHideSaveModal = this.handleHideSaveModal.bind(this);this.handleDatasetNameChange = this.handleDatasetNameChange.bind(this);this.handleSaveDatasetRadioBtnState = this.handleSaveDatasetRadioBtnState.bind(this);this.handleOverwriteCancel = this.handleOverwriteCancel.bind(this);this.handleOverwriteDataset = this.handleOverwriteDataset.bind(this);this.handleOverwriteDatasetOption = this.handleOverwriteDatasetOption.bind(this);this.handleSaveDatasetModalSearch = _debounce(this.handleSaveDatasetModalSearch.bind(this), 1000);this.handleFilterAutocompleteOption = this.handleFilterAutocompleteOption.bind(this);this.handleOnChangeAutoComplete = this.handleOnChangeAutoComplete.bind(this);this.handleExploreBtnClick = this.handleExploreBtnClick.bind(this);}async componentDidMount() {// only do this the first time the component is rendered/mounted\n    this.reRunQueryIfSessionTimeoutErrorOnMount();const userDatasetsOwned = await this.getUserDatasets();this.setState({ userDatasetOptions: userDatasetsOwned });}UNSAFE_componentWillReceiveProps(nextProps) {// when new results comes in, save them locally and clear in store\n    if (this.props.cache && !nextProps.query.cached && nextProps.query.results && nextProps.query.results.data && nextProps.query.results.data.length > 0) {this.setState({ data: nextProps.query.results.data }, () => this.clearQueryResults(nextProps.query));}if (nextProps.query.resultsKey && nextProps.query.resultsKey !== this.props.query.resultsKey) {this.fetchResults(nextProps.query);}}clearQueryResults(query) {this.props.actions.clearQueryResults(query);}popSelectStar(tempSchema, tempTable) {const qe = { id: shortid.generate(), title: tempTable, autorun: false, dbId: this.props.query.dbId, sql: `SELECT * FROM ${tempSchema ? `${tempSchema}.` : ''}${tempTable}` };this.props.actions.addQueryEditor(qe);}toggleExploreResultsButton() {this.setState((prevState) => ({ showExploreResultsButton: !prevState.showExploreResultsButton }));}changeSearch(event) {this.setState({ searchText: event.target.value });}fetchResults(query) {this.props.actions.fetchQueryResults(query, this.props.displayLimit);}reFetchQueryResults(query) {this.props.actions.reFetchQueryResults(query);}reRunQueryIfSessionTimeoutErrorOnMount() {const { query } = this.props;if (query.errorMessage && query.errorMessage.indexOf('session timed out') > 0) {this.props.actions.reRunQuery(query);}}renderControls() {if (this.props.search || this.props.visualize || this.props.csv) {let { data } = this.props.query.results;if (this.props.cache && this.props.query.cached) {({ data } = this.state);}const { columns } = this.props.query.results; // Added compute logic to stop user from being able to Save & Explore\n      const { saveDatasetRadioBtnState, newSaveDatasetName, datasetToOverwrite, saveModalAutocompleteValue, shouldOverwriteDataSet, userDatasetOptions, showSaveDatasetModal } = this.state;const disableSaveAndExploreBtn = saveDatasetRadioBtnState === DatasetRadioState.SAVE_NEW && newSaveDatasetName.length === 0 || saveDatasetRadioBtnState === DatasetRadioState.OVERWRITE_DATASET && Object.keys(datasetToOverwrite).length === 0 && saveModalAutocompleteValue.length === 0;return ___EmotionJSX(ResultSetControls, null, ___EmotionJSX(SaveDatasetModal, { visible: showSaveDatasetModal, onOk: this.handleSaveInDataset, saveDatasetRadioBtnState: saveDatasetRadioBtnState, shouldOverwriteDataset: shouldOverwriteDataSet, defaultCreateDatasetValue: newSaveDatasetName, userDatasetOptions: userDatasetOptions, disableSaveAndExploreBtn: disableSaveAndExploreBtn, onHide: this.handleHideSaveModal, handleDatasetNameChange: this.handleDatasetNameChange, handleSaveDatasetRadioBtnState: this.handleSaveDatasetRadioBtnState, handleOverwriteCancel: this.handleOverwriteCancel, handleOverwriteDataset: this.handleOverwriteDataset, handleOverwriteDatasetOption: this.handleOverwriteDatasetOption, handleSaveDatasetModalSearch: this.handleSaveDatasetModalSearch, filterAutocompleteOption: this.handleFilterAutocompleteOption, onChangeAutoComplete: this.handleOnChangeAutoComplete }), ___EmotionJSX(ResultSetButtons, null, this.props.visualize && this.props.database && this.props.database.allows_virtual_table_explore && ___EmotionJSX(ExploreResultsButton // @ts-ignore Redux types are difficult to work with, ignoring for now\n      , { query: this.props.query, database: this.props.database, actions: this.props.actions, onClick: this.handleExploreBtnClick }), this.props.csv && ___EmotionJSX(Button, { buttonSize: \"small\", href: `/superset/csv/${this.props.query.id}` }, ___EmotionJSX(\"i\", { className: \"fa fa-file-text-o\" }), \" \", t('Download to CSV')), ___EmotionJSX(CopyToClipboard, { text: prepareCopyToClipboardTabularData(data, columns), wrapped: false, copyNode: ___EmotionJSX(Button, { buttonSize: \"small\" }, ___EmotionJSX(\"i\", { className: \"fa fa-clipboard\" }), \" \", t('Copy to Clipboard')) })), this.props.search && ___EmotionJSX(\"input\", { type: \"text\", onChange: this.changeSearch, value: this.state.searchText, className: \"form-control input-sm\", placeholder: t('Filter results') }));}return ___EmotionJSX(\"div\", null);}renderRowsReturned() {var _this$props$user, _this$props$user$role;const { results, rows, queryLimit, limitingFactor } = this.props.query;let limitMessage;const limitReached = results == null ? void 0 : results.displayLimitReached;\n    const limit = queryLimit || results.query.limit;\n    const isAdmin = !!((_this$props$user = this.props.user) != null && (_this$props$user$role = _this$props$user.roles) != null && _this$props$user$role.Admin);\n    const displayMaxRowsReachedMessage = {\n      withAdmin: t(`The number of results displayed is limited to %(rows)d by the configuration DISPLAY_MAX_ROWS. `, { rows }).concat(t(`Please add additional limits/filters or download to csv to see more rows up to `), t(`the %(limit)d limit.`, { limit })),\n      withoutAdmin: t(`The number of results displayed is limited to %(rows)d. `, { rows }).concat(t(`Please add additional limits/filters, download to csv, or contact an admin `), t(`to see more rows up to the %(limit)d limit.`, {\n        limit })) };\n\n\n    const shouldUseDefaultDropdownAlert = limit === this.props.defaultQueryLimit &&\n    limitingFactor === LIMITING_FACTOR.DROPDOWN;\n    if (limitingFactor === LIMITING_FACTOR.QUERY && this.props.csv) {\n      limitMessage = ___EmotionJSX(\"span\", { className: \"limitMessage\" },\n      t(`The number of rows displayed is limited to %(rows)d by the query`, { rows }));\n\n    } else\n    if (limitingFactor === LIMITING_FACTOR.DROPDOWN &&\n    !shouldUseDefaultDropdownAlert) {\n      limitMessage = ___EmotionJSX(\"span\", { className: \"limitMessage\" },\n      t(`The number of rows displayed is limited to %(rows)d by the limit dropdown.`, { rows }));\n\n    } else\n    if (limitingFactor === LIMITING_FACTOR.QUERY_AND_DROPDOWN) {\n      limitMessage = ___EmotionJSX(\"span\", { className: \"limitMessage\" },\n      t(`The number of rows displayed is limited to %(rows)d by the query and limit dropdown.`, { rows }));\n\n    }\n    return ___EmotionJSX(ReturnedRows, null,\n    !limitReached && !shouldUseDefaultDropdownAlert && ___EmotionJSX(\"span\", null,\n    t(`%(rows)d rows returned`, { rows }), \" \", limitMessage),\n\n    !limitReached && shouldUseDefaultDropdownAlert && ___EmotionJSX(\"div\", { ref: this.calculateAlertRefHeight },\n    ___EmotionJSX(Alert, { type: \"warning\", message: t(`%(rows)d rows returned`, { rows }), onClose: this.onAlertClose, description: t(`The number of rows displayed is limited to %s by the dropdown.`, rows) })),\n\n    limitReached && ___EmotionJSX(\"div\", { ref: this.calculateAlertRefHeight },\n    ___EmotionJSX(Alert, { type: \"warning\", onClose: this.onAlertClose, message: t(`%(rows)d rows returned`, { rows }), description: isAdmin ?\n      displayMaxRowsReachedMessage.withAdmin :\n      displayMaxRowsReachedMessage.withoutAdmin })));\n\n\n  }\n  render() {\n    const { query } = this.props;\n    let sql;\n    let exploreDBId = query.dbId;\n    if (this.props.database && this.props.database.explore_database_id) {\n      exploreDBId = this.props.database.explore_database_id;\n    }\n    if (this.props.showSql) {\n      sql = ___EmotionJSX(HighlightedSql, { sql: query.sql });\n    }\n    if (query.state === 'stopped') {\n      return ___EmotionJSX(Alert, { type: \"warning\", message: t('Query was stopped') });\n    }\n    if (query.state === 'failed') {var _query$errors;\n      return ___EmotionJSX(ResultSetErrorMessage, null,\n      ___EmotionJSX(ErrorMessageWithStackTrace, { title: t('Database error'), error: query == null ? void 0 : (_query$errors = query.errors) == null ? void 0 : _query$errors[0], subtitle: ___EmotionJSX(MonospaceDiv, null, query.errorMessage), copyText: query.errorMessage || undefined, link: query.link, source: \"sqllab\" }));\n\n    }\n    if (query.state === 'success' && query.ctas) {\n      const { tempSchema, tempTable } = query;\n      let object = 'Table';\n      if (query.ctas_method === CtasEnum.VIEW) {\n        object = 'View';\n      }\n      return ___EmotionJSX(\"div\", null,\n      ___EmotionJSX(Alert, { type: \"info\", message: ___EmotionJSX(React.Fragment, null,\n        t(object), \" [\",\n        ___EmotionJSX(\"strong\", null,\n        tempSchema ? `${tempSchema}.` : '',\n        tempTable), \"] \",\n\n        t('was created'), \" \\xA0\",\n        ___EmotionJSX(ButtonGroup, null,\n        ___EmotionJSX(Button, { buttonSize: \"small\", className: \"m-r-5\", onClick: () => this.popSelectStar(tempSchema, tempTable) },\n        t('Query in a new tab')),\n\n        ___EmotionJSX(ExploreCtasResultsButton\n        // @ts-ignore Redux types are difficult to work with, ignoring for now\n        , { table: tempTable, schema: tempSchema, dbId: exploreDBId, database: this.props.database, actions: this.props.actions }))) }));\n\n\n\n    }\n    if (query.state === 'success' && query.results) {\n      const { results } = query;\n      const height = this.state.alertIsOpen ?\n      this.props.height - 70 :\n      this.props.height;\n      let data;\n      if (this.props.cache && query.cached) {\n        ({ data } = this.state);\n      } else\n      if (results && results.data) {\n        ({ data } = results);\n      }\n      if (data && data.length > 0) {\n        const expandedColumns = results.expanded_columns ?\n        results.expanded_columns.map((col) => col.name) :\n        [];\n        return ___EmotionJSX(React.Fragment, null,\n        this.renderControls(),\n        this.renderRowsReturned(),\n        sql,\n        ___EmotionJSX(FilterableTable, { data: data, orderedColumnKeys: results.columns.map((col) => col.name), height: height, filterText: this.state.searchText, expandedColumns: expandedColumns }));\n\n      }\n      if (data && data.length === 0) {\n        return ___EmotionJSX(Alert, { type: \"warning\", message: t('The query returned no data') });\n      }\n    }\n    if (query.cached || query.state === 'success' && !query.results) {\n      if (query.isDataPreview) {\n        return ___EmotionJSX(Button, { buttonSize: \"small\", buttonStyle: \"primary\", onClick: () => this.reFetchQueryResults({\n            ...query,\n            isDataPreview: true }) },\n\n        t('Fetch data preview'));\n\n      }\n      if (query.resultsKey) {\n        return ___EmotionJSX(Button, { buttonSize: \"small\", buttonStyle: \"primary\", onClick: () => this.fetchResults(query) },\n        t('Refetch results'));\n\n      }\n    }\n    let progressBar;\n    let trackingUrl;\n    if (query.progress > 0) {\n      progressBar = ___EmotionJSX(ProgressBar, { percent: parseInt(query.progress.toFixed(0), 10), striped: true });\n    }\n    if (query.trackingUrl) {\n      trackingUrl = ___EmotionJSX(Button, { buttonSize: \"small\", onClick: () => query.trackingUrl && window.open(query.trackingUrl) },\n      t('Track job'));\n\n    }\n    const progressMsg = query && query.extra && query.extra.progress ?\n    query.extra.progress :\n    null;\n    return ___EmotionJSX(\"div\", { style: LOADING_STYLES },\n    ___EmotionJSX(\"div\", null, !progressBar && ___EmotionJSX(Loading, { position: \"normal\" })),\n    ___EmotionJSX(QueryStateLabel, { query: query }),\n    ___EmotionJSX(\"div\", null,\n    progressMsg && ___EmotionJSX(Alert, { type: \"success\", message: progressMsg })),\n\n    ___EmotionJSX(\"div\", null, progressBar),\n    ___EmotionJSX(\"div\", null, trackingUrl));\n\n  }}ResultSet.defaultProps = { cache: false, csv: true, database: {}, search: true, showSql: false, visualize: true };","map":null,"metadata":{},"sourceType":"module"}