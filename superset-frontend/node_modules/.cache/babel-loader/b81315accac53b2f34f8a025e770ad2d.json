{"ast":null,"code":"import _extends from \"@babel/runtime-corejs3/helpers/extends\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint camelcase: 0 */\nimport React from 'react';\nimport { bindActionCreators } from 'redux';\nimport { connect } from 'react-redux';\nimport { ensureIsArray, t, styled, getChartControlPanelRegistry, DatasourceType, css } from '@superset-ui/core';\nimport { InfoTooltipWithTrigger, sections } from '@superset-ui/chart-controls';\nimport Collapse from 'src/components/Collapse';\nimport Tabs from 'src/components/Tabs';\nimport { PluginContext } from 'src/components/DynamicPlugins';\nimport Loading from 'src/components/Loading';\nimport { getSectionsToRender } from 'src/explore/controlUtils';\nimport { exploreActions } from 'src/explore/actions/exploreActions';\nimport ControlRow from './ControlRow';\nimport Control from './Control';import { jsx as ___EmotionJSX } from \"@emotion/react\";\nconst Styles = styled.div`\n  height: 100%;\n  width: 100%;\n  overflow: auto;\n  overflow-x: visible;\n  overflow-y: auto;\n  #controlSections {\n    min-height: 100%;\n    overflow: visible;\n  }\n  .nav-tabs {\n    flex: 0 0 1;\n  }\n  .tab-content {\n    overflow: auto;\n    flex: 1 1 100%;\n  }\n  .Select__menu {\n    max-width: 100%;\n  }\n  .type-label {\n    margin-right: ${({ theme }) => theme.gridUnit * 3}px;\n    width: ${({ theme }) => theme.gridUnit * 7}px;\n    display: inline-block;\n    text-align: center;\n    font-weight: ${({ theme }) => theme.typography.weights.bold};\n  }\n`;\nconst ControlPanelsTabs = styled(Tabs)`\n  .ant-tabs-nav-list {\n    width: ${({ fullWidth }) => fullWidth ? '100%' : '50%'};\n  }\n  .ant-tabs-content-holder {\n    overflow: visible;\n  }\n  .ant-tabs-tabpane {\n    height: 100%;\n  }\n`;\nconst isTimeSection = (section) => !!section.label && (\nsections.legacyRegularTime.label === section.label ||\nsections.legacyTimeseriesTime.label === section.label);\nconst hasTimeColumn = (datasource) => {var _datasource$columns;return (datasource == null ? void 0 : (_datasource$columns = datasource.columns) == null ? void 0 : _datasource$columns.some((c) => c.is_dttm)) ||\n  datasource.type === DatasourceType.Druid;};\nconst sectionsToExpand = (sections, datasource) =>\n// avoid expanding time section if datasource doesn't include time column\nsections.reduce((acc, section) => section.expanded && (!isTimeSection(section) || hasTimeColumn(datasource)) ?\n[...acc, String(section.label)] :\nacc, []);\nfunction getState(props) {\n  const { exploreState: { datasource } } = props;\n  const querySections = [];\n  const customizeSections = [];\n  getSectionsToRender(props.form_data.viz_type, props.datasource_type).forEach((section) => {\n    // if at least one control in the section is not `renderTrigger`\n    // or asks to be displayed at the Data tab\n    if (section.tabOverride === 'data' ||\n    section.controlSetRows.some((rows) => rows.some((control) => control &&\n    typeof control === 'object' &&\n    'config' in control &&\n    control.config && (\n    !control.config.renderTrigger ||\n    control.config.tabOverride === 'data')))) {\n      querySections.push(section);\n    } else\n    {\n      customizeSections.push(section);\n    }\n  });\n  const expandedQuerySections = sectionsToExpand(querySections, datasource);\n  const expandedCustomizeSections = sectionsToExpand(customizeSections, datasource);\n  return {\n    expandedQuerySections,\n    expandedCustomizeSections,\n    querySections,\n    customizeSections,\n    loading: false };\n\n}\nexport class ControlPanelsContainer extends React.Component {\n  // trigger updates to the component when async plugins load\n\n  constructor(props) {\n    super(props);\n    this.state = {\n      expandedQuerySections: [],\n      expandedCustomizeSections: [],\n      querySections: [],\n      customizeSections: [],\n      loading: false };\n\n    this.renderControl = this.renderControl.bind(this);\n    this.renderControlPanelSection = this.renderControlPanelSection.bind(this);\n  }\n  componentDidUpdate(prevProps) {\n    if (this.props.form_data.datasource !== prevProps.form_data.datasource ||\n    this.props.form_data.viz_type !== prevProps.form_data.viz_type) {\n      // eslint-disable-next-line react/no-did-update-set-state\n      this.setState(getState(this.props));\n    }\n  }\n  // required for an Antd bug that would otherwise malfunction re-rendering\n  // a collapsed panel after changing the datasource or viz type\n  UNSAFE_componentWillReceiveProps(nextProps) {\n    if (this.props.form_data.datasource !== nextProps.form_data.datasource ||\n    this.props.form_data.viz_type !== nextProps.form_data.viz_type) {\n      this.setState({ loading: true });\n    }\n  }\n  componentDidMount() {\n    this.setState(getState(this.props));\n  }\n  renderControl({ name, config }) {var _config$mapStateToPro;\n    const { actions, controls, chart, exploreState } = this.props;\n    const { visibility } = config;\n    // If the control item is not an object, we have to look up the control data from\n    // the centralized controls file.\n    // When it is an object we read control data straight from `config` instead\n    const controlData = {\n      ...config,\n      ...controls[name],\n      // if `mapStateToProps` accept three arguments, it means it needs chart\n      // state, too. Since it's may be expensive to run mapStateToProps for every\n      // re-render, we only run this when the chart plugin explicitly ask for this.\n      ...(((_config$mapStateToPro = config.mapStateToProps) == null ? void 0 : _config$mapStateToPro.length) === 3 ?\n      // @ts-ignore /* The typing accuses of having an extra parameter. I didn't remove it because I believe it could be an error in the types and not in the code */\n      config.mapStateToProps(exploreState, controls[name], chart) :\n      // for other controls, `mapStateToProps` is already run in\n      // controlUtils/getControlState.ts\n      undefined),\n      name };\n\n    const { validationErrors, ...restProps } = controlData;\n    // if visibility check says the config is not visible, don't render it\n    if (visibility && !visibility.call(config, this.props, controlData)) {\n      return null;\n    }\n    return ___EmotionJSX(Control, _extends({ key: `control-${name}`, name: name, validationErrors: validationErrors, actions: actions }, restProps));\n  }\n  renderControlPanelSection(section) {\n    const { controls } = this.props;\n    const { label, description } = section;\n    // Section label can be a ReactNode but in some places we want to\n    // have a string ID. Using forced type conversion for now,\n    // should probably add a `id` field to sections in the future.\n    const sectionId = String(label);\n    const hasErrors = section.controlSetRows.some((rows) => rows.some((item) => {\n      const controlName = typeof item === 'string' ?\n      item :\n      item && 'name' in item ?\n      item.name :\n      null;\n      return controlName &&\n      controlName in controls &&\n      controls[controlName].validationErrors &&\n      controls[controlName].validationErrors.length > 0;\n    }));\n    const PanelHeader = () => ___EmotionJSX(\"span\", null,\n    ___EmotionJSX(\"span\", null, label), ' ',\n    description &&\n    // label is only used in tooltip id (should probably call this prop `id`)\n    ___EmotionJSX(InfoTooltipWithTrigger, { label: sectionId, tooltip: description }),\n    hasErrors && ___EmotionJSX(InfoTooltipWithTrigger, { label: \"validation-errors\", bsStyle: \"danger\", tooltip: \"This section contains validation errors\" }));\n\n    return ___EmotionJSX(Collapse.Panel, { css: (theme) => css`\n          margin-bottom: 0;\n          box-shadow: none;\n\n          &:last-child {\n            padding-bottom: ${theme.gridUnit * 10}px;\n          }\n\n          .panel-body {\n            margin-left: ${theme.gridUnit * 4}px;\n            padding-bottom: 0px;\n          }\n\n          span.label {\n            display: inline-block;\n          }\n        `, header: PanelHeader(), key: sectionId },\n    section.controlSetRows.map((controlSets, i) => {\n      const renderedControls = controlSets.\n      map((controlItem) => {\n        if (!controlItem) {\n          // When the item is invalid\n          return null;\n        }\n        if ( /*#__PURE__*/React.isValidElement(controlItem)) {\n          // When the item is a React element\n          return controlItem;\n        }\n        if (controlItem.name &&\n        controlItem.config &&\n        controlItem.name !== 'datasource') {\n          return this.renderControl(controlItem);\n        }\n        return null;\n      }).\n      filter((x) => x !== null);\n      // don't show the row if it is empty\n      if (renderedControls.length === 0) {\n        return null;\n      }\n      return ___EmotionJSX(ControlRow, { key: `controlsetrow-${i}`, controls: renderedControls });\n    }));\n\n  }\n  render() {\n    const controlPanelRegistry = getChartControlPanelRegistry();\n    if (!controlPanelRegistry.has(this.props.form_data.viz_type) &&\n    this.context.loading ||\n    this.state.loading) {\n      return ___EmotionJSX(Loading, null);\n    }\n    const showCustomizeTab = this.state.customizeSections.length > 0;\n    return ___EmotionJSX(Styles, null,\n    ___EmotionJSX(ControlPanelsTabs, { id: \"controlSections\", fullWidth: showCustomizeTab },\n    ___EmotionJSX(Tabs.TabPane, { key: \"query\", tab: t('Data') },\n    ___EmotionJSX(Collapse, { bordered: true, activeKey: this.state.expandedQuerySections, expandIconPosition: \"right\", onChange: (selection) => {\n        this.setState({\n          expandedQuerySections: ensureIsArray(selection) });\n\n      }, ghost: true },\n    this.state.querySections.map(this.renderControlPanelSection))),\n\n\n    showCustomizeTab && ___EmotionJSX(Tabs.TabPane, { key: \"display\", tab: t('Customize') },\n    ___EmotionJSX(Collapse, { bordered: true, activeKey: this.state.expandedCustomizeSections, expandIconPosition: \"right\", onChange: (selection) => {\n        this.setState({\n          expandedCustomizeSections: ensureIsArray(selection) });\n\n      }, ghost: true },\n    this.state.customizeSections.map(this.renderControlPanelSection)))));\n\n\n\n\n  }}ControlPanelsContainer.contextType = PluginContext;\n\nexport default connect(function mapStateToProps(state) {\n  const { explore, charts } = state;\n  const chartKey = Object.keys(charts)[0];\n  const chart = charts[chartKey];\n  return {\n    chart,\n    isDatasourceMetaLoading: explore.isDatasourceMetaLoading,\n    controls: explore.controls,\n    exploreState: explore };\n\n}, function mapDispatchToProps(dispatch) {\n  return {\n    actions: bindActionCreators(exploreActions, dispatch) };\n\n})(ControlPanelsContainer);","map":null,"metadata":{},"sourceType":"module"}