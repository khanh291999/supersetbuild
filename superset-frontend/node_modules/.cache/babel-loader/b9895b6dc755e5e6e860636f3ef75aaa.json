{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n// ParentSize uses resize observer so the dashboard will update size\n// when its container size changes, due to e.g., builder side panel opening\nimport React, { useEffect, useState } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { FeatureFlag, isFeatureEnabled } from '@superset-ui/core';\nimport { ParentSize } from '@vx/responsive';\nimport Tabs from 'src/components/Tabs';\nimport DashboardGrid from 'src/dashboard/containers/DashboardGrid';\nimport getLeafComponentIdFromPath from 'src/dashboard/util/getLeafComponentIdFromPath';\nimport { DASHBOARD_GRID_ID, DASHBOARD_ROOT_DEPTH } from 'src/dashboard/util/constants';\nimport { getRootLevelTabIndex, getRootLevelTabsComponent } from './utils';\nimport { getChartIdsInFilterScope } from '../../util/activeDashboardFilters';\nimport findTabIndexByComponentId from '../../util/findTabIndexByComponentId';\nimport { findTabsWithChartsInScope } from '../nativeFilters/utils';\nimport { setInScopeStatusOfFilters } from '../../actions/nativeFilters';import { jsx as ___EmotionJSX } from \"@emotion/react\";\nconst DashboardContainer = ({ topLevelTabs }) => {var _useSelector;\n  const dashboardLayout = useSelector((state) => state.dashboardLayout.present);\n  const nativeFilters = (_useSelector = useSelector((state) => {var _state$nativeFilters;return (_state$nativeFilters = state.nativeFilters) == null ? void 0 : _state$nativeFilters.filters;})) != null ? _useSelector :\n  {};\n  const directPathToChild = useSelector((state) => state.dashboardState.directPathToChild);\n  const [tabIndex, setTabIndex] = useState(getRootLevelTabIndex(dashboardLayout, directPathToChild));\n  const dispatch = useDispatch();\n  useEffect(() => {\n    const nextTabIndex = findTabIndexByComponentId({\n      currentComponent: getRootLevelTabsComponent(dashboardLayout),\n      directPathToChild });\n\n    if (nextTabIndex > -1) {\n      setTabIndex(nextTabIndex);\n    }\n  }, [getLeafComponentIdFromPath(directPathToChild)]);\n  // recalculate charts and tabs in scopes of native filters only when a scope or dashboard layout changes\n  const filterScopes = Object.values(nativeFilters).map((filter) => ({\n    id: filter.id,\n    scope: filter.scope }));\n\n  useEffect(() => {\n    if (!isFeatureEnabled(FeatureFlag.DASHBOARD_NATIVE_FILTERS) ||\n    filterScopes.length === 0) {\n      return;\n    }\n    const scopes = filterScopes.map((filterScope) => {\n      const { scope } = filterScope;\n      const chartsInScope = getChartIdsInFilterScope({\n        filterScope: {\n          scope: scope.rootPath,\n          // @ts-ignore\n          immune: scope.excluded } });\n\n\n      const tabsInScope = findTabsWithChartsInScope(dashboardLayout, chartsInScope);\n      return {\n        filterId: filterScope.id,\n        tabsInScope: Array.from(tabsInScope),\n        chartsInScope };\n\n    });\n    dispatch(setInScopeStatusOfFilters(scopes));\n  }, [JSON.stringify(filterScopes), dashboardLayout, dispatch]);\n  const childIds = topLevelTabs ?\n  topLevelTabs.children :\n  [DASHBOARD_GRID_ID];\n  const min = Math.min(tabIndex, childIds.length - 1);\n  const activeKey = min === 0 ? DASHBOARD_GRID_ID : min.toString();\n  return ___EmotionJSX(\"div\", { className: \"grid-container\" },\n  ___EmotionJSX(ParentSize, null,\n  ({ width }) =>\n  /*\n    We use a TabContainer irrespective of whether top-level tabs exist to maintain\n    a consistent React component tree. This avoids expensive mounts/unmounts of\n    the entire dashboard upon adding/removing top-level tabs, which would otherwise\n    happen because of React's diffing algorithm\n  */\n  ___EmotionJSX(Tabs, { id: DASHBOARD_GRID_ID, activeKey: activeKey, renderTabBar: () => ___EmotionJSX(React.Fragment, null), fullWidth: false, animated: false, allowOverflow: true },\n  childIds.map((id, index) =>\n  // Matching the key of the first TabPane irrespective of topLevelTabs\n  // lets us keep the same React component tree when !!topLevelTabs changes.\n  // This avoids expensive mounts/unmounts of the entire dashboard.\n  ___EmotionJSX(Tabs.TabPane, { key: index === 0 ? DASHBOARD_GRID_ID : index.toString() },\n  ___EmotionJSX(DashboardGrid, { gridComponent: dashboardLayout[id]\n    // see isValidChild for why tabs do not increment the depth of their children\n    , depth: DASHBOARD_ROOT_DEPTH + 1 // (topLevelTabs ? 0 : 1)}\n    , width: width, isComponentVisible: index === tabIndex }))))));\n\n\n\n\n};\nexport default DashboardContainer;","map":null,"metadata":{},"sourceType":"module"}