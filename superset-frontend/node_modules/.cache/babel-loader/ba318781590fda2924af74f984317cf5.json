{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport { Resizable } from 're-resizable';\nimport cx from 'classnames';\n\nimport ResizableHandle from './ResizableHandle';\nimport resizableConfig from '../../util/resizableConfig';\nimport { GRID_BASE_UNIT, GRID_GUTTER_SIZE } from '../../util/constants';import { jsx as ___EmotionJSX } from \"@emotion/react\";\n\nconst proxyToInfinity = Number.MAX_VALUE;\n\nconst propTypes = {\n  id: PropTypes.string.isRequired,\n  children: PropTypes.node,\n  adjustableWidth: PropTypes.bool,\n  adjustableHeight: PropTypes.bool,\n  gutterWidth: PropTypes.number,\n  widthStep: PropTypes.number,\n  heightStep: PropTypes.number,\n  widthMultiple: PropTypes.number,\n  heightMultiple: PropTypes.number,\n  minWidthMultiple: PropTypes.number,\n  maxWidthMultiple: PropTypes.number,\n  minHeightMultiple: PropTypes.number,\n  maxHeightMultiple: PropTypes.number,\n  staticHeight: PropTypes.number,\n  staticHeightMultiple: PropTypes.number,\n  staticWidth: PropTypes.number,\n  staticWidthMultiple: PropTypes.number,\n  onResizeStop: PropTypes.func,\n  onResize: PropTypes.func,\n  onResizeStart: PropTypes.func,\n  editMode: PropTypes.bool.isRequired };\n\n\nconst defaultProps = {\n  children: null,\n  adjustableWidth: true,\n  adjustableHeight: true,\n  gutterWidth: GRID_GUTTER_SIZE,\n  widthStep: GRID_BASE_UNIT,\n  heightStep: GRID_BASE_UNIT,\n  widthMultiple: null,\n  heightMultiple: null,\n  minWidthMultiple: 1,\n  maxWidthMultiple: proxyToInfinity,\n  minHeightMultiple: 1,\n  maxHeightMultiple: proxyToInfinity,\n  staticHeight: null,\n  staticHeightMultiple: null,\n  staticWidth: null,\n  staticWidthMultiple: null,\n  onResizeStop: null,\n  onResize: null,\n  onResizeStart: null };\n\n\n// because columns are not multiples of a single variable (width = n*cols + (n-1) * gutters)\n// we snap to the base unit and then snap to _actual_ column multiples on stop\nconst SNAP_TO_GRID = [GRID_BASE_UNIT, GRID_BASE_UNIT];\nconst HANDLE_CLASSES = {\n  right: 'resizable-container-handle--right',\n  bottom: 'resizable-container-handle--bottom' };\n\nclass ResizableContainer extends React.PureComponent {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      isResizing: false };\n\n\n    this.handleResizeStart = this.handleResizeStart.bind(this);\n    this.handleResize = this.handleResize.bind(this);\n    this.handleResizeStop = this.handleResizeStop.bind(this);\n  }\n\n  handleResizeStart(event, direction, ref) {\n    const { id, onResizeStart } = this.props;\n\n    if (onResizeStart) {\n      onResizeStart({ id, direction, ref });\n    }\n\n    this.setState(() => ({ isResizing: true }));\n  }\n\n  handleResize(event, direction, ref) {\n    const { onResize, id } = this.props;\n    if (onResize) {\n      onResize({ id, direction, ref });\n    }\n  }\n\n  handleResizeStop(event, direction, ref, delta) {\n    const {\n      id,\n      onResizeStop,\n      widthStep,\n      heightStep,\n      widthMultiple,\n      heightMultiple,\n      adjustableHeight,\n      adjustableWidth,\n      gutterWidth } =\n    this.props;\n\n    if (onResizeStop) {\n      const nextWidthMultiple =\n      widthMultiple + Math.round(delta.width / (widthStep + gutterWidth));\n      const nextHeightMultiple =\n      heightMultiple + Math.round(delta.height / heightStep);\n\n      onResizeStop({\n        id,\n        widthMultiple: adjustableWidth ? nextWidthMultiple : null,\n        heightMultiple: adjustableHeight ? nextHeightMultiple : null });\n\n\n      this.setState(() => ({ isResizing: false }));\n    }\n  }\n\n  render() {\n    const {\n      children,\n      adjustableWidth,\n      adjustableHeight,\n      widthStep,\n      heightStep,\n      widthMultiple,\n      heightMultiple,\n      staticHeight,\n      staticHeightMultiple,\n      staticWidth,\n      staticWidthMultiple,\n      minWidthMultiple,\n      maxWidthMultiple,\n      minHeightMultiple,\n      maxHeightMultiple,\n      gutterWidth,\n      editMode } =\n    this.props;\n\n    const size = {\n      width: adjustableWidth ?\n      (widthStep + gutterWidth) * widthMultiple - gutterWidth :\n      staticWidthMultiple && staticWidthMultiple * widthStep ||\n      staticWidth ||\n      undefined,\n      height: adjustableHeight ?\n      heightStep * heightMultiple :\n      staticHeightMultiple && staticHeightMultiple * heightStep ||\n      staticHeight ||\n      undefined };\n\n\n    let enableConfig = resizableConfig.notAdjustable;\n\n    if (editMode && adjustableWidth && adjustableHeight) {\n      enableConfig = resizableConfig.widthAndHeight;\n    } else if (editMode && adjustableWidth) {\n      enableConfig = resizableConfig.widthOnly;\n    } else if (editMode && adjustableHeight) {\n      enableConfig = resizableConfig.heightOnly;\n    }\n\n    const { isResizing } = this.state;\n\n    return (\n      ___EmotionJSX(Resizable, {\n        enable: enableConfig,\n        grid: SNAP_TO_GRID,\n        minWidth:\n        adjustableWidth ?\n        minWidthMultiple * (widthStep + gutterWidth) - gutterWidth :\n        undefined,\n\n        minHeight:\n        adjustableHeight ? minHeightMultiple * heightStep : undefined,\n\n        maxWidth:\n        adjustableWidth ?\n        Math.max(\n        size.width,\n        Math.min(\n        proxyToInfinity,\n        maxWidthMultiple * (widthStep + gutterWidth) - gutterWidth)) :\n\n\n        undefined,\n\n        maxHeight:\n        adjustableHeight ?\n        Math.max(\n        size.height,\n        Math.min(proxyToInfinity, maxHeightMultiple * heightStep)) :\n\n        undefined,\n\n        size: size,\n        onResizeStart: this.handleResizeStart,\n        onResize: this.handleResize,\n        onResizeStop: this.handleResizeStop,\n        handleComponent: ResizableHandle,\n        className: cx(\n        'resizable-container',\n        isResizing && 'resizable-container--resizing'),\n\n        handleClasses: HANDLE_CLASSES },\n\n      children));\n\n\n  }}\n\n\nResizableContainer.propTypes = propTypes;\nResizableContainer.defaultProps = defaultProps;\n\nexport default ResizableContainer;","map":null,"metadata":{},"sourceType":"module"}