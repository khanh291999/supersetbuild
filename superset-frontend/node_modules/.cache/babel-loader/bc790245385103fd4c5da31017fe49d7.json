{"ast":null,"code":"import _omit from \"lodash/omit\";import \"core-js/modules/es.string.replace.js\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport { useCallback, useEffect } from 'react';\n\n/* eslint camelcase: 0 */\nimport URI from 'urijs';\nimport {\nbuildQueryContext,\nensureIsArray,\ngetChartBuildQueryRegistry,\ngetChartMetadataRegistry } from\n'@superset-ui/core';\nimport { availableDomains } from 'src/utils/hostNamesConfig';\nimport { safeStringify } from 'src/utils/safeStringify';\nimport { URL_PARAMS } from 'src/constants';\nimport {\nMULTI_OPERATORS,\nOPERATOR_ENUM_TO_OPERATOR_TYPE } from\n'src/explore/constants';\nimport { DashboardStandaloneMode } from 'src/dashboard/util/constants';\n\nconst MAX_URL_LENGTH = 8000;\n\nexport function getChartKey(explore) {\n  const { slice } = explore;\n  return slice ? slice.slice_id : 0;\n}\n\nlet requestCounter = 0;\nexport function getHostName(allowDomainSharding = false) {\n  let currentIndex = 0;\n  if (allowDomainSharding) {\n    currentIndex = requestCounter % availableDomains.length;\n    requestCounter += 1;\n\n    // if domain sharding is enabled, skip main domain for fetching chart API\n    // leave main domain free for other calls like fav star, save change, etc.\n    // to make dashboard be responsive when it's loading large number of charts\n    if (currentIndex === 0) {\n      currentIndex += 1;\n      requestCounter += 1;\n    }\n  }\n  return availableDomains[currentIndex];\n}\n\nexport function getAnnotationJsonUrl(slice_id, form_data, isNative, force) {\n  if (slice_id === null || slice_id === undefined) {\n    return null;\n  }\n  const uri = URI(window.location.search);\n  const endpoint = isNative ? 'annotation_json' : 'slice_json';\n  return uri.\n  pathname(`/superset/${endpoint}/${slice_id}`).\n  search({\n    form_data: safeStringify(form_data, (key, value) =>\n    value === null ? undefined : value),\n\n    force }).\n\n  toString();\n}\n\nexport function getURIDirectory(endpointType = 'base') {\n  // Building the directory part of the URI\n  if (\n  ['full', 'json', 'csv', 'query', 'results', 'samples'].includes(\n  endpointType))\n\n  {\n    return '/superset/explore_json/';\n  }\n  return '/superset/explore/';\n}\n\n/**\n * This gets the url of the explore page, with all the form data included explicitly.\n * This includes any form data overrides from the dashboard.\n */\nexport function getExploreLongUrl(\nformData,\nendpointType,\nallowOverflow = true,\nextraSearch = {})\n{\n  if (!formData.datasource) {\n    return null;\n  }\n\n  // remove formData params that we don't need in the explore url.\n  // These are present when generating explore urls from the dashboard page.\n  // This should be superseded by some sort of \"exploration context\" system\n  // where form data and other context is referenced by id.\n  const trimmedFormData = _omit(formData, ['dataMask', 'url_params']);\n\n  const uri = new URI('/');\n  const directory = getURIDirectory(endpointType);\n  const search = uri.search(true);\n  Object.keys(extraSearch).forEach((key) => {\n    search[key] = extraSearch[key];\n  });\n  search.form_data = safeStringify(trimmedFormData);\n  if (endpointType === URL_PARAMS.standalone.name) {\n    search.standalone = DashboardStandaloneMode.HIDE_NAV;\n  }\n  const url = uri.directory(directory).search(search).toString();\n  if (!allowOverflow && url.length > MAX_URL_LENGTH) {\n    const minimalFormData = {\n      datasource: formData.datasource,\n      viz_type: formData.viz_type };\n\n    return getExploreLongUrl(minimalFormData, endpointType, false, {\n      URL_IS_TOO_LONG_TO_SHARE: null });\n\n  }\n  return url;\n}\n\nexport function getExploreUrlFromDashboard(formData) {\n  // remove formData params that we don't need in the explore url.\n  // These are present when generating explore urls from the dashboard page.\n  // This should be superseded by some sort of \"exploration context\" system\n  // where form data and other context is referenced by id.\n  const trimmedFormData = _omit(formData, [\n  'dataMask',\n  'url_params',\n  'label_colors']);\n\n  return getExploreLongUrl(trimmedFormData, null, false);\n}\n\nexport function getChartDataUri({ path, qs, allowDomainSharding = false }) {\n  // The search params from the window.location are carried through,\n  // but can be specified with curUrl (used for unit tests to spoof\n  // the window.location).\n  let uri = new URI({\n    protocol: window.location.protocol.slice(0, -1),\n    hostname: getHostName(allowDomainSharding),\n    port: window.location.port ? window.location.port : '',\n    path });\n\n  if (qs) {\n    uri = uri.search(qs);\n  }\n  return uri;\n}\n\n/**\n * This gets the minimal url for the given form data.\n * If there are dashboard overrides present in the form data,\n * they will not be included in the url.\n */\nexport function getExploreUrl({\n  formData,\n  endpointType = 'base',\n  force = false,\n  curUrl = null,\n  requestParams = {},\n  allowDomainSharding = false,\n  method = 'POST' })\n{\n  if (!formData.datasource) {\n    return null;\n  }\n\n  // label_colors should not pollute the URL\n  // eslint-disable-next-line no-param-reassign\n  delete formData.label_colors;\n\n  let uri = getChartDataUri({ path: '/', allowDomainSharding });\n  if (curUrl) {\n    uri = URI(URI(curUrl).search());\n  }\n\n  const directory = getURIDirectory(endpointType);\n\n  // Building the querystring (search) part of the URI\n  const search = uri.search(true);\n  const { slice_id, extra_filters, adhoc_filters, viz_type } = formData;\n  if (slice_id) {\n    const form_data = { slice_id };\n    if (method === 'GET') {\n      form_data.viz_type = viz_type;\n      if (extra_filters && extra_filters.length) {\n        form_data.extra_filters = extra_filters;\n      }\n      if (adhoc_filters && adhoc_filters.length) {\n        form_data.adhoc_filters = adhoc_filters;\n      }\n    }\n    search.form_data = safeStringify(form_data);\n  }\n  if (force) {\n    search.force = 'true';\n  }\n  if (endpointType === 'csv') {\n    search.csv = 'true';\n  }\n  if (endpointType === URL_PARAMS.standalone.name) {\n    search.standalone = '1';\n  }\n  if (endpointType === 'query') {\n    search.query = 'true';\n  }\n  if (endpointType === 'results') {\n    search.results = 'true';\n  }\n  if (endpointType === 'samples') {\n    search.samples = 'true';\n  }\n  const paramNames = Object.keys(requestParams);\n  if (paramNames.length) {\n    paramNames.forEach((name) => {\n      if (requestParams.hasOwnProperty(name)) {\n        search[name] = requestParams[name];\n      }\n    });\n  }\n  return uri.search(search).directory(directory).toString();\n}\n\nexport const shouldUseLegacyApi = (formData) => {\n  const vizMetadata = getChartMetadataRegistry().get(formData.viz_type);\n  return vizMetadata ? vizMetadata.useLegacyApi : false;\n};\n\nexport const buildV1ChartDataPayload = ({\n  formData,\n  force,\n  resultFormat,\n  resultType,\n  setDataMask,\n  ownState }) =>\n{var _getChartBuildQueryRe;\n  const buildQuery = (_getChartBuildQueryRe =\n  getChartBuildQueryRegistry().get(formData.viz_type)) != null ? _getChartBuildQueryRe :\n  (buildQueryformData) =>\n  buildQueryContext(buildQueryformData, (baseQueryObject) => [\n  {\n    ...baseQueryObject }]);\n\n\n  return buildQuery(\n  {\n    ...formData,\n    force,\n    result_format: resultFormat,\n    result_type: resultType },\n\n  {\n    ownState,\n    hooks: {\n      setDataMask } });\n\n\n\n};\n\nexport const getLegacyEndpointType = ({ resultType, resultFormat }) =>\nresultFormat === 'csv' ? resultFormat : resultType;\n\nexport function postForm(url, payload, target = '_blank') {\n  if (!url) {\n    return;\n  }\n\n  const hiddenForm = document.createElement('form');\n  hiddenForm.action = url;\n  hiddenForm.method = 'POST';\n  hiddenForm.target = target;\n  const token = document.createElement('input');\n  token.type = 'hidden';\n  token.name = 'csrf_token';\n  token.value = (document.getElementById('csrf_token') || {}).value;\n  hiddenForm.appendChild(token);\n  const data = document.createElement('input');\n  data.type = 'hidden';\n  data.name = 'form_data';\n  data.value = safeStringify(payload);\n  hiddenForm.appendChild(data);\n\n  document.body.appendChild(hiddenForm);\n  hiddenForm.submit();\n  document.body.removeChild(hiddenForm);\n}\n\nexport const exportChart = ({\n  formData,\n  resultFormat = 'json',\n  resultType = 'full',\n  force = false,\n  ownState = {} }) =>\n{\n  let url;\n  let payload;\n  if (shouldUseLegacyApi(formData)) {\n    const endpointType = getLegacyEndpointType({ resultFormat, resultType });\n    url = getExploreUrl({\n      formData,\n      endpointType,\n      allowDomainSharding: false });\n\n    payload = formData;\n  } else {\n    url = '/api/v1/chart/data';\n    payload = buildV1ChartDataPayload({\n      formData,\n      force,\n      resultFormat,\n      resultType,\n      ownState });\n\n  }\n  postForm(url, payload);\n};\n\nexport const exploreChart = (formData) => {\n  const url = getExploreUrl({\n    formData,\n    endpointType: 'base',\n    allowDomainSharding: false });\n\n  postForm(url, formData);\n};\n\nexport const useDebouncedEffect = (effect, delay, deps) => {\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  const callback = useCallback(effect, deps);\n\n  useEffect(() => {\n    const handler = setTimeout(() => {\n      callback();\n    }, delay);\n\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [callback, delay]);\n};\n\nexport const getSimpleSQLExpression = (subject, operator, comparator) => {\n  const isMulti =\n  [...MULTI_OPERATORS].\n  map((op) => OPERATOR_ENUM_TO_OPERATOR_TYPE[op].operation).\n  indexOf(operator) >= 0;\n  let expression = subject != null ? subject : '';\n  if (subject && operator) {\n    expression += ` ${operator}`;\n    const firstValue =\n    isMulti && Array.isArray(comparator) ? comparator[0] : comparator;\n    const comparatorArray = ensureIsArray(comparator);\n    const isString =\n    firstValue !== undefined && Number.isNaN(Number(firstValue));\n    const quote = isString ? \"'\" : '';\n    const [prefix, suffix] = isMulti ? ['(', ')'] : ['', ''];\n    const formattedComparators = comparatorArray.map(\n    (val) =>\n    `${quote}${isString ? String(val).replace(\"'\", \"''\") : val}${quote}`);\n\n    if (comparatorArray.length > 0) {\n      expression += ` ${prefix}${formattedComparators.join(', ')}${suffix}`;\n    }\n  }\n  return expression;\n};","map":null,"metadata":{},"sourceType":"module"}