{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport React, { useCallback, useEffect, useState } from 'react';\nimport { styled, t } from '@superset-ui/core';\nimport Collapse from 'src/components/Collapse';\nimport Tabs from 'src/components/Tabs';\nimport Loading from 'src/components/Loading';\nimport TableView, { EmptyWrapperType } from 'src/components/TableView';\nimport { getChartDataRequest } from 'src/chart/chartAction';\nimport { getClientErrorObject } from 'src/utils/getClientErrorObject';\nimport { getFromLocalStorage, setInLocalStorage } from 'src/utils/localStorageHelpers';\nimport { CopyToClipboardButton, FilterInput, RowCount, useFilteredTableData, useTableColumns } from 'src/explore/components/DataTableControl';import { jsx as ___EmotionJSX } from \"@emotion/react\";\nconst RESULT_TYPES = {\n  results: 'results',\n  samples: 'samples' };\n\nconst NULLISH_RESULTS_STATE = {\n  [RESULT_TYPES.results]: undefined,\n  [RESULT_TYPES.samples]: undefined };\n\nconst DATA_TABLE_PAGE_SIZE = 50;\nconst STORAGE_KEYS = {\n  isOpen: 'is_datapanel_open' };\n\nconst DATAPANEL_KEY = 'data';\nconst TableControlsWrapper = styled.div`\n  display: flex;\n  align-items: center;\n\n  span {\n    flex-shrink: 0;\n  }\n`;\nconst SouthPane = styled.div`\n  position: relative;\n  background-color: ${({ theme }) => theme.colors.grayscale.light5};\n  z-index: 5;\n  overflow: hidden;\n`;\nconst TabsWrapper = styled.div`\n  height: ${({ contentHeight }) => contentHeight}px;\n  overflow: hidden;\n\n  .table-condensed {\n    height: 100%;\n    overflow: auto;\n  }\n`;\nconst CollapseWrapper = styled.div`\n  height: 100%;\n\n  .collapse-inner {\n    height: 100%;\n\n    .ant-collapse-item {\n      height: 100%;\n\n      .ant-collapse-content {\n        height: calc(100% - ${({ theme }) => theme.gridUnit * 8}px);\n\n        .ant-collapse-content-box {\n          padding-top: 0;\n          height: 100%;\n        }\n      }\n    }\n  }\n`;\nconst Error = styled.pre`\n  margin-top: ${({ theme }) => `${theme.gridUnit * 4}px`};\n`;\nexport const DataTablesPane = ({ queryFormData, tableSectionHeight, onCollapseChange, chartStatus, ownState, errorMessage, queriesResponse }) => {\n  const [data, setData] = useState(NULLISH_RESULTS_STATE);\n  const [isLoading, setIsLoading] = useState({\n    [RESULT_TYPES.results]: true,\n    [RESULT_TYPES.samples]: true });\n\n  const [columnNames, setColumnNames] = useState([]);\n  const [error, setError] = useState(NULLISH_RESULTS_STATE);\n  const [filterText, setFilterText] = useState('');\n  const [activeTabKey, setActiveTabKey] = useState(RESULT_TYPES.results);\n  const [isRequestPending, setIsRequestPending] = useState(NULLISH_RESULTS_STATE);\n  const [panelOpen, setPanelOpen] = useState(getFromLocalStorage(STORAGE_KEYS.isOpen, false));\n  const getData = useCallback((resultType) => {\n    setIsLoading((prevIsLoading) => ({\n      ...prevIsLoading,\n      [resultType]: true }));\n\n    return getChartDataRequest({\n      formData: queryFormData,\n      resultFormat: 'json',\n      resultType,\n      ownState }).\n\n    then(({ json }) => {\n      // Only displaying the first query is currently supported\n      if (json.result.length > 1) {\n        const data = [];\n        json.result.forEach((item) => {\n          item.data.forEach((row, i) => {\n            if (data[i] !== undefined) {\n              data[i] = { ...data[i], ...row };\n            } else\n            {\n              data[i] = row;\n            }\n          });\n        });\n        setData((prevData) => ({\n          ...prevData,\n          [resultType]: data }));\n\n      } else\n      {\n        setData((prevData) => ({\n          ...prevData,\n          [resultType]: json.result[0].data }));\n\n      }\n      setIsLoading((prevIsLoading) => ({\n        ...prevIsLoading,\n        [resultType]: false }));\n\n      setError((prevError) => ({\n        ...prevError,\n        [resultType]: null }));\n\n    }).\n    catch((response) => {\n      getClientErrorObject(response).then(({ error, message }) => {\n        setError((prevError) => ({\n          ...prevError,\n          [resultType]: error || message || t('Sorry, An error occurred') }));\n\n        setIsLoading((prevIsLoading) => ({\n          ...prevIsLoading,\n          [resultType]: false }));\n\n      });\n    });\n  }, [queryFormData]);\n  useEffect(() => {\n    setInLocalStorage(STORAGE_KEYS.isOpen, panelOpen);\n  }, [panelOpen]);\n  useEffect(() => {\n    setIsRequestPending((prevState) => ({\n      ...prevState,\n      [RESULT_TYPES.results]: true }));\n\n  }, [queryFormData]);\n  useEffect(() => {\n    setIsRequestPending((prevState) => ({\n      ...prevState,\n      [RESULT_TYPES.samples]: true }));\n\n  }, [queryFormData == null ? void 0 : queryFormData.adhoc_filters, queryFormData == null ? void 0 : queryFormData.datasource]);\n  useEffect(() => {\n    if (queriesResponse && chartStatus === 'success') {\n      const { colnames } = queriesResponse[0];\n      setColumnNames([...colnames]);\n    }\n  }, [queriesResponse]);\n  useEffect(() => {\n    if (panelOpen && isRequestPending[RESULT_TYPES.results]) {\n      if (errorMessage) {\n        setIsRequestPending((prevState) => ({\n          ...prevState,\n          [RESULT_TYPES.results]: false }));\n\n        setIsLoading((prevIsLoading) => ({\n          ...prevIsLoading,\n          [RESULT_TYPES.results]: false }));\n\n        return;\n      }\n      if (chartStatus === 'loading') {\n        setIsLoading((prevIsLoading) => ({\n          ...prevIsLoading,\n          [RESULT_TYPES.results]: true }));\n\n      } else\n      {\n        setIsRequestPending((prevState) => ({\n          ...prevState,\n          [RESULT_TYPES.results]: false }));\n\n        getData(RESULT_TYPES.results);\n      }\n    }\n    if (panelOpen &&\n    isRequestPending[RESULT_TYPES.samples] &&\n    activeTabKey === RESULT_TYPES.samples) {\n      setIsRequestPending((prevState) => ({\n        ...prevState,\n        [RESULT_TYPES.samples]: false }));\n\n      getData(RESULT_TYPES.samples);\n    }\n  }, [\n  panelOpen,\n  isRequestPending,\n  getData,\n  activeTabKey,\n  chartStatus,\n  errorMessage]);\n\n  const filteredData = {\n    [RESULT_TYPES.results]: useFilteredTableData(filterText, data[RESULT_TYPES.results]),\n    [RESULT_TYPES.samples]: useFilteredTableData(filterText, data[RESULT_TYPES.samples]) };\n\n  // this is to preserve the order of the columns, even if there are integer values,\n  // while also only grabbing the first column's keys\n  const columns = {\n    [RESULT_TYPES.results]: useTableColumns(columnNames, data[RESULT_TYPES.results]),\n    [RESULT_TYPES.samples]: useTableColumns(columnNames, data[RESULT_TYPES.samples]) };\n\n  const renderDataTable = (type) => {\n    if (isLoading[type]) {\n      return ___EmotionJSX(Loading, null);\n    }\n    if (error[type]) {\n      return ___EmotionJSX(Error, null, error[type]);\n    }\n    if (data[type]) {var _data$type;\n      if (((_data$type = data[type]) == null ? void 0 : _data$type.length) === 0) {\n        return ___EmotionJSX(\"span\", null, \"No data\");\n      }\n      return ___EmotionJSX(TableView, { columns: columns[type], data: filteredData[type], pageSize: DATA_TABLE_PAGE_SIZE, noDataText: t('No data'), emptyWrapperType: EmptyWrapperType.Small, className: \"table-condensed\", isPaginationSticky: true, showRowCount: false, small: true });\n    }\n    if (errorMessage) {\n      return ___EmotionJSX(Error, null, errorMessage);\n    }\n    return null;\n  };\n  const TableControls = ___EmotionJSX(TableControlsWrapper, null,\n  ___EmotionJSX(RowCount, { data: data[activeTabKey], loading: isLoading[activeTabKey] }),\n  ___EmotionJSX(CopyToClipboardButton, { data: data[activeTabKey], columns: columnNames }),\n  ___EmotionJSX(FilterInput, { onChangeHandler: setFilterText }));\n\n  const handleCollapseChange = (openPanelName) => {\n    onCollapseChange(openPanelName);\n    setPanelOpen(!!openPanelName);\n  };\n  return ___EmotionJSX(SouthPane, null,\n  ___EmotionJSX(TabsWrapper, { contentHeight: tableSectionHeight },\n  ___EmotionJSX(CollapseWrapper, null,\n  ___EmotionJSX(Collapse, { accordion: true, bordered: false, defaultActiveKey: panelOpen ? DATAPANEL_KEY : undefined, onChange: handleCollapseChange, bold: true, ghost: true, className: \"collapse-inner\" },\n  ___EmotionJSX(Collapse.Panel, { header: t('Data'), key: DATAPANEL_KEY },\n  ___EmotionJSX(Tabs, { fullWidth: false, tabBarExtraContent: TableControls, activeKey: activeTabKey, onChange: setActiveTabKey },\n  ___EmotionJSX(Tabs.TabPane, { tab: t('View results'), key: RESULT_TYPES.results },\n  renderDataTable(RESULT_TYPES.results)),\n\n  ___EmotionJSX(Tabs.TabPane, { tab: t('View samples'), key: RESULT_TYPES.samples },\n  renderDataTable(RESULT_TYPES.samples))))))));\n\n\n\n\n\n\n\n};","map":null,"metadata":{},"sourceType":"module"}