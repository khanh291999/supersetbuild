{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint camelcase: 0 */\nimport { t, SupersetClient } from '@superset-ui/core';\nimport rison from 'rison';\n\nimport { addDangerToast } from 'src/components/MessageToasts/actions';\nimport { getDatasourceParameter } from 'src/modules/utils';\nimport { getClientErrorObject } from 'src/utils/getClientErrorObject';\n\nexport const SET_ALL_SLICES = 'SET_ALL_SLICES';\nexport function setAllSlices(slices) {\n  return { type: SET_ALL_SLICES, payload: { slices } };\n}\n\nexport const FETCH_ALL_SLICES_STARTED = 'FETCH_ALL_SLICES_STARTED';\nexport function fetchAllSlicesStarted() {\n  return { type: FETCH_ALL_SLICES_STARTED };\n}\n\nexport const FETCH_ALL_SLICES_FAILED = 'FETCH_ALL_SLICES_FAILED';\nexport function fetchAllSlicesFailed(error) {\n  return { type: FETCH_ALL_SLICES_FAILED, payload: { error } };\n}\n\nconst FETCH_SLICES_PAGE_SIZE = 200;\nexport function fetchAllSlices(userId) {\n  return (dispatch, getState) => {\n    const { sliceEntities } = getState();\n    if (sliceEntities.lastUpdated === 0) {\n      dispatch(fetchAllSlicesStarted());\n\n      return SupersetClient.get({\n        endpoint: `/api/v1/chart/?q=${rison.encode({\n          columns: [\n          'changed_on_delta_humanized',\n          'changed_on_utc',\n          'datasource_id',\n          'datasource_type',\n          'datasource_url',\n          'datasource_name_text',\n          'description_markeddown',\n          'description',\n          'id',\n          'params',\n          'slice_name',\n          'url',\n          'viz_type'],\n\n          filters: [{ col: 'owners', opr: 'rel_m_m', value: userId }],\n          page_size: FETCH_SLICES_PAGE_SIZE,\n          order_column: 'changed_on_delta_humanized',\n          order_direction: 'desc' })\n        }` }).\n\n      then(({ json }) => {\n        const slices = {};\n        json.result.forEach((slice) => {\n          let form_data = JSON.parse(slice.params);\n          form_data = {\n            ...form_data,\n            // force using datasource stored in relational table prop\n            datasource:\n            getDatasourceParameter(\n            slice.datasource_id,\n            slice.datasource_type) ||\n            form_data.datasource };\n\n          slices[slice.id] = {\n            slice_id: slice.id,\n            slice_url: slice.url,\n            slice_name: slice.slice_name,\n            form_data,\n            datasource_name: slice.datasource_name_text,\n            datasource_url: slice.datasource_url,\n            datasource_id: slice.datasource_id,\n            datasource_type: slice.datasource_type,\n            changed_on: new Date(slice.changed_on_utc).getTime(),\n            description: slice.description,\n            description_markdown: slice.description_markeddown,\n            viz_type: slice.viz_type,\n            modified: slice.changed_on_delta_humanized,\n            changed_on_humanized: slice.changed_on_delta_humanized };\n\n        });\n\n        return dispatch(setAllSlices(slices));\n      }).\n      catch(\n      (errorResponse) =>\n      console.log(errorResponse) ||\n      getClientErrorObject(errorResponse).then(({ error }) => {\n        dispatch(\n        fetchAllSlicesFailed(\n        error || t('Could not fetch all saved charts')));\n\n\n        dispatch(\n        addDangerToast(\n        t('Sorry there was an error fetching saved charts: ') + error));\n\n\n      }));\n\n    }\n\n    return dispatch(setAllSlices(sliceEntities.slices));\n  };\n}","map":null,"metadata":{},"sourceType":"module"}