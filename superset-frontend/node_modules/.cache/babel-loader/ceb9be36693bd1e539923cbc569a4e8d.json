{"ast":null,"code":"import shortid from 'shortid';\nimport { getInitialDataMask } from 'src/dataMask/reducer';\nimport { t } from '@superset-ui/core';\nexport const REMOVAL_DELAY_SECS = 5;\nexport const validateForm = async (form, currentFilterId, filterConfigMap, filterIds, removedFilters, setCurrentFilterId) => {\n  const addValidationError = (filterId, field, error) => {\n    const fieldError = {\n      name: ['filters', filterId, field],\n      errors: [error] };\n\n    form.setFields([fieldError]);\n    setCurrentFilterId(filterId);\n  };\n  try {\n    let formValues;\n    try {\n      formValues = await form.validateFields();\n    }\n    catch (error) {var _error$errorFields;\n      // In Jest tests in chain of tests, Ant generate `outOfDate` error so need to catch it here\n      if (!(error != null && (_error$errorFields = error.errorFields) != null && _error$errorFields.length) && error != null && error.outOfDate) {\n        formValues = error.values;\n      } else\n      {\n        throw error;\n      }\n    }\n    const validateCycles = (filterId, trace = []) => {var _formValues$filters, _formValues$filters$f, _formValues$filters$f2, _filterConfigMap$filt, _filterConfigMap$filt2;\n      if (trace.includes(filterId)) {\n        addValidationError(filterId, 'parentFilter', t('Cannot create cyclic hierarchy'));\n        return false;\n      }\n      const parentId = (_formValues$filters = formValues.filters) != null && _formValues$filters[filterId] ? (_formValues$filters$f =\n      formValues.filters[filterId]) == null ? void 0 : (_formValues$filters$f2 = _formValues$filters$f.parentFilter) == null ? void 0 : _formValues$filters$f2.value : (_filterConfigMap$filt =\n      filterConfigMap[filterId]) == null ? void 0 : (_filterConfigMap$filt2 = _filterConfigMap$filt.cascadeParentIds) == null ? void 0 : _filterConfigMap$filt2[0];\n      if (parentId) {\n        return validateCycles(parentId, [...trace, filterId]);\n      }\n      return true;\n    };\n    const invalid = filterIds.\n    filter((id) => !removedFilters[id]).\n    some((filterId) => !validateCycles(filterId));\n    if (invalid) {\n      return null;\n    }\n    return formValues;\n  }\n  catch (error) {\n    console.warn('Filter configuration failed:', error);\n    if (!error.errorFields || !error.errorFields.length)\n    return null; // not a validation error\n    const errorFields = error.errorFields;\n    // filter id is the second item in the field name\n    if (!errorFields.some((field) => field.name[1] === currentFilterId)) {\n      // switch to the first tab that had a validation error\n      const filterError = errorFields.find((field) => field.name[0] === 'filters');\n      if (filterError) {\n        const filterId = filterError.name[1];\n        setCurrentFilterId(filterId);\n      }\n    }\n    return null;\n  }\n};\nexport const createHandleSave = (filterConfigMap, filterIds, removedFilters, saveForm, values) => async () => {\n  const newFilterConfig = filterIds.\n  filter((id) => !removedFilters[id]).\n  map((id) => {var _values$filters, _formInputs$controlVa, _formInputs$requiredF, _formInputs$defaultDa;\n    // create a filter config object from the form inputs\n    const formInputs = (_values$filters = values.filters) == null ? void 0 : _values$filters[id];\n    // if user didn't open a filter, return the original config\n    if (!formInputs)\n    return filterConfigMap[id];\n    const target = {};\n    if (formInputs.dataset) {\n      target.datasetId = formInputs.dataset.value;\n    }\n    if (formInputs.dataset && formInputs.column) {\n      target.column = { name: formInputs.column };\n    }\n    return {\n      id,\n      adhoc_filters: formInputs.adhoc_filters,\n      time_range: formInputs.time_range,\n      controlValues: (_formInputs$controlVa = formInputs.controlValues) != null ? _formInputs$controlVa : {},\n      granularity_sqla: formInputs.granularity_sqla,\n      requiredFirst: Object.values((_formInputs$requiredF = formInputs.requiredFirst) != null ? _formInputs$requiredF : {}).find((rf) => rf),\n      name: formInputs.name,\n      filterType: formInputs.filterType,\n      // for now there will only ever be one target\n      targets: [target],\n      defaultDataMask: (_formInputs$defaultDa = formInputs.defaultDataMask) != null ? _formInputs$defaultDa : getInitialDataMask(),\n      cascadeParentIds: formInputs.parentFilter ?\n      [formInputs.parentFilter.value] :\n      [],\n      scope: formInputs.scope,\n      sortMetric: formInputs.sortMetric,\n      type: formInputs.type };\n\n  });\n  await saveForm(newFilterConfig);\n};\nexport const createHandleTabEdit = (setRemovedFilters, setSaveAlertVisible, addFilter) => (filterId, action) => {\n  const completeFilterRemoval = (filterId) => {\n    // the filter state will actually stick around in the form,\n    // and the filterConfig/newFilterIds, but we use removedFilters\n    // to mark it as removed.\n    setRemovedFilters((removedFilters) => ({\n      ...removedFilters,\n      [filterId]: { isPending: false } }));\n\n  };\n  if (action === 'remove') {\n    // first set up the timer to completely remove it\n    const timerId = window.setTimeout(() => completeFilterRemoval(filterId), REMOVAL_DELAY_SECS * 1000);\n    // mark the filter state as \"removal in progress\"\n    setRemovedFilters((removedFilters) => ({\n      ...removedFilters,\n      [filterId]: { isPending: true, timerId } }));\n\n    setSaveAlertVisible(false);\n  } else\n  if (action === 'add') {\n    addFilter();\n  }\n};\nexport const NATIVE_FILTER_PREFIX = 'NATIVE_FILTER-';\nexport const generateFilterId = () => `${NATIVE_FILTER_PREFIX}${shortid.generate()}`;\nexport const getFilterIds = (config) => config.map((filter) => filter.id);","map":null,"metadata":{},"sourceType":"module"}