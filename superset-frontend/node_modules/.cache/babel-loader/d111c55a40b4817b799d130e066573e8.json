{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint max-len: 0 */\n/**\n * When determining if a component is a valid child of another component we must consider both\n *   - parent + child component types\n *   - component depth, or depth of nesting of container components\n *\n * We consider types because some components aren't containers (e.g. a heading) and we consider\n * depth to prevent infinite nesting of container components.\n *\n * The following example container nestings should be valid, which means that some containers\n * don't increase the (depth) of their children, namely tabs and tab:\n *   (a) root (0) > grid (1) >                         row (2) > column (3) > row (4) > non-container (5)\n *   (b) root (0) > grid (1) >    tabs (2) > tab (2) > row (2) > column (3) > row (4) > non-container (5)\n *   (c) root (0) > top-tab (1) >                      row (2) > column (3) > row (4) > non-container (5)\n *   (d) root (0) > top-tab (1) > tabs (2) > tab (2) > row (2) > column (3) > row (4) > non-container (5)\n */\nimport { CHART_TYPE, COLUMN_TYPE, DASHBOARD_GRID_TYPE, DASHBOARD_ROOT_TYPE, DIVIDER_TYPE, HEADER_TYPE, MARKDOWN_TYPE, ROW_TYPE, TABS_TYPE, TAB_TYPE } from './componentTypes';\nimport { DASHBOARD_ROOT_DEPTH as rootDepth } from './constants';\nconst depthOne = rootDepth + 1;\n// const depthTwo = rootDepth + 2; // Meantime no need\nconst depthThree = rootDepth + 3;\nconst depthFour = rootDepth + 4;\nconst depthFive = rootDepth + 5;\n// when moving components around the depth of child is irrelevant, note these are parent depths\nconst parentMaxDepthLookup = {\n  [DASHBOARD_ROOT_TYPE]: {\n    [TABS_TYPE]: rootDepth,\n    [DASHBOARD_GRID_TYPE]: rootDepth },\n\n  [DASHBOARD_GRID_TYPE]: {\n    [CHART_TYPE]: depthOne,\n    [MARKDOWN_TYPE]: depthOne,\n    [COLUMN_TYPE]: depthOne,\n    [DIVIDER_TYPE]: depthOne,\n    [HEADER_TYPE]: depthOne,\n    [ROW_TYPE]: depthOne,\n    [TABS_TYPE]: depthOne },\n\n  [ROW_TYPE]: {\n    [CHART_TYPE]: depthFour,\n    [MARKDOWN_TYPE]: depthFour,\n    [COLUMN_TYPE]: depthFour },\n\n  [TABS_TYPE]: {\n    [TAB_TYPE]: depthThree },\n\n  [TAB_TYPE]: {\n    [CHART_TYPE]: depthFive,\n    [MARKDOWN_TYPE]: depthFive,\n    [COLUMN_TYPE]: depthThree,\n    [DIVIDER_TYPE]: depthFive,\n    [HEADER_TYPE]: depthFive,\n    [ROW_TYPE]: depthThree,\n    [TABS_TYPE]: depthThree },\n\n  [COLUMN_TYPE]: {\n    [CHART_TYPE]: depthFive,\n    [HEADER_TYPE]: depthFive,\n    [MARKDOWN_TYPE]: depthFive,\n    [ROW_TYPE]: depthThree,\n    [DIVIDER_TYPE]: depthThree,\n    [TABS_TYPE]: depthThree },\n\n  // these have no valid children\n  [CHART_TYPE]: {},\n  [DIVIDER_TYPE]: {},\n  [HEADER_TYPE]: {},\n  [MARKDOWN_TYPE]: {} };\n\nexport default function isValidChild(child) {\n  const { parentType, childType, parentDepth } = child;\n  if (!parentType || !childType || typeof parentDepth !== 'number') {\n    return false;\n  }\n  const maxParentDepth = (parentMaxDepthLookup[parentType] || {})[childType];\n  return typeof maxParentDepth === 'number' && parentDepth <= maxParentDepth;\n}","map":null,"metadata":{},"sourceType":"module"}