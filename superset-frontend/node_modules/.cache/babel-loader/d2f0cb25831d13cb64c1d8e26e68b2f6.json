{"ast":null,"code":"import _extends from \"@babel/runtime-corejs3/helpers/extends\";import _merge from \"lodash/merge\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport React from 'react';\n\nimport BasicSelect, { components as defaultComponents, createFilter } from 'react-select';\nimport { withAsyncPaginate } from 'react-select-async-paginate';\nimport { SortableContainer, SortableElement } from 'react-sortable-hoc';\nimport arrayMove from 'array-move';\nimport { useTheme } from '@superset-ui/core';\nimport { WindowedSelect, WindowedAsyncSelect, WindowedCreatableSelect, WindowedAsyncCreatableSelect } from './WindowedSelect';\nimport { DEFAULT_CLASS_NAME, DEFAULT_CLASS_NAME_PREFIX, DEFAULT_STYLES, DEFAULT_COMPONENTS, VALUE_LABELED_STYLES, defaultTheme } from './styles';\nimport { findValue } from './utils';import { jsx as ___EmotionJSX } from \"@emotion/react\";\nfunction styled(SelectComponent) {\n  const SortableSelectComponent = SortableContainer(SelectComponent, {\n    withRef: true });\n\n  // default components for the given OptionType\n  const supersetDefaultComponents = DEFAULT_COMPONENTS;\n  const getSortableMultiValue = (MultiValue) => SortableElement((props) => {\n    const onMouseDown = (e) => {\n      e.preventDefault();\n      e.stopPropagation();\n    };\n    const innerProps = { onMouseDown };\n    return ___EmotionJSX(MultiValue, _extends({}, props, { innerProps: innerProps }));\n  });\n  /**\n   * Superset styled `Select` component. Apply Superset themed stylesheets and\n   * consolidate props API for backward compatibility with react-select v1.\n   */\n  function StyledSelect(selectProps) {\n    let stateManager; // reference to react-select StateManager\n    const {\n      // additional props for Superset Select\n      selectRef, labelKey = 'label', valueKey = 'value', themeConfig, stylesConfig = {}, optionRenderer, valueRenderer,\n      // whether value is rendered as `option-label` in input,\n      // useful for AdhocMetric and AdhocFilter\n      valueRenderedAsLabel: valueRenderedAsLabel_, onPaste, multi = false, // same as `isMulti`, used for backward compatibility\n      clearable, // same as `isClearable`\n      sortable = true, // whether to enable drag & drop sorting\n      forceOverflow, // whether the dropdown should be forcefully overflowing\n      // react-select props\n      className = DEFAULT_CLASS_NAME, classNamePrefix = DEFAULT_CLASS_NAME_PREFIX, options, value: value_, components: components_, isMulti: isMulti_, isClearable: isClearable_, minMenuHeight = 100, // apply different defaults\n      maxMenuHeight = 220, filterOption, ignoreAccents = false, // default is `true`, but it is slow\n      getOptionValue = (option) => typeof option === 'string' ? option : option[valueKey], getOptionLabel = (option) => typeof option === 'string' ?\n      option :\n      option[labelKey] || option[valueKey], formatOptionLabel = (option, { context }) => {\n        if (context === 'value') {\n          return valueRenderer ? valueRenderer(option) : getOptionLabel(option);\n        }\n        return optionRenderer ? optionRenderer(option) : getOptionLabel(option);\n      }, ...restProps } = selectProps;\n    // `value` may be rendered values (strings), we want option objects\n    const value = findValue(value_, options || [], valueKey);\n    // Add backward compability to v1 API\n    const isMulti = isMulti_ === undefined ? multi : isMulti_;\n    const isClearable = isClearable_ === undefined ? clearable : isClearable_;\n    // Sort is only applied when there are multiple selected values\n    const shouldAllowSort = isMulti && sortable && Array.isArray(value) && value.length > 1;\n    const MaybeSortableSelect = shouldAllowSort ?\n    SortableSelectComponent :\n    SelectComponent;\n    const components = { ...supersetDefaultComponents, ...components_ };\n    // Make multi-select sortable as per https://react-select.netlify.app/advanced\n    if (shouldAllowSort) {\n      components.MultiValue = getSortableMultiValue(components.MultiValue || defaultComponents.MultiValue);\n      const sortableContainerProps = {\n        getHelperDimensions: ({ node }) => node.getBoundingClientRect(),\n        axis: 'xy',\n        onSortEnd: ({ oldIndex, newIndex }) => {\n          const newValue = arrayMove(value, oldIndex, newIndex);\n          if (restProps.onChange) {\n            restProps.onChange(newValue, { action: 'set-value' });\n          }\n        },\n        distance: 4 };\n\n      Object.assign(restProps, sortableContainerProps);\n    }\n    // When values are rendered as labels, adjust valueContainer padding\n    const valueRenderedAsLabel = valueRenderedAsLabel_ === undefined ? isMulti : valueRenderedAsLabel_;\n    if (valueRenderedAsLabel && !stylesConfig.valueContainer) {\n      Object.assign(stylesConfig, VALUE_LABELED_STYLES);\n    }\n    // Handle onPaste event\n    if (onPaste) {\n      const Input = components.Input ||\n      defaultComponents.Input;\n      components.Input = (props) => ___EmotionJSX(Input, _extends({}, props, { onPaste: onPaste }));\n    }\n    // for CreaTable\n    if (SelectComponent === WindowedCreatableSelect) {\n      restProps.getNewOptionData = (inputValue, label) => ({\n        label: label || inputValue,\n        [valueKey]: inputValue,\n        isNew: true });\n\n    }\n    // handle forcing dropdown overflow\n    // use only when setting overflow:visible isn't possible on the container element\n    if (forceOverflow) {\n      Object.assign(restProps, {\n        closeMenuOnScroll: (e) => {var _stateManager, _stateManager$state, _target$classList;\n          // ensure menu is open\n          const menuIsOpen = (_stateManager = stateManager) == null ? void 0 : (_stateManager$state = _stateManager.state) == null ? void 0 : _stateManager$state.\n          menuIsOpen;\n          const target = e.target;\n          return menuIsOpen &&\n          target &&\n          !((_target$classList = target.classList) != null && _target$classList.contains('Select__menu-list'));\n        },\n        menuPosition: 'fixed' });\n\n    }\n    // Make sure always return StateManager for the refs.\n    // To get the real `Select` component, keep tap into `obj.select`:\n    //   - for normal <Select /> component: StateManager -> Select,\n    //   - for <Creatable />: StateManager -> Creatable -> Select\n    const setRef = (instance) => {\n      stateManager =\n      shouldAllowSort && instance && 'refs' in instance ?\n      instance.refs.wrappedInstance // obtain StateManger from SortableContainer\n      : instance;\n      if (typeof selectRef === 'function') {\n        selectRef(stateManager);\n      } else\n      if (selectRef && 'current' in selectRef) {\n        selectRef.current = stateManager;\n      }\n    };\n    const theme = useTheme();\n    return ___EmotionJSX(MaybeSortableSelect, _extends({ ref: setRef, className: className, classNamePrefix: classNamePrefix, isMulti: isMulti, isClearable: isClearable, options: options, value: value, minMenuHeight: minMenuHeight, maxMenuHeight: maxMenuHeight, filterOption:\n      // filterOption may be NULL\n      filterOption !== undefined ?\n      filterOption :\n      createFilter({ ignoreAccents }), styles: { ...DEFAULT_STYLES, ...stylesConfig }\n      // merge default theme from `react-select`, default theme for Superset,\n      // and the theme from props.\n      , theme: (reactSelectTheme) => _merge(reactSelectTheme, defaultTheme(theme), themeConfig), formatOptionLabel: formatOptionLabel, getOptionLabel: getOptionLabel, getOptionValue: getOptionValue, components: components }, restProps));\n  }\n  // React.memo makes sure the component does no rerender given the same props\n  return /*#__PURE__*/React.memo(StyledSelect);\n}\nexport const Select = styled(WindowedSelect);\nexport const AsyncSelect = styled(WindowedAsyncSelect);\nexport const CreatableSelect = styled(WindowedCreatableSelect);\nexport const AsyncCreatableSelect = styled(WindowedAsyncCreatableSelect);\nexport const PaginatedSelect = withAsyncPaginate(styled(BasicSelect));\nexport default Select;","map":null,"metadata":{},"sourceType":"module"}