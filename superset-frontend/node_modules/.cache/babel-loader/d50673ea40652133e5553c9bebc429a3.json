{"ast":null,"code":"import _extends from \"@babel/runtime-corejs3/helpers/extends\";import _isEmpty from \"lodash/isEmpty\";import _isEqual from \"lodash/isEqual\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { Behavior, GenericDataType, getChartMetadataRegistry, styled, t, SupersetClient } from '@superset-ui/core';\nimport { InfoTooltipWithTrigger } from '@superset-ui/chart-controls';\nimport React, { forwardRef, useCallback, useEffect, useImperativeHandle, useMemo, useState } from 'react';\nimport { useSelector } from 'react-redux';\n\nimport { FormItem } from 'src/components/Form';\nimport { Input } from 'src/common/components';\nimport { Select } from 'src/components';\nimport { cacheWrapper } from 'src/utils/cacheWrapper';\nimport AdhocFilterControl from 'src/explore/components/controls/FilterControl/AdhocFilterControl';\nimport DateFilterControl from 'src/explore/components/controls/DateFilterControl';\nimport { addDangerToast } from 'src/components/MessageToasts/actions';\nimport Collapse from 'src/components/Collapse';\nimport { getChartDataRequest } from 'src/chart/chartAction';\nimport { FeatureFlag, isFeatureEnabled } from 'src/featureFlags';\nimport { waitForAsyncData } from 'src/middleware/asyncEvent';\nimport Tabs from 'src/components/Tabs';\nimport Icons from 'src/components/Icons';\nimport { Tooltip } from 'src/components/Tooltip';\nimport { Radio } from 'src/components/Radio';\nimport BasicErrorAlert from 'src/components/ErrorMessage/BasicErrorAlert';\nimport Loading from 'src/components/Loading';\nimport { ColumnSelect } from './ColumnSelect';\nimport { FILTER_SUPPORTED_TYPES, hasTemporalColumns, setNativeFilterFieldValues, useForceUpdate, mostUsedDataset } from './utils';\nimport { useBackendFormUpdate, useDefaultValue } from './state';\nimport { getFormData } from '../../utils';\nimport { NativeFilterType } from '../../types';\nimport getControlItemsMap from './getControlItemsMap';\nimport FilterScope from './FilterScope/FilterScope';\nimport RemovedFilter from './RemovedFilter';\nimport DefaultValue from './DefaultValue';\nimport { CollapsibleControl } from './CollapsibleControl';\nimport { CASCADING_FILTERS, getFiltersConfigModalTestId } from '../FiltersConfigModal';\nimport DatasetSelect from './DatasetSelect';import { jsx as ___EmotionJSX } from \"@emotion/react\";\nconst { TabPane } = Tabs;\nconst StyledContainer = styled.div`\n  display: flex;\n  flex-direction: row-reverse;\n  justify-content: space-between;\n`;\nconst StyledRowContainer = styled.div`\n  display: flex;\n  flex-direction: row;\n  justify-content: space-between;\n  width: 100%;\n`;\nexport const StyledFormItem = styled(FormItem)`\n  width: 49%;\n  margin-bottom: ${({ theme }) => theme.gridUnit * 4}px;\n\n  & .ant-form-item-label {\n    padding-bottom: 0;\n  }\n\n  & .ant-form-item-control-input {\n    min-height: ${({ theme }) => theme.gridUnit * 10}px;\n  }\n`;\nexport const StyledRowFormItem = styled(FormItem)`\n  margin-bottom: 0;\n  padding-bottom: 0;\n  min-width: 50%;\n\n  & .ant-form-item-label {\n    padding-bottom: 0;\n  }\n\n  .ant-form-item-control-input-content > div > div {\n    height: auto;\n  }\n\n  & .ant-form-item-control-input {\n    min-height: ${({ theme }) => theme.gridUnit * 10}px;\n  }\n`;\nexport const StyledRowSubFormItem = styled(FormItem)`\n  min-width: 50%;\n\n  & .ant-form-item-label {\n    padding-bottom: 0;\n  }\n\n  .ant-form-item {\n    margin-bottom: 0;\n  }\n\n  .ant-form-item-control-input-content > div > div {\n    height: auto;\n  }\n\n  .ant-form-item-extra {\n    display: none;\n  }\n\n  & .ant-form-item-control-input {\n    height: auto;\n  }\n`;\nexport const StyledLabel = styled.span`\n  color: ${({ theme }) => theme.colors.grayscale.base};\n  font-size: ${({ theme }) => theme.typography.sizes.s}px;\n  text-transform: uppercase;\n`;\nconst CleanFormItem = styled(FormItem)`\n  margin-bottom: 0;\n`;\nconst DefaultValueContainer = styled.div`\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n`;\nconst RefreshIcon = styled(Icons.Refresh)`\n  margin-left: ${({ theme }) => theme.gridUnit * 2}px;\n  color: ${({ theme }) => theme.colors.primary.base};\n`;\nconst StyledCollapse = styled(Collapse)`\n  margin-left: ${({ theme }) => theme.gridUnit * -4 - 1}px;\n  margin-right: ${({ theme }) => theme.gridUnit * -4}px;\n  border-left: 1px solid ${({ theme }) => theme.colors.grayscale.light2};\n  border-top: 1px solid ${({ theme }) => theme.colors.grayscale.light2};\n  border-radius: 0;\n\n  .ant-collapse-header {\n    border-bottom: 1px solid ${({ theme }) => theme.colors.grayscale.light2};\n    border-top: 1px solid ${({ theme }) => theme.colors.grayscale.light2};\n    margin-top: -1px;\n    border-radius: 0;\n  }\n\n  .ant-collapse-content {\n    border: 0;\n  }\n\n  .ant-collapse-content-box {\n    padding-top: ${({ theme }) => theme.gridUnit * 2}px;\n  }\n\n  &.ant-collapse > .ant-collapse-item {\n    border: 0;\n    border-radius: 0;\n  }\n`;\nconst StyledTabs = styled(Tabs)`\n  .ant-tabs-nav {\n    position: sticky;\n    margin-left: ${({ theme }) => theme.gridUnit * -4}px;\n    margin-right: ${({ theme }) => theme.gridUnit * -4}px;\n    top: 0;\n    background: white;\n    z-index: 1;\n  }\n\n  .ant-tabs-nav-list {\n    padding: 0;\n  }\n\n  .ant-form-item-label {\n    padding-bottom: 0;\n  }\n`;\nconst StyledAsterisk = styled.span`\n  color: ${({ theme }) => theme.colors.error.base};\n  font-size: ${({ theme }) => theme.typography.sizes.s}px;\n  margin-left: ${({ theme }) => theme.gridUnit - 1}px;\n  &:before {\n    content: '*';\n  }\n`;\nconst FilterTabs = {\n  configuration: {\n    key: 'configuration',\n    name: t('Configuration') },\n\n  scoping: {\n    key: 'scoping',\n    name: t('Scoping') } };\n\n\nconst FilterPanels = {\n  basic: {\n    key: 'basic',\n    name: t('Basic') },\n\n  advanced: {\n    key: 'advanced',\n    name: t('Advanced') } };\n\n\nconst FILTERS_WITH_ADHOC_FILTERS = ['filter_select', 'filter_range'];\nconst BASIC_CONTROL_ITEMS = ['enableEmptyFilter', 'multiSelect'];\n// TODO: Rename the filter plugins and remove this mapping\nconst FILTER_TYPE_NAME_MAPPING = {\n  [t('Select filter')]: t('Value'),\n  [t('Range filter')]: t('Numerical range'),\n  [t('Time filter')]: t('Time range'),\n  [t('Time column')]: t('Time column'),\n  [t('Time grain')]: t('Time grain'),\n  [t('Group By')]: t('Group by') };\n\nconst localCache = new Map();\nconst cachedSupersetGet = cacheWrapper(SupersetClient.get, localCache, ({ endpoint }) => endpoint || '');\n/**\n * The configuration form for a specific filter.\n * Assigns field values to `filters[filterId]` in the form.\n */\nconst FiltersConfigForm = ({ filterId, filterToEdit, removedFilters, restoreFilter, form, parentFilters, setErroredFilters }, ref) => {var _form$getFieldValue, _formFilter$parentFil, _filterToEdit$cascade, _formFilter$dataset2, _nativeFilterItems$fo, _nativeFilterItems$fo2, _ref, _formFilter$dataset$v, _formFilter$dataset3, _filterToEdit$targets, _nativeFilterItems$fo3, _nativeFilterItem$val, _formFilter$isDataDir, _formFilter$dataset6, _filterToEdit$adhoc_f, _formFilter$controlVa, _filterToEdit$control, _filterToEdit$control2, _formFilter$controlVa2, _formFilter$adhoc_fil, _formFilter$controlVa3, _formFilter$dataset9, _datasetDetails$colum;\n  const isRemoved = !!removedFilters[filterId];\n  const [error, setError] = useState('');\n  const [metrics, setMetrics] = useState([]);\n  const [activeTabKey, setActiveTabKey] = useState(FilterTabs.configuration.key);\n  const [activeFilterPanelKey, setActiveFilterPanelKey] = useState();\n  const [undoFormValues, setUndoFormValues] = useState(null);\n  const forceUpdate = useForceUpdate();\n  const [datasetDetails, setDatasetDetails] = useState();\n  const defaultFormFilter = useMemo(() => ({}), []);\n  const formValues = (_form$getFieldValue = form.getFieldValue('filters')) == null ? void 0 : _form$getFieldValue[filterId];\n  const formFilter = formValues || undoFormValues || defaultFormFilter;\n  const parentFilterOptions = useMemo(() => parentFilters.map((filter) => ({\n    value: filter.id,\n    label: filter.title })),\n  [parentFilters]);\n  const parentId = (formFilter == null ? void 0 : (_formFilter$parentFil = formFilter.parentFilter) == null ? void 0 : _formFilter$parentFil.value) || (filterToEdit == null ? void 0 : (_filterToEdit$cascade = filterToEdit.cascadeParentIds) == null ? void 0 : _filterToEdit$cascade[0]);\n  const parentFilter = parentFilterOptions.find(({ value }) => value === parentId);\n  const hasParentFilter = !!parentFilter;\n  const nativeFilterItems = getChartMetadataRegistry().items;\n  const nativeFilterVizTypes = Object.entries(nativeFilterItems)\n  // @ts-ignore\n  .filter(([, { value }]) => {var _value$behaviors;return (_value$behaviors = value.behaviors) == null ? void 0 : _value$behaviors.includes(Behavior.NATIVE_FILTER);}).\n  map(([key]) => key);\n  const loadedDatasets = useSelector(({ datasources }) => datasources);\n  const charts = useSelector(({ charts }) => charts);\n  const doLoadedDatasetsHaveTemporalColumns = useMemo(() => Object.values(loadedDatasets).some((dataset) => hasTemporalColumns(dataset)), [loadedDatasets]);\n  const showTimeRangePicker = useMemo(() => {\n    const currentDataset = Object.values(loadedDatasets).find((dataset) => {var _formFilter$dataset;return dataset.id === (formFilter == null ? void 0 : (_formFilter$dataset = formFilter.dataset) == null ? void 0 : _formFilter$dataset.value);});\n    return currentDataset ? hasTemporalColumns(currentDataset) : true;\n  }, [formFilter == null ? void 0 : (_formFilter$dataset2 = formFilter.dataset) == null ? void 0 : _formFilter$dataset2.value, loadedDatasets]);\n  // @ts-ignore\n  const hasDataset = !!((_nativeFilterItems$fo = nativeFilterItems[formFilter == null ? void 0 : formFilter.filterType]) != null && (_nativeFilterItems$fo2 = _nativeFilterItems$fo.value) != null && _nativeFilterItems$fo2.\n  datasourceCount);\n  const datasetId = (_ref = (_formFilter$dataset$v = formFilter == null ? void 0 : (_formFilter$dataset3 = formFilter.dataset) == null ? void 0 : _formFilter$dataset3.value) != null ? _formFilter$dataset$v :\n  filterToEdit == null ? void 0 : (_filterToEdit$targets = filterToEdit.targets[0]) == null ? void 0 : _filterToEdit$targets.datasetId) != null ? _ref :\n  mostUsedDataset(loadedDatasets, charts);\n  const { controlItems = {}, mainControlItems = {} } = formFilter ?\n  getControlItemsMap({\n    datasetId,\n    disabled: false,\n    forceUpdate,\n    form,\n    filterId,\n    filterType: formFilter == null ? void 0 : formFilter.filterType,\n    filterToEdit,\n    formFilter,\n    removed: isRemoved }) :\n\n  {};\n  const hasColumn = !!mainControlItems.groupby;\n  const nativeFilterItem = (_nativeFilterItems$fo3 = nativeFilterItems[formFilter == null ? void 0 : formFilter.filterType]) != null ? _nativeFilterItems$fo3 : {};\n  // @ts-ignore\n  const enableNoResults = !!((_nativeFilterItem$val = nativeFilterItem.value) != null && _nativeFilterItem$val.enableNoResults);\n  const hasMetrics = hasColumn && !!metrics.length;\n  const hasFilledDataset = !hasDataset || datasetId && ((formFilter == null ? void 0 : formFilter.column) || !hasColumn);\n  const hasAdditionalFilters = FILTERS_WITH_ADHOC_FILTERS.includes(formFilter == null ? void 0 : formFilter.filterType);\n  const isCascadingFilter = CASCADING_FILTERS.includes(formFilter == null ? void 0 : formFilter.filterType);\n  const isDataDirty = (_formFilter$isDataDir = formFilter == null ? void 0 : formFilter.isDataDirty) != null ? _formFilter$isDataDir : true;\n  const setNativeFilterFieldValuesWrapper = (values) => {\n    setNativeFilterFieldValues(form, filterId, values);\n    setError('');\n    forceUpdate();\n  };\n  const setErrorWrapper = (error) => {\n    setNativeFilterFieldValues(form, filterId, {\n      defaultValueQueriesData: null });\n\n    setError(error);\n    forceUpdate();\n  };\n  const refreshHandler = useCallback((force = false) => {var _formFilter$dataset4, _formFilter$dataset5;\n    if (!hasDataset || !(formFilter != null && (_formFilter$dataset4 = formFilter.dataset) != null && _formFilter$dataset4.value)) {\n      forceUpdate();\n      return;\n    }\n    const formData = getFormData({\n      datasetId: formFilter == null ? void 0 : (_formFilter$dataset5 = formFilter.dataset) == null ? void 0 : _formFilter$dataset5.value,\n      groupby: formFilter == null ? void 0 : formFilter.column,\n      ...formFilter });\n\n    setNativeFilterFieldValuesWrapper({\n      defaultValueQueriesData: null,\n      isDataDirty: false });\n\n    getChartDataRequest({\n      formData,\n      force,\n      requestParams: { dashboardId: 0 } }).\n\n    then(({ response, json }) => {\n      if (isFeatureEnabled(FeatureFlag.GLOBAL_ASYNC_QUERIES)) {\n        // deal with getChartDataRequest transforming the response data\n        const result = 'result' in json ? json.result[0] : json;\n        if (response.status === 200) {\n          setNativeFilterFieldValuesWrapper({\n            defaultValueQueriesData: [result] });\n\n        } else\n        if (response.status === 202) {\n          waitForAsyncData(result).\n          then((asyncResult) => {\n            setNativeFilterFieldValuesWrapper({\n              defaultValueQueriesData: asyncResult });\n\n          }).\n          catch((error) => {\n            setError(error.message || error.error || t('Check configuration'));\n          });\n        } else\n        {\n          throw new Error(`Received unexpected response status (${response.status}) while fetching chart data`);\n        }\n      } else\n      {\n        setNativeFilterFieldValuesWrapper({\n          defaultValueQueriesData: json.result });\n\n      }\n    }).\n    catch((error) => {\n      error.json().then((body) => {\n        setErrorWrapper(body.message || error.statusText || t('Check configuration'));\n      });\n    });\n  }, [filterId, forceUpdate, form, formFilter, hasDataset]);\n  const newFormData = getFormData({\n    datasetId,\n    groupby: hasColumn ? formFilter == null ? void 0 : formFilter.column : undefined,\n    ...formFilter });\n\n  const [hasDefaultValue, isRequired, defaultValueTooltip, setHasDefaultValue] = useDefaultValue(formFilter, filterToEdit);\n  const showDataset = !datasetId || datasetDetails || (formFilter == null ? void 0 : (_formFilter$dataset6 = formFilter.dataset) == null ? void 0 : _formFilter$dataset6.label);\n  const formChanged = useCallback(() => {\n    form.setFields([\n    {\n      name: 'changed',\n      value: true }]);\n\n\n  }, [form]);\n  const updateFormValues = useCallback((values) => {\n    setNativeFilterFieldValues(form, filterId, values);\n    formChanged();\n  }, [filterId, form, formChanged]);\n  const hasPreFilter = !!(formFilter != null && formFilter.adhoc_filters) ||\n  !!(formFilter != null && formFilter.time_range) ||\n  !!(filterToEdit != null && (_filterToEdit$adhoc_f = filterToEdit.adhoc_filters) != null && _filterToEdit$adhoc_f.length) ||\n  !!(filterToEdit != null && filterToEdit.time_range);\n  const hasSorting = typeof (formFilter == null ? void 0 : (_formFilter$controlVa = formFilter.controlValues) == null ? void 0 : _formFilter$controlVa.sortAscending) === 'boolean' ||\n  typeof (filterToEdit == null ? void 0 : (_filterToEdit$control = filterToEdit.controlValues) == null ? void 0 : _filterToEdit$control.sortAscending) === 'boolean';\n  let sort = filterToEdit == null ? void 0 : (_filterToEdit$control2 = filterToEdit.controlValues) == null ? void 0 : _filterToEdit$control2.sortAscending;\n  if (typeof (formFilter == null ? void 0 : (_formFilter$controlVa2 = formFilter.controlValues) == null ? void 0 : _formFilter$controlVa2.sortAscending) === 'boolean') {\n    sort = formFilter.controlValues.sortAscending;\n  }\n  const showDefaultValue = !hasDataset ||\n  !isDataDirty && hasFilledDataset ||\n  !mainControlItems.groupby;\n  const onSortChanged = (value) => {var _form$getFieldValue2;\n    const previous = (_form$getFieldValue2 = form.getFieldValue('filters')) == null ? void 0 : _form$getFieldValue2[filterId].controlValues;\n    setNativeFilterFieldValues(form, filterId, {\n      controlValues: {\n        ...previous,\n        sortAscending: value } });\n\n\n    forceUpdate();\n  };\n  const validatePreFilter = () => setTimeout(() => form.validateFields([\n  ['filters', filterId, 'adhoc_filters'],\n  ['filters', filterId, 'time_range']]),\n  0);\n  const hasTimeRange = (formFilter == null ? void 0 : formFilter.time_range) && formFilter.time_range !== 'No filter';\n  const hasAdhoc = (formFilter == null ? void 0 : (_formFilter$adhoc_fil = formFilter.adhoc_filters) == null ? void 0 : _formFilter$adhoc_fil.length) > 0;\n  const defaultToFirstItem = formFilter == null ? void 0 : (_formFilter$controlVa3 = formFilter.controlValues) == null ? void 0 : _formFilter$controlVa3.defaultToFirstItem;\n  const hasAdvancedSection = (formFilter == null ? void 0 : formFilter.filterType) === 'filter_select' ||\n  (formFilter == null ? void 0 : formFilter.filterType) === 'filter_range';\n  const initialDefaultValue = (formFilter == null ? void 0 : formFilter.filterType) === (filterToEdit == null ? void 0 : filterToEdit.filterType) ?\n  filterToEdit == null ? void 0 : filterToEdit.defaultDataMask :\n  null;\n  const preFilterValidator = () => {\n    if (hasTimeRange || hasAdhoc) {\n      return Promise.resolve();\n    }\n    return Promise.reject(new Error(t('Pre-filter is required')));\n  };\n  const ParentSelect = ({ value, ...rest }) => {\n    const parentId = value == null ? void 0 : value.value;\n    const isParentRemoved = parentId && removedFilters[parentId];\n    let options = parentFilterOptions;\n    if (isParentRemoved) {\n      options = [\n      { label: t('(deleted)'), value: parentId },\n      ...parentFilterOptions];\n\n    }\n    return ___EmotionJSX(Select, _extends({ ariaLabel: t('Parent filter'), placeholder: t('None'), options: options, allowClear: true, value: parentId }, rest));\n  };\n  useEffect(() => {\n    if (datasetId) {\n      cachedSupersetGet({\n        endpoint: `/api/v1/dataset/${datasetId}` }).\n\n      then((response) => {var _response$json, _response$json$result, _response$json2;\n        setMetrics((_response$json = response.json) == null ? void 0 : (_response$json$result = _response$json.result) == null ? void 0 : _response$json$result.metrics);\n        const dataset = (_response$json2 = response.json) == null ? void 0 : _response$json2.result;\n        // modify the response to fit structure expected by AdhocFilterControl\n        dataset.type = dataset.datasource_type;\n        dataset.filter_select = true;\n        setDatasetDetails(dataset);\n      }).\n      catch((response) => {\n        addDangerToast(response.message);\n      });\n    }\n  }, [datasetId]);\n  useImperativeHandle(ref, () => ({\n    changeTab(tab) {\n      setActiveTabKey(tab);\n    } }));\n\n  useBackendFormUpdate(form, filterId);\n  useEffect(() => {\n    if (hasDataset && hasFilledDataset && hasDefaultValue && isDataDirty) {\n      refreshHandler();\n    }\n  }, [\n  hasDataset,\n  hasFilledDataset,\n  hasDefaultValue,\n  isDataDirty,\n  refreshHandler,\n  showDataset]);\n\n  useEffect(() => {\n    // Run only once when the control items are available\n    if (!activeFilterPanelKey && !_isEmpty(controlItems)) {\n      const hasCheckedAdvancedControl = hasParentFilter ||\n      hasPreFilter ||\n      hasSorting ||\n      Object.keys(controlItems).\n      filter((key) => !BASIC_CONTROL_ITEMS.includes(key)).\n      some((key) => controlItems[key].checked);\n      setActiveFilterPanelKey(hasCheckedAdvancedControl ?\n      [FilterPanels.basic.key, FilterPanels.advanced.key] :\n      FilterPanels.basic.key);\n    }\n  }, [\n  activeFilterPanelKey,\n  hasParentFilter,\n  hasPreFilter,\n  hasSorting,\n  controlItems]);\n\n  const initiallyExcludedCharts = useMemo(() => {var _formFilter$dataset7;\n    const excluded = [];\n    if ((formFilter == null ? void 0 : (_formFilter$dataset7 = formFilter.dataset) == null ? void 0 : _formFilter$dataset7.value) === undefined) {\n      return [];\n    }\n    Object.values(charts).forEach((chart) => {var _chart$formData, _loadedDatasets$chart, _formFilter$dataset8;\n      const chartDatasetUid = (_chart$formData = chart.formData) == null ? void 0 : _chart$formData.datasource;\n      if (chartDatasetUid === undefined) {\n        return;\n      }\n      if (((_loadedDatasets$chart = loadedDatasets[chartDatasetUid]) == null ? void 0 : _loadedDatasets$chart.id) !== (formFilter == null ? void 0 : (_formFilter$dataset8 = formFilter.dataset) == null ? void 0 : _formFilter$dataset8.value)) {\n        excluded.push(chart.id);\n      }\n    });\n    return excluded;\n  }, [\n  JSON.stringify(charts),\n  formFilter == null ? void 0 : (_formFilter$dataset9 = formFilter.dataset) == null ? void 0 : _formFilter$dataset9.value,\n  JSON.stringify(loadedDatasets)]);\n\n  useEffect(() => {\n    // just removed, saving current form items for eventual undo\n    if (isRemoved) {\n      setUndoFormValues(formValues);\n    }\n  }, [isRemoved]);\n  useEffect(() => {\n    // the filter was just restored after undo\n    if (undoFormValues && !isRemoved) {\n      setNativeFilterFieldValues(form, filterId, undoFormValues);\n      setUndoFormValues(null);\n    }\n  }, [formValues, filterId, form, isRemoved, undoFormValues]);\n  if (isRemoved) {\n    return ___EmotionJSX(RemovedFilter, { onClick: () => restoreFilter(filterId) });\n  }\n  return ___EmotionJSX(StyledTabs, { activeKey: activeTabKey, onChange: (activeKey) => setActiveTabKey(activeKey), centered: true },\n  ___EmotionJSX(TabPane, { tab: FilterTabs.configuration.name, key: FilterTabs.configuration.key, forceRender: true },\n  ___EmotionJSX(StyledContainer, null,\n  ___EmotionJSX(StyledFormItem, { name: ['filters', filterId, 'type'], hidden: true, initialValue: NativeFilterType.NATIVE_FILTER },\n  ___EmotionJSX(Input, null)),\n\n  ___EmotionJSX(StyledFormItem, { name: ['filters', filterId, 'name'], label: ___EmotionJSX(StyledLabel, null, t('Filter name')), initialValue: filterToEdit == null ? void 0 : filterToEdit.name, rules: [{ required: !isRemoved, message: t('Name is required') }] },\n  ___EmotionJSX(Input, getFiltersConfigModalTestId('name-input'))),\n\n  ___EmotionJSX(StyledFormItem, _extends({ name: ['filters', filterId, 'filterType'], rules: [{ required: !isRemoved, message: t('Name is required') }], initialValue: (filterToEdit == null ? void 0 : filterToEdit.filterType) || 'filter_select', label: ___EmotionJSX(StyledLabel, null, t('Filter Type')) }, getFiltersConfigModalTestId('filter-type')),\n  ___EmotionJSX(Select, { ariaLabel: t('Filter type'), options: nativeFilterVizTypes.map((filterType) => {var _nativeFilterItems$fi, _FILTER_SUPPORTED_TYP, _FILTER_SUPPORTED_TYP2;\n      // @ts-ignore\n      const name = (_nativeFilterItems$fi = nativeFilterItems[filterType]) == null ? void 0 : _nativeFilterItems$fi.value.name;\n      const mappedName = name ?\n      FILTER_TYPE_NAME_MAPPING[name] :\n      undefined;\n      const isDisabled = ((_FILTER_SUPPORTED_TYP = FILTER_SUPPORTED_TYPES[filterType]) == null ? void 0 : _FILTER_SUPPORTED_TYP.length) === 1 && ((_FILTER_SUPPORTED_TYP2 =\n      FILTER_SUPPORTED_TYPES[filterType]) == null ? void 0 : _FILTER_SUPPORTED_TYP2.includes(GenericDataType.TEMPORAL)) &&\n      !doLoadedDatasetsHaveTemporalColumns;\n      return {\n        value: filterType,\n        label: mappedName || name,\n        customLabel: isDisabled ? ___EmotionJSX(Tooltip, { title: t('Datasets do not contain a temporal column') },\n        mappedName || name) :\n        undefined,\n        disabled: isDisabled };\n\n    }), onChange: (value) => {\n      setNativeFilterFieldValues(form, filterId, {\n        filterType: value,\n        defaultDataMask: null,\n        column: null });\n\n      forceUpdate();\n    } }))),\n\n\n  hasDataset && ___EmotionJSX(StyledRowContainer, null,\n  showDataset ? ___EmotionJSX(StyledFormItem, _extends({ name: ['filters', filterId, 'dataset'], label: ___EmotionJSX(StyledLabel, null, t('Dataset')), initialValue: datasetDetails ?\n    {\n      label: datasetDetails.table_name,\n      value: datasetDetails.id } :\n\n    undefined, rules: [\n    { required: !isRemoved, message: t('Dataset is required') }] },\n  getFiltersConfigModalTestId('datasource-input')),\n  ___EmotionJSX(DatasetSelect, { onChange: (value) => {\n      // We need to reset the column when the dataset has changed\n      if (value.value !== datasetId) {\n        setNativeFilterFieldValues(form, filterId, {\n          dataset: value,\n          defaultDataMask: null,\n          column: null });\n\n      }\n      forceUpdate();\n    } })) :\n  ___EmotionJSX(StyledFormItem, { label: ___EmotionJSX(StyledLabel, null, t('Dataset')) },\n  ___EmotionJSX(Loading, { position: \"inline-centered\" })),\n\n  hasDataset &&\n  Object.keys(mainControlItems).map((key) => mainControlItems[key].element)),\n\n  ___EmotionJSX(StyledCollapse, { activeKey: activeFilterPanelKey, onChange: (key) => setActiveFilterPanelKey(key), expandIconPosition: \"right\" },\n  ___EmotionJSX(Collapse.Panel, { forceRender: true, header: FilterPanels.basic.name, key: FilterPanels.basic.key },\n  ___EmotionJSX(CleanFormItem, { name: ['filters', filterId, 'defaultValueQueriesData'], hidden: true, initialValue: null }),\n  ___EmotionJSX(CleanFormItem, { name: ['filters', filterId, 'defaultValue'] },\n  ___EmotionJSX(CollapsibleControl, { checked: hasDefaultValue, disabled: isRequired || defaultToFirstItem, initialValue: hasDefaultValue, title: t('Filter has default value'), tooltip: defaultValueTooltip, onChange: (value) => {\n      setHasDefaultValue(value);\n      formChanged();\n    } },\n  !isRemoved && ___EmotionJSX(StyledRowSubFormItem, { name: ['filters', filterId, 'defaultDataMask'], initialValue: initialDefaultValue, label: ___EmotionJSX(StyledLabel, null, t('Default Value')), required: hasDefaultValue, rules: [\n    {\n      validator: () => {var _formFilter$defaultDa, _formFilter$defaultDa2;\n        if (formFilter != null && (_formFilter$defaultDa = formFilter.defaultDataMask) != null && (_formFilter$defaultDa2 = _formFilter$defaultDa.filterState) != null && _formFilter$defaultDa2.value) {\n          // requires managing the error as the DefaultValue\n          // component does not use an Antdesign compatible input\n          const formValidationFields = form.getFieldsError();\n          setErroredFilters((prevErroredFilters) => {\n            if (prevErroredFilters.length &&\n            !formValidationFields.find((f) => f.errors.length > 0)) {\n              return [];\n            }\n            return prevErroredFilters;\n          });\n          return Promise.resolve();\n        }\n        setErroredFilters((prevErroredFilters) => {\n          if (prevErroredFilters.includes(filterId)) {\n            return prevErroredFilters;\n          }\n          return [...prevErroredFilters, filterId];\n        });\n        return Promise.reject(new Error(t('Default value is required')));\n      } }] },\n\n\n  error ? ___EmotionJSX(BasicErrorAlert, { title: t('Cannot load filter'), body: error, level: \"error\" }) : showDefaultValue ? ___EmotionJSX(DefaultValueContainer, null,\n  ___EmotionJSX(DefaultValue, { setDataMask: (dataMask) => {var _initialDefaultValue$, _dataMask$filterState;\n      if (!_isEqual(initialDefaultValue == null ? void 0 : (_initialDefaultValue$ = initialDefaultValue.filterState) == null ? void 0 : _initialDefaultValue$.value, dataMask == null ? void 0 : (_dataMask$filterState = dataMask.filterState) == null ? void 0 : _dataMask$filterState.value)) {\n        formChanged();\n      }\n      setNativeFilterFieldValues(form, filterId, {\n        defaultDataMask: dataMask });\n\n      form.validateFields([\n      ['filters', filterId, 'defaultDataMask']]);\n\n      forceUpdate();\n    }, hasDefaultValue: hasDefaultValue, filterId: filterId, hasDataset: hasDataset, form: form, formData: newFormData, enableNoResults: enableNoResults }),\n  hasDataset && datasetId && ___EmotionJSX(Tooltip, { title: t('Refresh the default values') },\n  ___EmotionJSX(RefreshIcon, { onClick: () => refreshHandler(true) }))) :\n\n  t('Fill all required fields to enable \"Default Value\"')))),\n\n\n\n  Object.keys(controlItems).\n  filter((key) => BASIC_CONTROL_ITEMS.includes(key)).\n  map((key) => controlItems[key].element)),\n\n  hasAdvancedSection && ___EmotionJSX(Collapse.Panel, { forceRender: true, header: FilterPanels.advanced.name, key: FilterPanels.advanced.key },\n  isCascadingFilter && ___EmotionJSX(CleanFormItem, { name: ['filters', filterId, 'hierarchicalFilter'] },\n  ___EmotionJSX(CollapsibleControl, { title: t('Filter is hierarchical'), initialValue: hasParentFilter, onChange: (checked) => {\n      formChanged();\n      if (checked) {\n        // execute after render\n        setTimeout(() => form.validateFields([\n        ['filters', filterId, 'parentFilter']]),\n        0);\n      }\n    } },\n  ___EmotionJSX(StyledRowSubFormItem, { name: ['filters', filterId, 'parentFilter'], label: ___EmotionJSX(StyledLabel, null, t('Parent filter')), initialValue: parentFilter, normalize: (value) => value ? { value } : undefined, required: true, rules: [\n    {\n      required: true,\n      message: t('Parent filter is required') }] },\n\n\n  ___EmotionJSX(ParentSelect, null)))),\n\n\n\n  Object.keys(controlItems).\n  filter((key) => !BASIC_CONTROL_ITEMS.includes(key)).\n  map((key) => controlItems[key].element),\n  hasDataset && hasAdditionalFilters && ___EmotionJSX(CleanFormItem, { name: ['filters', filterId, 'preFilter'] },\n  ___EmotionJSX(CollapsibleControl, { initialValue: hasPreFilter, title: t('Pre-filter available values'), onChange: (checked) => {\n      formChanged();\n      if (checked) {\n        validatePreFilter();\n      }\n    } },\n  ___EmotionJSX(StyledRowSubFormItem, { name: ['filters', filterId, 'adhoc_filters'], initialValue: filterToEdit == null ? void 0 : filterToEdit.adhoc_filters, required: true, rules: [\n    {\n      validator: preFilterValidator }] },\n\n\n  ___EmotionJSX(AdhocFilterControl, { columns: (datasetDetails == null ? void 0 : (_datasetDetails$colum = datasetDetails.columns) == null ? void 0 : _datasetDetails$colum.filter((c) => c.filterable)) || [], savedMetrics: (datasetDetails == null ? void 0 : datasetDetails.metrics) || [], datasource: datasetDetails, onChange: (filters) => {\n      setNativeFilterFieldValues(form, filterId, {\n        adhoc_filters: filters });\n\n      forceUpdate();\n      validatePreFilter();\n    }, label: ___EmotionJSX(\"span\", null,\n    ___EmotionJSX(StyledLabel, null, t('Pre-filter')),\n    !hasTimeRange && ___EmotionJSX(StyledAsterisk, null)) })),\n\n\n  showTimeRangePicker && ___EmotionJSX(StyledRowFormItem, { name: ['filters', filterId, 'time_range'], label: ___EmotionJSX(StyledLabel, null, t('Time range')), initialValue: (filterToEdit == null ? void 0 : filterToEdit.time_range) || 'No filter', required: !hasAdhoc, rules: [\n    {\n      validator: preFilterValidator }] },\n\n\n  ___EmotionJSX(DateFilterControl, { name: \"time_range\", endpoints: ['inclusive', 'exclusive'], onChange: (timeRange) => {\n      setNativeFilterFieldValues(form, filterId, {\n        time_range: timeRange });\n\n      forceUpdate();\n      validatePreFilter();\n    } })),\n\n  hasTimeRange && ___EmotionJSX(StyledRowFormItem, { name: ['filters', filterId, 'granularity_sqla'], label: ___EmotionJSX(React.Fragment, null,\n    ___EmotionJSX(StyledLabel, null, t('Time column')), \"\\xA0\",\n    ___EmotionJSX(InfoTooltipWithTrigger, { placement: \"top\", tooltip: t('Optional time column if time range should apply to another column than the default time column') })),\n    initialValue: filterToEdit == null ? void 0 : filterToEdit.granularity_sqla },\n  ___EmotionJSX(ColumnSelect, { allowClear: true, form: form, formField: \"granularity_sqla\", filterId: filterId, filterValues: (column) => !!column.is_dttm, datasetId: datasetId, onChange: (column) => {\n      // We need reset default value when when column changed\n      setNativeFilterFieldValues(form, filterId, {\n        granularity_sqla: column });\n\n      forceUpdate();\n    } })))),\n\n\n\n  (formFilter == null ? void 0 : formFilter.filterType) !== 'filter_range' && ___EmotionJSX(CleanFormItem, { name: ['filters', filterId, 'sortFilter'] },\n  ___EmotionJSX(CollapsibleControl, { initialValue: hasSorting, title: t('Sort filter values'), onChange: (checked) => {\n      onSortChanged(checked || undefined);\n      formChanged();\n    } },\n  ___EmotionJSX(StyledRowFormItem, { name: [\n    'filters',\n    filterId,\n    'controlValues',\n    'sortAscending'],\n    initialValue: sort, label: ___EmotionJSX(StyledLabel, null, t('Sort type')) },\n  ___EmotionJSX(Radio.Group, { onChange: (value) => {\n      onSortChanged(value.target.value);\n    } },\n  ___EmotionJSX(Radio, { value: true }, t('Sort ascending')),\n  ___EmotionJSX(Radio, { value: false }, t('Sort descending')))),\n\n\n  hasMetrics && ___EmotionJSX(StyledRowSubFormItem, { name: ['filters', filterId, 'sortMetric'], initialValue: filterToEdit == null ? void 0 : filterToEdit.sortMetric, label: ___EmotionJSX(React.Fragment, null,\n    ___EmotionJSX(StyledLabel, null, t('Sort Metric')), \"\\xA0\",\n    ___EmotionJSX(InfoTooltipWithTrigger, { placement: \"top\", tooltip: t('If a metric is specified, sorting will be done based on the metric value') })) },\n\n  ___EmotionJSX(Select, { allowClear: true, ariaLabel: t('Sort metric'), name: \"sortMetric\", options: metrics.map((metric) => {var _metric$verbose_name;return {\n        value: metric.metric_name,\n        label: (_metric$verbose_name = metric.verbose_name) != null ? _metric$verbose_name : metric.metric_name };}),\n    onChange: (value) => {\n      if (value !== undefined) {\n        setNativeFilterFieldValues(form, filterId, {\n          sortMetric: value });\n\n        forceUpdate();\n      }\n    } }))))))),\n\n\n\n\n\n\n  ___EmotionJSX(TabPane, { tab: FilterTabs.scoping.name, key: FilterTabs.scoping.key, forceRender: true },\n  ___EmotionJSX(FilterScope, { updateFormValues: updateFormValues, pathToFormValue: ['filters', filterId], forceUpdate: forceUpdate, filterScope: filterToEdit == null ? void 0 : filterToEdit.scope, formFilterScope: formFilter == null ? void 0 : formFilter.scope, formScopingType: formFilter == null ? void 0 : formFilter.scoping, initiallyExcludedCharts: initiallyExcludedCharts })));\n\n\n};\nexport default /*#__PURE__*/forwardRef(FiltersConfigForm);","map":null,"metadata":{},"sourceType":"module"}