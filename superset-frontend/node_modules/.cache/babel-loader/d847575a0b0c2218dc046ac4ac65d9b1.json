{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { t } from '@superset-ui/core';\n\nimport getInitialState from './getInitialState';\nimport * as actions from '../actions/sqlLab';\nimport { now } from '../../modules/dates';\nimport {\naddToObject,\nalterInObject,\nalterInArr,\nremoveFromArr,\ngetFromArr,\naddToArr,\nextendArr } from\n'../../reduxUtils';\n\nexport default function sqlLabReducer(state = {}, action) {\n  const actionHandlers = {\n    [actions.ADD_QUERY_EDITOR]() {\n      const tabHistory = state.tabHistory.slice();\n      tabHistory.push(action.queryEditor.id);\n      const newState = { ...state, tabHistory };\n      return addToArr(newState, 'queryEditors', action.queryEditor);\n    },\n    [actions.QUERY_EDITOR_SAVED]() {\n      const { query, result } = action;\n      const existing = state.queryEditors.find((qe) => qe.id === query.id);\n      return alterInArr(\n      state,\n      'queryEditors',\n      existing,\n      {\n        remoteId: result.remoteId,\n        title: query.title },\n\n      'id');\n\n    },\n    [actions.UPDATE_QUERY_EDITOR]() {\n      const id = action.alterations.remoteId;\n      const existing = state.queryEditors.find((qe) => qe.remoteId === id);\n      if (existing == null) return state;\n      return alterInArr(\n      state,\n      'queryEditors',\n      existing,\n      action.alterations,\n      'remoteId');\n\n    },\n    [actions.CLONE_QUERY_TO_NEW_TAB]() {\n      const progenitor = state.queryEditors.find(\n      (qe) => qe.id === state.tabHistory[state.tabHistory.length - 1]);\n\n      const qe = {\n        remoteId: progenitor.remoteId,\n        title: t('Copy of %s', progenitor.title),\n        dbId: action.query.dbId ? action.query.dbId : null,\n        schema: action.query.schema ? action.query.schema : null,\n        autorun: true,\n        sql: action.query.sql,\n        queryLimit: action.query.queryLimit,\n        maxRow: action.query.maxRow };\n\n      return sqlLabReducer(state, actions.addQueryEditor(qe));\n    },\n    [actions.REMOVE_QUERY_EDITOR]() {\n      let newState = removeFromArr(state, 'queryEditors', action.queryEditor);\n      // List of remaining queryEditor ids\n      const qeIds = newState.queryEditors.map((qe) => qe.id);\n\n      const queries = {};\n      Object.keys(state.queries).forEach((k) => {\n        const query = state.queries[k];\n        if (qeIds.indexOf(query.sqlEditorId) > -1) {\n          queries[k] = query;\n        }\n      });\n\n      let tabHistory = state.tabHistory.slice();\n      tabHistory = tabHistory.filter((id) => qeIds.indexOf(id) > -1);\n\n      // Remove associated table schemas\n      const tables = state.tables.filter(\n      (table) => table.queryEditorId !== action.queryEditor.id);\n\n\n      newState = { ...newState, tabHistory, tables, queries };\n      return newState;\n    },\n    [actions.REMOVE_QUERY]() {\n      const newQueries = { ...state.queries };\n      delete newQueries[action.query.id];\n      return { ...state, queries: newQueries };\n    },\n    [actions.RESET_STATE]() {\n      return { ...getInitialState() };\n    },\n    [actions.MERGE_TABLE]() {\n      const at = { ...action.table };\n      let existingTable;\n      state.tables.forEach((xt) => {\n        if (\n        xt.dbId === at.dbId &&\n        xt.queryEditorId === at.queryEditorId &&\n        xt.schema === at.schema &&\n        xt.name === at.name)\n        {\n          existingTable = xt;\n        }\n      });\n      if (existingTable) {\n        if (action.query) {\n          at.dataPreviewQueryId = action.query.id;\n        }\n        return alterInArr(state, 'tables', existingTable, at);\n      }\n      // for new table, associate Id of query for data preview\n      at.dataPreviewQueryId = null;\n      let newState = addToArr(state, 'tables', at);\n      if (action.query) {\n        newState = alterInArr(newState, 'tables', at, {\n          dataPreviewQueryId: action.query.id });\n\n      }\n      return newState;\n    },\n    [actions.EXPAND_TABLE]() {\n      return alterInArr(state, 'tables', action.table, { expanded: true });\n    },\n    [actions.REMOVE_DATA_PREVIEW]() {\n      const queries = { ...state.queries };\n      delete queries[action.table.dataPreviewQueryId];\n      const newState = alterInArr(state, 'tables', action.table, {\n        dataPreviewQueryId: null });\n\n      return { ...newState, queries };\n    },\n    [actions.CHANGE_DATA_PREVIEW_ID]() {\n      const queries = { ...state.queries };\n      delete queries[action.oldQueryId];\n\n      const newTables = [];\n      state.tables.forEach((xt) => {\n        if (xt.dataPreviewQueryId === action.oldQueryId) {\n          newTables.push({ ...xt, dataPreviewQueryId: action.newQuery.id });\n        } else {\n          newTables.push(xt);\n        }\n      });\n      return {\n        ...state,\n        queries,\n        tables: newTables,\n        activeSouthPaneTab: action.newQuery.id };\n\n    },\n    [actions.COLLAPSE_TABLE]() {\n      return alterInArr(state, 'tables', action.table, { expanded: false });\n    },\n    [actions.REMOVE_TABLE]() {\n      return removeFromArr(state, 'tables', action.table);\n    },\n    [actions.START_QUERY_VALIDATION]() {\n      let newState = { ...state };\n      const sqlEditor = { id: action.query.sqlEditorId };\n      newState = alterInArr(newState, 'queryEditors', sqlEditor, {\n        validationResult: {\n          id: action.query.id,\n          errors: [],\n          completed: false } });\n\n\n      return newState;\n    },\n    [actions.QUERY_VALIDATION_RETURNED]() {\n      // If the server is very slow about answering us, we might get validation\n      // responses back out of order. This check confirms the response we're\n      // handling corresponds to the most recently dispatched request.\n      //\n      // We don't care about any but the most recent because validations are\n      // only valid for the SQL text they correspond to -- once the SQL has\n      // changed, the old validation doesn't tell us anything useful anymore.\n      const qe = getFromArr(state.queryEditors, action.query.sqlEditorId);\n      if (qe.validationResult.id !== action.query.id) {\n        return state;\n      }\n      // Otherwise, persist the results on the queryEditor state\n      let newState = { ...state };\n      const sqlEditor = { id: action.query.sqlEditorId };\n      newState = alterInArr(newState, 'queryEditors', sqlEditor, {\n        validationResult: {\n          id: action.query.id,\n          errors: action.results,\n          completed: true } });\n\n\n      return newState;\n    },\n    [actions.QUERY_VALIDATION_FAILED]() {\n      // If the server is very slow about answering us, we might get validation\n      // responses back out of order. This check confirms the response we're\n      // handling corresponds to the most recently dispatched request.\n      //\n      // We don't care about any but the most recent because validations are\n      // only valid for the SQL text they correspond to -- once the SQL has\n      // changed, the old validation doesn't tell us anything useful anymore.\n      const qe = getFromArr(state.queryEditors, action.query.sqlEditorId);\n      if (qe.validationResult.id !== action.query.id) {\n        return state;\n      }\n      // Otherwise, persist the results on the queryEditor state\n      let newState = { ...state };\n      const sqlEditor = { id: action.query.sqlEditorId };\n      newState = alterInArr(newState, 'queryEditors', sqlEditor, {\n        validationResult: {\n          id: action.query.id,\n          errors: [\n          {\n            line_number: 1,\n            start_column: 1,\n            end_column: 1,\n            message: `The server failed to validate your query.\\n${action.message}` }],\n\n\n          completed: true } });\n\n\n      return newState;\n    },\n    [actions.COST_ESTIMATE_STARTED]() {\n      let newState = { ...state };\n      const sqlEditor = { id: action.query.sqlEditorId };\n      newState = alterInArr(newState, 'queryEditors', sqlEditor, {\n        queryCostEstimate: {\n          completed: false,\n          cost: null,\n          error: null } });\n\n\n      return newState;\n    },\n    [actions.COST_ESTIMATE_RETURNED]() {\n      let newState = { ...state };\n      const sqlEditor = { id: action.query.sqlEditorId };\n      newState = alterInArr(newState, 'queryEditors', sqlEditor, {\n        queryCostEstimate: {\n          completed: true,\n          cost: action.json,\n          error: null } });\n\n\n      return newState;\n    },\n    [actions.COST_ESTIMATE_FAILED]() {\n      let newState = { ...state };\n      const sqlEditor = { id: action.query.sqlEditorId };\n      newState = alterInArr(newState, 'queryEditors', sqlEditor, {\n        queryCostEstimate: {\n          completed: false,\n          cost: null,\n          error: action.error } });\n\n\n      return newState;\n    },\n    [actions.START_QUERY]() {\n      let newState = { ...state };\n      if (action.query.sqlEditorId) {\n        const qe = getFromArr(state.queryEditors, action.query.sqlEditorId);\n        if (qe.latestQueryId && state.queries[qe.latestQueryId]) {\n          const newResults = {\n            ...state.queries[qe.latestQueryId].results,\n            data: [],\n            query: null };\n\n          const q = { ...state.queries[qe.latestQueryId], results: newResults };\n          const queries = { ...state.queries, [q.id]: q };\n          newState = { ...state, queries };\n        }\n      } else {\n        newState.activeSouthPaneTab = action.query.id;\n      }\n      newState = addToObject(newState, 'queries', action.query);\n      const sqlEditor = { id: action.query.sqlEditorId };\n      return alterInArr(newState, 'queryEditors', sqlEditor, {\n        latestQueryId: action.query.id });\n\n    },\n    [actions.STOP_QUERY]() {\n      return alterInObject(state, 'queries', action.query, {\n        state: 'stopped',\n        results: [] });\n\n    },\n    [actions.CLEAR_QUERY_RESULTS]() {\n      const newResults = { ...action.query.results };\n      newResults.data = [];\n      return alterInObject(state, 'queries', action.query, {\n        results: newResults,\n        cached: true });\n\n    },\n    [actions.REQUEST_QUERY_RESULTS]() {\n      return alterInObject(state, 'queries', action.query, {\n        state: 'fetching' });\n\n    },\n    [actions.QUERY_SUCCESS]() {var _action$results, _action$results$data, _action$results2, _action$results2$quer, _action$results3, _action$results3$quer, _action$results4, _action$results4$quer;\n      // prevent race condition were query succeeds shortly after being canceled\n      if (action.query.state === 'stopped') {\n        return state;\n      }\n      const alts = {\n        endDttm: now(),\n        progress: 100,\n        results: action.results,\n        rows: action == null ? void 0 : (_action$results = action.results) == null ? void 0 : (_action$results$data = _action$results.data) == null ? void 0 : _action$results$data.length,\n        state: 'success',\n        limitingFactor: action == null ? void 0 : (_action$results2 = action.results) == null ? void 0 : (_action$results2$quer = _action$results2.query) == null ? void 0 : _action$results2$quer.limitingFactor,\n        tempSchema: action == null ? void 0 : (_action$results3 = action.results) == null ? void 0 : (_action$results3$quer = _action$results3.query) == null ? void 0 : _action$results3$quer.tempSchema,\n        tempTable: action == null ? void 0 : (_action$results4 = action.results) == null ? void 0 : (_action$results4$quer = _action$results4.query) == null ? void 0 : _action$results4$quer.tempTable,\n        errorMessage: null,\n        cached: false };\n\n      return alterInObject(state, 'queries', action.query, alts);\n    },\n    [actions.QUERY_FAILED]() {\n      if (action.query.state === 'stopped') {\n        return state;\n      }\n      const alts = {\n        state: 'failed',\n        errors: action.errors,\n        errorMessage: action.msg,\n        endDttm: now(),\n        link: action.link };\n\n      return alterInObject(state, 'queries', action.query, alts);\n    },\n    [actions.SET_ACTIVE_QUERY_EDITOR]() {\n      const qeIds = state.queryEditors.map((qe) => qe.id);\n      if (\n      qeIds.indexOf(action.queryEditor.id) > -1 &&\n      state.tabHistory[state.tabHistory.length - 1] !== action.queryEditor.id)\n      {\n        const tabHistory = state.tabHistory.slice();\n        tabHistory.push(action.queryEditor.id);\n        return { ...state, tabHistory };\n      }\n      return state;\n    },\n    [actions.LOAD_QUERY_EDITOR]() {\n      return alterInArr(state, 'queryEditors', action.queryEditor, {\n        ...action.queryEditor });\n\n    },\n    [actions.SET_TABLES]() {\n      return extendArr(state, 'tables', action.tables);\n    },\n    [actions.SET_ACTIVE_SOUTHPANE_TAB]() {\n      return { ...state, activeSouthPaneTab: action.tabId };\n    },\n    [actions.MIGRATE_QUERY_EDITOR]() {\n      // remove migrated query editor from localStorage\n      const { sqlLab } = JSON.parse(localStorage.getItem('redux'));\n      sqlLab.queryEditors = sqlLab.queryEditors.filter(\n      (qe) => qe.id !== action.oldQueryEditor.id);\n\n      localStorage.setItem('redux', JSON.stringify({ sqlLab }));\n\n      // replace localStorage query editor with the server backed one\n      return addToArr(\n      removeFromArr(state, 'queryEditors', action.oldQueryEditor),\n      'queryEditors',\n      action.newQueryEditor);\n\n    },\n    [actions.MIGRATE_TABLE]() {\n      // remove migrated table from localStorage\n      const { sqlLab } = JSON.parse(localStorage.getItem('redux'));\n      sqlLab.tables = sqlLab.tables.filter(\n      (table) => table.id !== action.oldTable.id);\n\n      localStorage.setItem('redux', JSON.stringify({ sqlLab }));\n\n      // replace localStorage table with the server backed one\n      return addToArr(\n      removeFromArr(state, 'tables', action.oldTable),\n      'tables',\n      action.newTable);\n\n    },\n    [actions.MIGRATE_TAB_HISTORY]() {\n      // remove migrated tab from localStorage tabHistory\n      const { sqlLab } = JSON.parse(localStorage.getItem('redux'));\n      sqlLab.tabHistory = sqlLab.tabHistory.filter(\n      (tabId) => tabId !== action.oldId);\n\n      localStorage.setItem('redux', JSON.stringify({ sqlLab }));\n      const tabHistory = state.tabHistory.filter(\n      (tabId) => tabId !== action.oldId);\n\n      tabHistory.push(action.newId);\n      return { ...state, tabHistory };\n    },\n    [actions.MIGRATE_QUERY]() {\n      const query = {\n        ...state.queries[action.queryId],\n        // point query to migrated query editor\n        sqlEditorId: action.queryEditorId };\n\n      const queries = { ...state.queries, [query.id]: query };\n      return { ...state, queries };\n    },\n    [actions.QUERY_EDITOR_SETDB]() {\n      return alterInArr(state, 'queryEditors', action.queryEditor, {\n        dbId: action.dbId });\n\n    },\n    [actions.QUERY_EDITOR_SET_FUNCTION_NAMES]() {\n      return alterInArr(state, 'queryEditors', action.queryEditor, {\n        functionNames: action.functionNames });\n\n    },\n    [actions.QUERY_EDITOR_SET_SCHEMA]() {\n      return alterInArr(state, 'queryEditors', action.queryEditor, {\n        schema: action.schema });\n\n    },\n    [actions.QUERY_EDITOR_SET_SCHEMA_OPTIONS]() {\n      return alterInArr(state, 'queryEditors', action.queryEditor, {\n        schemaOptions: action.options });\n\n    },\n    [actions.QUERY_EDITOR_SET_TABLE_OPTIONS]() {\n      return alterInArr(state, 'queryEditors', action.queryEditor, {\n        tableOptions: action.options });\n\n    },\n    [actions.QUERY_EDITOR_SET_TITLE]() {\n      return alterInArr(state, 'queryEditors', action.queryEditor, {\n        title: action.title });\n\n    },\n    [actions.QUERY_EDITOR_SET_SQL]() {\n      return alterInArr(state, 'queryEditors', action.queryEditor, {\n        sql: action.sql });\n\n    },\n    [actions.QUERY_EDITOR_SET_QUERY_LIMIT]() {\n      return alterInArr(state, 'queryEditors', action.queryEditor, {\n        queryLimit: action.queryLimit });\n\n    },\n    [actions.QUERY_EDITOR_SET_TEMPLATE_PARAMS]() {\n      return alterInArr(state, 'queryEditors', action.queryEditor, {\n        templateParams: action.templateParams });\n\n    },\n    [actions.QUERY_EDITOR_SET_SELECTED_TEXT]() {\n      return alterInArr(state, 'queryEditors', action.queryEditor, {\n        selectedText: action.sql });\n\n    },\n    [actions.QUERY_EDITOR_SET_AUTORUN]() {\n      return alterInArr(state, 'queryEditors', action.queryEditor, {\n        autorun: action.autorun });\n\n    },\n    [actions.QUERY_EDITOR_PERSIST_HEIGHT]() {\n      return alterInArr(state, 'queryEditors', action.queryEditor, {\n        northPercent: action.northPercent,\n        southPercent: action.southPercent });\n\n    },\n    [actions.QUERY_EDITOR_TOGGLE_LEFT_BAR]() {\n      return alterInArr(state, 'queryEditors', action.queryEditor, {\n        hideLeftBar: action.hideLeftBar });\n\n    },\n    [actions.SET_DATABASES]() {\n      const databases = {};\n      action.databases.forEach((db) => {\n        databases[db.id] = {\n          ...db,\n          extra_json: JSON.parse(db.extra || '') };\n\n      });\n      return { ...state, databases };\n    },\n    [actions.REFRESH_QUERIES]() {\n      let newQueries = { ...state.queries };\n      // Fetch the updates to the queries present in the store.\n      let change = false;\n      let { queriesLastUpdate } = state;\n      Object.entries(action.alteredQueries).forEach(([id, changedQuery]) => {\n        if (\n        !state.queries.hasOwnProperty(id) ||\n        state.queries[id].state !== 'stopped' &&\n        state.queries[id].state !== 'failed')\n        {var _state$queries$id;\n          if (changedQuery.changedOn > queriesLastUpdate) {\n            queriesLastUpdate = changedQuery.changedOn;\n          }\n          const prevState = (_state$queries$id = state.queries[id]) == null ? void 0 : _state$queries$id.state;\n          const currentState = changedQuery.state;\n          newQueries[id] = {\n            ...state.queries[id],\n            ...changedQuery,\n            // race condition:\n            // because of async behavior, sql lab may still poll a couple of seconds\n            // when it started fetching or finished rendering results\n            state:\n            currentState === 'success' &&\n            ['fetching', 'success'].includes(prevState) ?\n            prevState :\n            currentState };\n\n          change = true;\n        }\n      });\n      if (!change) {\n        newQueries = state.queries;\n      }\n      return { ...state, queries: newQueries, queriesLastUpdate };\n    },\n    [actions.SET_USER_OFFLINE]() {\n      return { ...state, offline: action.offline };\n    },\n    [actions.CREATE_DATASOURCE_STARTED]() {\n      return { ...state, isDatasourceLoading: true, errorMessage: null };\n    },\n    [actions.CREATE_DATASOURCE_SUCCESS]() {\n      return {\n        ...state,\n        isDatasourceLoading: false,\n        errorMessage: null,\n        datasource: action.datasource };\n\n    },\n    [actions.CREATE_DATASOURCE_FAILED]() {\n      return { ...state, isDatasourceLoading: false, errorMessage: action.err };\n    } };\n\n  if (action.type in actionHandlers) {\n    return actionHandlers[action.type]();\n  }\n  return state;\n}","map":null,"metadata":{},"sourceType":"module"}