{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint camelcase: 0 */\nimport { ActionCreators as UndoActionCreators } from 'redux-undo';\nimport { ensureIsArray, t, SupersetClient } from '@superset-ui/core';\nimport { addChart, removeChart, refreshChart } from 'src/chart/chartAction';\nimport { chart as initChart } from 'src/chart/chartReducer';\nimport { applyDefaultFormData } from 'src/explore/store';\nimport { getClientErrorObject } from 'src/utils/getClientErrorObject';\nimport { SAVE_TYPE_OVERWRITE } from 'src/dashboard/util/constants';\nimport {\naddSuccessToast,\naddWarningToast,\naddDangerToast } from\n'src/components/MessageToasts/actions';\nimport serializeActiveFilterValues from 'src/dashboard/util/serializeActiveFilterValues';\nimport serializeFilterScopes from 'src/dashboard/util/serializeFilterScopes';\nimport { getActiveFilters } from 'src/dashboard/util/activeDashboardFilters';\nimport { safeStringify } from 'src/utils/safeStringify';\nimport { FeatureFlag, isFeatureEnabled } from 'src/featureFlags';\nimport { UPDATE_COMPONENTS_PARENTS_LIST } from './dashboardLayout';\nimport {\nsetChartConfiguration,\ndashboardInfoChanged,\nSET_CHART_CONFIG_COMPLETE } from\n'./dashboardInfo';\nimport { fetchDatasourceMetadata } from './datasources';\nimport {\naddFilter,\nremoveFilter,\nupdateDirectPathToFilter } from\n'./dashboardFilters';\n\nexport const SET_UNSAVED_CHANGES = 'SET_UNSAVED_CHANGES';\nexport function setUnsavedChanges(hasUnsavedChanges) {\n  return { type: SET_UNSAVED_CHANGES, payload: { hasUnsavedChanges } };\n}\n\nexport const ADD_SLICE = 'ADD_SLICE';\nexport function addSlice(slice) {\n  return { type: ADD_SLICE, slice };\n}\n\nexport const REMOVE_SLICE = 'REMOVE_SLICE';\nexport function removeSlice(sliceId) {\n  return { type: REMOVE_SLICE, sliceId };\n}\n\nconst FAVESTAR_BASE_URL = '/superset/favstar/Dashboard';\nexport const TOGGLE_FAVE_STAR = 'TOGGLE_FAVE_STAR';\nexport function toggleFaveStar(isStarred) {\n  return { type: TOGGLE_FAVE_STAR, isStarred };\n}\n\nexport const FETCH_FAVE_STAR = 'FETCH_FAVE_STAR';\nexport function fetchFaveStar(id) {\n  return function fetchFaveStarThunk(dispatch) {\n    return SupersetClient.get({\n      endpoint: `${FAVESTAR_BASE_URL}/${id}/count/` }).\n\n    then(({ json }) => {\n      if (json.count > 0) dispatch(toggleFaveStar(true));\n    }).\n    catch(() =>\n    dispatch(\n    addDangerToast(\n    t(\n    'There was an issue fetching the favorite status of this dashboard.'))));\n\n\n\n\n  };\n}\n\nexport const SAVE_FAVE_STAR = 'SAVE_FAVE_STAR';\nexport function saveFaveStar(id, isStarred) {\n  return function saveFaveStarThunk(dispatch) {\n    const urlSuffix = isStarred ? 'unselect' : 'select';\n    return SupersetClient.get({\n      endpoint: `${FAVESTAR_BASE_URL}/${id}/${urlSuffix}/` }).\n\n    then(() => {\n      dispatch(toggleFaveStar(!isStarred));\n    }).\n    catch(() =>\n    dispatch(\n    addDangerToast(t('There was an issue favoriting this dashboard.'))));\n\n\n  };\n}\n\nexport const TOGGLE_PUBLISHED = 'TOGGLE_PUBLISHED';\nexport function togglePublished(isPublished) {\n  return { type: TOGGLE_PUBLISHED, isPublished };\n}\n\nexport function savePublished(id, isPublished) {\n  return function savePublishedThunk(dispatch) {\n    return SupersetClient.put({\n      endpoint: `/api/v1/dashboard/${id}`,\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        published: isPublished }) }).\n\n\n    then(() => {\n      const nowPublished = isPublished ? 'published' : 'hidden';\n      dispatch(addSuccessToast(t(`This dashboard is now ${nowPublished}`)));\n      dispatch(togglePublished(isPublished));\n    }).\n    catch(() => {\n      dispatch(\n      addDangerToast(\n      t('You do not have permissions to edit this dashboard.')));\n\n\n    });\n  };\n}\n\nexport const TOGGLE_EXPAND_SLICE = 'TOGGLE_EXPAND_SLICE';\nexport function toggleExpandSlice(sliceId) {\n  return { type: TOGGLE_EXPAND_SLICE, sliceId };\n}\n\nexport const UPDATE_CSS = 'UPDATE_CSS';\nexport function updateCss(css) {\n  return { type: UPDATE_CSS, css };\n}\n\nexport const SET_EDIT_MODE = 'SET_EDIT_MODE';\nexport function setEditMode(editMode) {\n  return { type: SET_EDIT_MODE, editMode };\n}\n\nexport const ON_CHANGE = 'ON_CHANGE';\nexport function onChange() {\n  return { type: ON_CHANGE };\n}\n\nexport const ON_SAVE = 'ON_SAVE';\nexport function onSave(lastModifiedTime) {\n  return { type: ON_SAVE, lastModifiedTime };\n}\n\nexport const SET_REFRESH_FREQUENCY = 'SET_REFRESH_FREQUENCY';\nexport function setRefreshFrequency(refreshFrequency, isPersistent = false) {\n  return { type: SET_REFRESH_FREQUENCY, refreshFrequency, isPersistent };\n}\n\nexport function saveDashboardRequestSuccess(lastModifiedTime) {\n  return (dispatch) => {\n    dispatch(onSave(lastModifiedTime));\n    // clear layout undo history\n    dispatch(UndoActionCreators.clearHistory());\n  };\n}\n\nexport function saveDashboardRequest(data, id, saveType) {\n  return (dispatch, getState) => {var _data$metadata, _data$metadata2, _data$metadata3, _data$metadata4, _data$metadata5, _data$metadata6;\n    dispatch({ type: UPDATE_COMPONENTS_PARENTS_LIST });\n\n    const { dashboardFilters, dashboardLayout } = getState();\n    const layout = dashboardLayout.present;\n    Object.values(dashboardFilters).forEach((filter) => {var _layout$componentId;\n      const { chartId } = filter;\n      const componentId = filter.directPathToFilter.slice().pop();\n      const directPathToFilter = (((_layout$componentId = layout[componentId]) == null ? void 0 : _layout$componentId.parents) || []).slice();\n      directPathToFilter.push(componentId);\n      dispatch(updateDirectPathToFilter(chartId, directPathToFilter));\n    });\n    // serialize selected values for each filter field, grouped by filter id\n    const serializedFilters = serializeActiveFilterValues(getActiveFilters());\n    // serialize filter scope for each filter field, grouped by filter id\n    const serializedFilterScopes = serializeFilterScopes(dashboardFilters);\n    const {\n      certified_by,\n      certification_details,\n      css,\n      dashboard_title,\n      owners,\n      roles,\n      slug } =\n    data;\n\n    const hasId = (item) => item.id !== undefined;\n\n    // making sure the data is what the backend expects\n    const cleanedData = {\n      ...data,\n      certified_by: certified_by || '',\n      certification_details:\n      certified_by && certification_details ? certification_details : '',\n      css: css || '',\n      dashboard_title: dashboard_title || t('[ untitled dashboard ]'),\n      owners: ensureIsArray(owners).map((o) => hasId(o) ? o.id : o),\n      roles: !isFeatureEnabled(FeatureFlag.DASHBOARD_RBAC) ?\n      undefined :\n      ensureIsArray(roles).map((r) => hasId(r) ? r.id : r),\n      slug: slug || null,\n      metadata: {\n        ...data.metadata,\n        color_namespace: ((_data$metadata = data.metadata) == null ? void 0 : _data$metadata.color_namespace) || undefined,\n        color_scheme: ((_data$metadata2 = data.metadata) == null ? void 0 : _data$metadata2.color_scheme) || '',\n        expanded_slices: ((_data$metadata3 = data.metadata) == null ? void 0 : _data$metadata3.expanded_slices) || {},\n        label_colors: ((_data$metadata4 = data.metadata) == null ? void 0 : _data$metadata4.label_colors) || {},\n        refresh_frequency: ((_data$metadata5 = data.metadata) == null ? void 0 : _data$metadata5.refresh_frequency) || 0,\n        timed_refresh_immune_slices:\n        ((_data$metadata6 = data.metadata) == null ? void 0 : _data$metadata6.timed_refresh_immune_slices) || [] } };\n\n\n\n    const handleChartConfiguration = () => {\n      const {\n        dashboardInfo: {\n          metadata: { chart_configuration = {} } } } =\n\n      getState();\n      const chartConfiguration = Object.values(chart_configuration).reduce(\n      (prev, next) => {\n        // If chart removed from dashboard - remove it from metadata\n        if (\n        Object.values(layout).find(\n        (layoutItem) => {var _layoutItem$meta;return (layoutItem == null ? void 0 : (_layoutItem$meta = layoutItem.meta) == null ? void 0 : _layoutItem$meta.chartId) === next.id;}))\n\n        {\n          return { ...prev, [next.id]: next };\n        }\n        return prev;\n      },\n      {});\n\n      return chartConfiguration;\n    };\n\n    const onCopySuccess = (response) => {\n      const lastModifiedTime = response.json.last_modified_time;\n      if (lastModifiedTime) {\n        dispatch(saveDashboardRequestSuccess(lastModifiedTime));\n      }\n      if (isFeatureEnabled(FeatureFlag.DASHBOARD_CROSS_FILTERS)) {\n        const chartConfiguration = handleChartConfiguration();\n        dispatch(setChartConfiguration(chartConfiguration));\n      }\n      dispatch(addSuccessToast(t('This dashboard was saved successfully.')));\n      return response;\n    };\n\n    const onUpdateSuccess = (response) => {\n      const updatedDashboard = response.json.result;\n      const lastModifiedTime = response.json.last_modified_time;\n      // synching with the backend transformations of the metadata\n      if (updatedDashboard.json_metadata) {\n        const metadata = JSON.parse(updatedDashboard.json_metadata);\n        dispatch(\n        dashboardInfoChanged({\n          metadata }));\n\n\n        if (metadata.chart_configuration) {\n          dispatch({\n            type: SET_CHART_CONFIG_COMPLETE,\n            chartConfiguration: metadata.chart_configuration });\n\n        }\n      }\n      if (lastModifiedTime) {\n        dispatch(saveDashboardRequestSuccess(lastModifiedTime));\n      }\n      // redirect to the new slug or id\n      window.history.pushState(\n      { event: 'dashboard_properties_changed' },\n      '',\n      `/superset/dashboard/${slug || id}/`);\n\n\n      dispatch(addSuccessToast(t('This dashboard was saved successfully.')));\n      return response;\n    };\n\n    const onError = async (response) => {\n      const { error, message } = await getClientErrorObject(response);\n      let errorText = t('Sorry, an unknown error occured');\n\n      if (error) {\n        errorText = t(\n        'Sorry, there was an error saving this dashboard: %s',\n        error);\n\n      }\n      if (typeof message === 'string' && message === 'Forbidden') {\n        errorText = t('You do not have permission to edit this dashboard');\n      }\n      dispatch(addDangerToast(errorText));\n    };\n\n    if (saveType === SAVE_TYPE_OVERWRITE) {\n      let chartConfiguration = {};\n      if (isFeatureEnabled(FeatureFlag.DASHBOARD_CROSS_FILTERS)) {\n        chartConfiguration = handleChartConfiguration();\n      }\n      const updatedDashboard = {\n        certified_by: cleanedData.certified_by,\n        certification_details: cleanedData.certification_details,\n        css: cleanedData.css,\n        dashboard_title: cleanedData.dashboard_title,\n        slug: cleanedData.slug,\n        owners: cleanedData.owners,\n        roles: cleanedData.roles,\n        json_metadata: safeStringify({\n          ...((cleanedData == null ? void 0 : cleanedData.metadata) || {}),\n          default_filters: safeStringify(serializedFilters),\n          filter_scopes: serializedFilterScopes,\n          chart_configuration: chartConfiguration }) };\n\n\n\n      return SupersetClient.put({\n        endpoint: `/api/v1/dashboard/${id}`,\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(updatedDashboard) }).\n\n      then((response) => onUpdateSuccess(response)).\n      catch((response) => onError(response));\n    }\n    // changing the data as the endpoint requires\n    const copyData = cleanedData;\n    if (copyData.metadata) {\n      delete copyData.metadata;\n    }\n    const finalCopyData = {\n      ...copyData,\n      // the endpoint is expecting the metadata to be flat\n      ...((cleanedData == null ? void 0 : cleanedData.metadata) || {}) };\n\n    return SupersetClient.post({\n      endpoint: `/superset/copy_dash/${id}/`,\n      postPayload: {\n        data: {\n          ...finalCopyData,\n          default_filters: safeStringify(serializedFilters),\n          filter_scopes: safeStringify(serializedFilterScopes) } } }).\n\n\n\n    then((response) => onCopySuccess(response)).\n    catch((response) => onError(response));\n  };\n}\n\nexport function fetchCharts(\nchartList = [],\nforce = false,\ninterval = 0,\ndashboardId)\n{\n  return (dispatch, getState) => {\n    if (!interval) {\n      chartList.forEach((chartKey) =>\n      dispatch(refreshChart(chartKey, force, dashboardId)));\n\n      return;\n    }\n\n    const { metadata: meta } = getState().dashboardInfo;\n    const refreshTime = Math.max(interval, meta.stagger_time || 5000); // default 5 seconds\n    if (typeof meta.stagger_refresh !== 'boolean') {\n      meta.stagger_refresh =\n      meta.stagger_refresh === undefined ?\n      true :\n      meta.stagger_refresh === 'true';\n    }\n    const delay = meta.stagger_refresh ?\n    refreshTime / (chartList.length - 1) :\n    0;\n    chartList.forEach((chartKey, i) => {\n      setTimeout(\n      () => dispatch(refreshChart(chartKey, force, dashboardId)),\n      delay * i);\n\n    });\n  };\n}\n\nconst refreshCharts = (chartList, force, interval, dashboardId, dispatch) =>\nnew Promise((resolve) => {\n  dispatch(fetchCharts(chartList, force, interval, dashboardId));\n  resolve();\n});\n\nexport const ON_REFRESH_SUCCESS = 'ON_REFRESH_SUCCESS';\nexport function onRefreshSuccess() {\n  return { type: ON_REFRESH_SUCCESS };\n}\n\nexport const ON_REFRESH = 'ON_REFRESH';\nexport function onRefresh(\nchartList = [],\nforce = false,\ninterval = 0,\ndashboardId)\n{\n  return (dispatch) => {\n    dispatch({ type: ON_REFRESH });\n    refreshCharts(chartList, force, interval, dashboardId, dispatch).then(() =>\n    dispatch({ type: ON_REFRESH_SUCCESS }));\n\n  };\n}\n\nexport const SHOW_BUILDER_PANE = 'SHOW_BUILDER_PANE';\nexport function showBuilderPane() {\n  return { type: SHOW_BUILDER_PANE };\n}\n\nexport function addSliceToDashboard(id, component) {\n  return (dispatch, getState) => {\n    const { sliceEntities } = getState();\n    const selectedSlice = sliceEntities.slices[id];\n    if (!selectedSlice) {\n      return dispatch(\n      addWarningToast(\n      'Sorry, there is no chart definition associated with the chart trying to be added.'));\n\n\n    }\n    const form_data = {\n      ...selectedSlice.form_data,\n      slice_id: selectedSlice.slice_id };\n\n    const newChart = {\n      ...initChart,\n      id,\n      form_data,\n      formData: applyDefaultFormData(form_data) };\n\n\n    return Promise.all([\n    dispatch(addChart(newChart, id)),\n    dispatch(fetchDatasourceMetadata(form_data.datasource))]).\n    then(() => {\n      dispatch(addSlice(selectedSlice));\n\n      if (selectedSlice && selectedSlice.viz_type === 'filter_box') {\n        dispatch(addFilter(id, component, selectedSlice.form_data));\n      }\n    });\n  };\n}\n\nexport function removeSliceFromDashboard(id) {\n  return (dispatch, getState) => {\n    const sliceEntity = getState().sliceEntities.slices[id];\n    if (sliceEntity && sliceEntity.viz_type === 'filter_box') {\n      dispatch(removeFilter(id));\n    }\n\n    dispatch(removeSlice(id));\n    dispatch(removeChart(id));\n  };\n}\n\nexport const SET_COLOR_SCHEME = 'SET_COLOR_SCHEME';\nexport function setColorScheme(colorScheme) {\n  return { type: SET_COLOR_SCHEME, colorScheme };\n}\n\nexport function setColorSchemeAndUnsavedChanges(colorScheme) {\n  return (dispatch) => {\n    dispatch(setColorScheme(colorScheme));\n    dispatch(setUnsavedChanges(true));\n  };\n}\n\nexport const SET_DIRECT_PATH = 'SET_DIRECT_PATH';\nexport function setDirectPathToChild(path) {\n  return { type: SET_DIRECT_PATH, path };\n}\n\nexport const SET_ACTIVE_TABS = 'SET_ACTIVE_TABS';\nexport function setActiveTabs(tabId, prevTabId) {\n  return { type: SET_ACTIVE_TABS, tabId, prevTabId };\n}\n\nexport const SET_FOCUSED_FILTER_FIELD = 'SET_FOCUSED_FILTER_FIELD';\nexport function setFocusedFilterField(chartId, column) {\n  return { type: SET_FOCUSED_FILTER_FIELD, chartId, column };\n}\n\nexport const UNSET_FOCUSED_FILTER_FIELD = 'UNSET_FOCUSED_FILTER_FIELD';\nexport function unsetFocusedFilterField(chartId, column) {\n  return { type: UNSET_FOCUSED_FILTER_FIELD, chartId, column };\n}\n\nexport const SET_FULL_SIZE_CHART_ID = 'SET_FULL_SIZE_CHART_ID';\nexport function setFullSizeChartId(chartId) {\n  return { type: SET_FULL_SIZE_CHART_ID, chartId };\n}\n\n// Undo history ---------------------------------------------------------------\nexport const SET_MAX_UNDO_HISTORY_EXCEEDED = 'SET_MAX_UNDO_HISTORY_EXCEEDED';\nexport function setMaxUndoHistoryExceeded(maxUndoHistoryExceeded = true) {\n  return {\n    type: SET_MAX_UNDO_HISTORY_EXCEEDED,\n    payload: { maxUndoHistoryExceeded } };\n\n}\n\nexport function maxUndoHistoryToast() {\n  return (dispatch, getState) => {\n    const { dashboardLayout } = getState();\n    const historyLength = dashboardLayout.past.length;\n\n    return dispatch(\n    addWarningToast(\n    `You have used all ${historyLength} undo slots and will not be able to fully undo subsequent actions. You may save your current state to reset the history.`));\n\n\n  };\n}","map":null,"metadata":{},"sourceType":"module"}