{"ast":null,"code":"import { bisector, tickStep } from \"d3-array\";\nimport { durationDay, durationHour, durationMinute, durationMonth, durationSecond, durationWeek, durationYear } from \"./duration.js\";\nimport millisecond from \"./millisecond.js\";\nimport second from \"./second.js\";\nimport minute from \"./minute.js\";\nimport hour from \"./hour.js\";\nimport day from \"./day.js\";\nimport { sunday as week } from \"./week.js\";\nimport month from \"./month.js\";\nimport year from \"./year.js\";\nimport utcMinute from \"./utcMinute.js\";\nimport utcHour from \"./utcHour.js\";\nimport utcDay from \"./utcDay.js\";\nimport { utcSunday as utcWeek } from \"./utcWeek.js\";\nimport utcMonth from \"./utcMonth.js\";\nimport utcYear from \"./utcYear.js\";\n\nfunction ticker(year, month, week, day, hour, minute) {\n\n  const tickIntervals = [\n  [second, 1, durationSecond],\n  [second, 5, 5 * durationSecond],\n  [second, 15, 15 * durationSecond],\n  [second, 30, 30 * durationSecond],\n  [minute, 1, durationMinute],\n  [minute, 5, 5 * durationMinute],\n  [minute, 15, 15 * durationMinute],\n  [minute, 30, 30 * durationMinute],\n  [hour, 1, durationHour],\n  [hour, 3, 3 * durationHour],\n  [hour, 6, 6 * durationHour],\n  [hour, 12, 12 * durationHour],\n  [day, 1, durationDay],\n  [day, 2, 2 * durationDay],\n  [week, 1, durationWeek],\n  [month, 1, durationMonth],\n  [month, 3, 3 * durationMonth],\n  [year, 1, durationYear]];\n\n\n  function ticks(start, stop, count) {\n    const reverse = stop < start;\n    if (reverse) [start, stop] = [stop, start];\n    const interval = count && typeof count.range === \"function\" ? count : tickInterval(start, stop, count);\n    const ticks = interval ? interval.range(start, +stop + 1) : []; // inclusive stop\n    return reverse ? ticks.reverse() : ticks;\n  }\n\n  function tickInterval(start, stop, count) {\n    const target = Math.abs(stop - start) / count;\n    const i = bisector(([,, step]) => step).right(tickIntervals, target);\n    if (i === tickIntervals.length) return year.every(tickStep(start / durationYear, stop / durationYear, count));\n    if (i === 0) return millisecond.every(Math.max(tickStep(start, stop, count), 1));\n    const [t, step] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];\n    return t.every(step);\n  }\n\n  return [ticks, tickInterval];\n}\n\nconst [utcTicks, utcTickInterval] = ticker(utcYear, utcMonth, utcWeek, utcDay, utcHour, utcMinute);\nconst [timeTicks, timeTickInterval] = ticker(year, month, week, day, hour, minute);\n\nexport { utcTicks, utcTickInterval, timeTicks, timeTickInterval };","map":null,"metadata":{},"sourceType":"module"}