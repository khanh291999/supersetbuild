{"ast":null,"code":"import _extends from \"@babel/runtime-corejs3/helpers/extends\";import _isEqual from \"lodash/isEqual\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport React, { useEffect, useMemo, useState, useRef, useCallback } from 'react';\nimport { styled, t } from '@superset-ui/core';\nimport AntdSelect from 'antd/lib/select';\nimport { DownOutlined, SearchOutlined } from '@ant-design/icons';\nimport debounce from 'lodash/debounce';\n\nimport { Spin } from 'antd';\nimport Icons from 'src/components/Icons';\nimport { getClientErrorObject } from 'src/utils/getClientErrorObject';\nimport { hasOption } from './utils';import { jsx as ___EmotionJSX } from \"@emotion/react\";\nconst { Option } = AntdSelect;\nconst StyledContainer = styled.div`\n  display: flex;\n  flex-direction: column;\n  width: 100%;\n`;\nconst StyledSelect = styled(AntdSelect)`\n  ${({ theme }) => `\n    && .ant-select-selector {\n      border-radius: ${theme.gridUnit}px;\n    }\n\n    // Open the dropdown when clicking on the suffix\n    // This is fixed in version 4.16\n    .ant-select-arrow .anticon:not(.ant-select-suffix) {\n      pointer-events: none;\n    }\n  `}\n`;\nconst StyledStopOutlined = styled(Icons.StopOutlined)`\n  vertical-align: 0;\n`;\nconst StyledCheckOutlined = styled(Icons.CheckOutlined)`\n  vertical-align: 0;\n`;\nconst StyledError = styled.div`\n  ${({ theme }) => `\n    display: flex;\n    justify-content: center;\n    align-items: flex-start;\n    width: 100%;\n    padding: ${theme.gridUnit * 2}px;\n    color: ${theme.colors.error.base};\n\n    & svg {\n      margin-right: ${theme.gridUnit * 2}px;\n    }\n  `}\n`;\nconst StyledErrorMessage = styled.div`\n  overflow: hidden;\n  text-overflow: ellipsis;\n`;\nconst StyledSpin = styled(Spin)`\n  margin-top: ${({ theme }) => -theme.gridUnit}px;\n`;\nconst StyledLoadingText = styled.div`\n  ${({ theme }) => `\n    margin-left: ${theme.gridUnit * 3}px;\n    line-height: ${theme.gridUnit * 8}px;\n    color: ${theme.colors.grayscale.light1};\n  `}\n`;\nconst MAX_TAG_COUNT = 4;\nconst TOKEN_SEPARATORS = [',', '\\n', '\\t', ';'];\nconst DEBOUNCE_TIMEOUT = 500;\nconst DEFAULT_PAGE_SIZE = 100;\nconst EMPTY_OPTIONS = [];\nconst Error = ({ error }) => ___EmotionJSX(StyledError, null,\n___EmotionJSX(Icons.ErrorSolid, null), \" \", ___EmotionJSX(StyledErrorMessage, null, error));\n\nconst Select = ({ allowNewOptions = false, ariaLabel, fetchOnlyOnSearch, filterOption = true, header = null, invertSelection = false, labelInValue = false, lazyLoading = true, loading, mode = 'single', name, notFoundContent, onError, onChange, onClear, optionFilterProps = ['label', 'value'], options, pageSize = DEFAULT_PAGE_SIZE, placeholder = t('Select ...'), showSearch = true, value, ...props }) => {\n  const isAsync = typeof options === 'function';\n  const isSingleMode = mode === 'single';\n  const shouldShowSearch = isAsync || allowNewOptions ? true : showSearch;\n  const initialOptions = options && Array.isArray(options) ? options : EMPTY_OPTIONS;\n  const [selectOptions, setSelectOptions] = useState(initialOptions);\n  const shouldUseChildrenOptions = !!selectOptions.find((opt) => opt == null ? void 0 : opt.customLabel);\n  const [selectValue, setSelectValue] = useState(value);\n  const [searchedValue, setSearchedValue] = useState('');\n  const [isLoading, setIsLoading] = useState(loading);\n  const [isTyping, setIsTyping] = useState(false);\n  const [error, setError] = useState('');\n  const [isDropdownVisible, setIsDropdownVisible] = useState(false);\n  const [page, setPage] = useState(0);\n  const [totalCount, setTotalCount] = useState(0);\n  const [loadingEnabled, setLoadingEnabled] = useState(!lazyLoading);\n  const [allValuesLoaded, setAllValuesLoaded] = useState(false);\n  const fetchedQueries = useRef(new Map());\n  const mappedMode = isSingleMode ?\n  undefined :\n  allowNewOptions ?\n  'tags' :\n  'multiple';\n  // TODO: Don't assume that isAsync is always labelInValue\n  const handleTopOptions = useCallback((selectedValue) => {\n    // bringing selected options to the top of the list\n    if (selectedValue !== undefined && selectedValue !== null) {\n      const isLabeledValue = isAsync || labelInValue;\n      const topOptions = [];\n      const otherOptions = [];\n      selectOptions.forEach((opt) => {\n        let found = false;\n        if (Array.isArray(selectedValue)) {\n          if (isLabeledValue) {\n            found =\n            selectedValue.find((element) => element.value === opt.value) !== undefined;\n          } else\n          {\n            found = selectedValue.includes(opt.value);\n          }\n        } else\n        {\n          found = isLabeledValue ?\n          selectedValue.value === opt.value :\n          selectedValue === opt.value;\n        }\n        if (found) {\n          topOptions.push(opt);\n        } else\n        {\n          otherOptions.push(opt);\n        }\n      });\n      // fallback for custom options in tags mode as they\n      // do not appear in the selectOptions state\n      if (!isSingleMode && Array.isArray(selectedValue)) {\n        selectedValue.forEach((val) => {\n          if (!topOptions.find((tOpt) => tOpt.value === (\n          isLabeledValue ? val == null ? void 0 : val.value : val))) {\n            if (isLabeledValue) {\n              const labelValue = val;\n              topOptions.push({\n                label: labelValue.label,\n                value: labelValue.value });\n\n            } else\n            {\n              const value = val;\n              topOptions.push({ label: String(value), value });\n            }\n          }\n        });\n      }\n      const sortedOptions = [...topOptions, ...otherOptions];\n      if (!_isEqual(sortedOptions, selectOptions)) {\n        setSelectOptions(sortedOptions);\n      }\n    }\n  }, [isAsync, isSingleMode, labelInValue, selectOptions]);\n  const handleOnSelect = (selectedValue) => {\n    if (isSingleMode) {\n      setSelectValue(selectedValue);\n    } else\n    {\n      const currentSelected = selectValue ?\n      Array.isArray(selectValue) ?\n      selectValue :\n      [selectValue] :\n      [];\n      if (typeof selectedValue === 'number' ||\n      typeof selectedValue === 'string') {\n        setSelectValue([\n        ...currentSelected,\n        selectedValue]);\n\n      } else\n      {\n        setSelectValue([\n        ...currentSelected,\n        selectedValue]);\n\n      }\n    }\n    setSearchedValue('');\n  };\n  const handleOnDeselect = (value) => {\n    if (Array.isArray(selectValue)) {\n      if (typeof value === 'number' || typeof value === 'string') {\n        const array = selectValue;\n        setSelectValue(array.filter((element) => element !== value));\n      } else\n      {\n        const array = selectValue;\n        setSelectValue(array.filter((element) => element.value !== value.value));\n      }\n    }\n    setSearchedValue('');\n  };\n  const internalOnError = useCallback((response) => getClientErrorObject(response).then((e) => {\n    const { error } = e;\n    setError(error);\n    if (onError) {\n      onError(error);\n    }\n  }), [onError]);\n  const handleData = (data) => {\n    let mergedData = [];\n    if (data && Array.isArray(data) && data.length) {\n      const dataValues = new Set();\n      data.forEach((option) => dataValues.add(String(option.value).toLocaleLowerCase()));\n      // merges with existing and creates unique options\n      setSelectOptions((prevOptions) => {\n        mergedData = [\n        ...prevOptions.filter((previousOption) => !dataValues.has(String(previousOption.value).toLocaleLowerCase())),\n        ...data];\n\n        return mergedData;\n      });\n    }\n    return mergedData;\n  };\n  const handlePaginatedFetch = useMemo(() => (value, page, pageSize) => {\n    if (allValuesLoaded) {\n      setIsLoading(false);\n      setIsTyping(false);\n      return;\n    }\n    const key = `${value};${page};${pageSize}`;\n    const cachedCount = fetchedQueries.current.get(key);\n    if (cachedCount) {\n      setTotalCount(cachedCount);\n      setIsLoading(false);\n      setIsTyping(false);\n      return;\n    }\n    setIsLoading(true);\n    const fetchOptions = options;\n    fetchOptions(value, page, pageSize).\n    then(({ data, totalCount }) => {\n      const mergedData = handleData(data);\n      fetchedQueries.current.set(key, totalCount);\n      setTotalCount(totalCount);\n      if (!fetchOnlyOnSearch &&\n      value === '' &&\n      mergedData.length >= totalCount) {\n        setAllValuesLoaded(true);\n      }\n    }).\n    catch(internalOnError).\n    finally(() => {\n      setIsLoading(false);\n      setIsTyping(false);\n    });\n  }, [allValuesLoaded, fetchOnlyOnSearch, internalOnError, options]);\n  const handleOnSearch = useMemo(() => debounce((search) => {\n    const searchValue = search.trim();\n    if (allowNewOptions && isSingleMode) {\n      const newOption = searchValue &&\n      !hasOption(searchValue, selectOptions) && {\n        label: searchValue,\n        value: searchValue };\n\n      const newOptions = newOption ?\n      [\n      newOption,\n      ...selectOptions.filter((opt) => opt.value !== searchedValue)] :\n\n      [...selectOptions.filter((opt) => opt.value !== searchedValue)];\n      setSelectOptions(newOptions);\n    }\n    if (!searchValue || searchValue === searchedValue) {\n      setIsTyping(false);\n    }\n    setSearchedValue(searchValue);\n  }, DEBOUNCE_TIMEOUT), [allowNewOptions, isSingleMode, searchedValue, selectOptions]);\n  const handlePagination = (e) => {\n    const vScroll = e.currentTarget;\n    const thresholdReached = vScroll.scrollTop > (vScroll.scrollHeight - vScroll.offsetHeight) * 0.7;\n    const hasMoreData = page * pageSize + pageSize < totalCount;\n    if (!isLoading && isAsync && hasMoreData && thresholdReached) {\n      const newPage = page + 1;\n      handlePaginatedFetch(searchedValue, newPage, pageSize);\n      setPage(newPage);\n    }\n  };\n  const handleFilterOption = (search, option) => {\n    if (typeof filterOption === 'function') {\n      return filterOption(search, option);\n    }\n    if (filterOption) {\n      const searchValue = search.trim().toLowerCase();\n      if (optionFilterProps && optionFilterProps.length) {\n        return optionFilterProps.some((prop) => {\n          const optionProp = option != null && option[prop] ?\n          String(option[prop]).trim().toLowerCase() :\n          '';\n          return optionProp.includes(searchValue);\n        });\n      }\n    }\n    return false;\n  };\n  const handleOnDropdownVisibleChange = (isDropdownVisible) => {\n    setIsDropdownVisible(isDropdownVisible);\n    if (isAsync && !loadingEnabled) {\n      setLoadingEnabled(true);\n    }\n    // multiple or tags mode keep the dropdown visible while selecting options\n    // this waits for the dropdown to be closed before sorting the top options\n    if (!isSingleMode && !isDropdownVisible) {\n      handleTopOptions(selectValue);\n    }\n  };\n  const dropdownRender = (originNode) => {\n    if (!isDropdownVisible) {var _originNode$ref, _originNode$ref$curre;\n      (_originNode$ref = originNode.ref) == null ? void 0 : (_originNode$ref$curre = _originNode$ref.current) == null ? void 0 : _originNode$ref$curre.scrollTo({ top: 0 });\n    }\n    if (isLoading && selectOptions.length === 0 || isTyping) {\n      return ___EmotionJSX(StyledLoadingText, null, t('Loading...'));\n    }\n    return error ? ___EmotionJSX(Error, { error: error }) : originNode;\n  };\n  const onInputKeyDown = (event) => {\n    if (event.key.length === 1 && isAsync && !isTyping) {\n      setIsTyping(true);\n    }\n  };\n  const SuffixIcon = () => {\n    if (isLoading) {\n      return ___EmotionJSX(StyledSpin, { size: \"small\" });\n    }\n    if (shouldShowSearch && isDropdownVisible) {\n      return ___EmotionJSX(SearchOutlined, null);\n    }\n    return ___EmotionJSX(DownOutlined, null);\n  };\n  const handleClear = () => {\n    setSelectValue(undefined);\n    if (onClear) {\n      onClear();\n    }\n  };\n  useEffect(() => {\n    fetchedQueries.current.clear();\n    setSelectOptions(options && Array.isArray(options) ? options : EMPTY_OPTIONS);\n    setAllValuesLoaded(false);\n  }, [options]);\n  useEffect(() => {\n    setSelectValue(value);\n  }, [value]);\n  useEffect(() => {\n    if (selectValue) {\n      const array = Array.isArray(selectValue) ?\n      selectValue :\n      [selectValue];\n      const options = [];\n      const isLabeledValue = isAsync || labelInValue;\n      array.forEach((element) => {\n        const found = selectOptions.find((option) => isLabeledValue ?\n        option.value === element.value :\n        option.value === element);\n        if (!found) {\n          options.push(isLabeledValue ?\n          element :\n          { value: element, label: element });\n        }\n      });\n      if (options.length > 0) {\n        setSelectOptions([...options, ...selectOptions]);\n      }\n    }\n  }, [labelInValue, isAsync, selectOptions, selectValue]);\n  // Stop the invocation of the debounced function after unmounting\n  useEffect(() => () => handleOnSearch.cancel(), [handleOnSearch]);\n  useEffect(() => {\n    const allowFetch = !fetchOnlyOnSearch || searchedValue;\n    if (isAsync && loadingEnabled && allowFetch) {\n      const page = 0;\n      handlePaginatedFetch(searchedValue, page, pageSize);\n      setPage(page);\n    }\n  }, [\n  isAsync,\n  searchedValue,\n  pageSize,\n  handlePaginatedFetch,\n  loadingEnabled,\n  fetchOnlyOnSearch]);\n\n  useEffect(() => {\n    if (isSingleMode) {\n      handleTopOptions(selectValue);\n    }\n  }, [handleTopOptions, isSingleMode, selectValue]);\n  useEffect(() => {\n    if (loading !== undefined && loading !== isLoading) {\n      setIsLoading(loading);\n    }\n  }, [isLoading, loading]);\n  return ___EmotionJSX(StyledContainer, null,\n  header,\n  ___EmotionJSX(StyledSelect, _extends({ \"aria-label\": ariaLabel || name, dropdownRender: dropdownRender, filterOption: handleFilterOption, getPopupContainer: (triggerNode) => triggerNode.parentNode, labelInValue: isAsync || labelInValue, maxTagCount: MAX_TAG_COUNT, mode: mappedMode, notFoundContent: allowNewOptions && !fetchOnlyOnSearch ? ___EmotionJSX(StyledLoadingText, null, t('Loading...')) : notFoundContent, onDeselect: handleOnDeselect, onDropdownVisibleChange: handleOnDropdownVisibleChange, onInputKeyDown: onInputKeyDown, onPopupScroll: isAsync ? handlePagination : undefined, onSearch: shouldShowSearch ? handleOnSearch : undefined, onSelect: handleOnSelect, onClear: handleClear, onChange: onChange, options: shouldUseChildrenOptions ? undefined : selectOptions, placeholder: placeholder, showSearch: shouldShowSearch, showArrow: true, tokenSeparators: TOKEN_SEPARATORS, value: selectValue, suffixIcon: ___EmotionJSX(SuffixIcon, null), menuItemSelectedIcon: invertSelection ? ___EmotionJSX(StyledStopOutlined, { iconSize: \"m\" }) : ___EmotionJSX(StyledCheckOutlined, { iconSize: \"m\" }) }, props),\n  shouldUseChildrenOptions &&\n  selectOptions.map((opt) => {\n    const isOptObject = typeof opt === 'object';\n    const label = isOptObject ? (opt == null ? void 0 : opt.label) || opt.value : opt;\n    const value = isOptObject && opt.value || opt;\n    const { customLabel, ...optProps } = opt;\n    return ___EmotionJSX(Option, _extends({}, optProps, { key: value, label: label, value: value }),\n    isOptObject && customLabel ? customLabel : label);\n\n  })));\n\n\n};\nexport default Select;","map":null,"metadata":{},"sourceType":"module"}