{"ast":null,"code":"import _isEqualWith from \"lodash/isEqualWith\";import _isEqual from \"lodash/isEqual\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport React, { useEffect, useRef, useState } from 'react';\nimport { SuperChart, t, styled, Behavior, getChartMetadataRegistry } from '@superset-ui/core';\nimport { useDispatch, useSelector } from 'react-redux';\n\nimport { getChartDataRequest } from 'src/chart/chartAction';\nimport Loading from 'src/components/Loading';\nimport BasicErrorAlert from 'src/components/ErrorMessage/BasicErrorAlert';\nimport { FeatureFlag, isFeatureEnabled } from 'src/featureFlags';\nimport { waitForAsyncData } from 'src/middleware/asyncEvent';\nimport { dispatchFocusAction } from './utils';\nimport { getFormData } from '../../utils';\nimport { useCascadingFilters } from './state';\nimport { checkIsMissingRequiredValue } from '../utils';import { jsx as ___EmotionJSX } from \"@emotion/react\";\nconst HEIGHT = 32;\n// Overrides superset-ui height with min-height\nconst StyledDiv = styled.div`\n  & > div {\n    height: auto !important;\n    min-height: ${HEIGHT}px;\n  }\n`;\nconst FilterValue = ({ dataMaskSelected, filter, directPathToChild, onFilterSelectionChange, inView = true }) => {var _filter$dataMask2, _filter$dataMask3, _filter$dataMask4;\n  const { id, targets, filterType, adhoc_filters, time_range } = filter;\n  const metadata = getChartMetadataRegistry().get(filterType);\n  const cascadingFilters = useCascadingFilters(id, dataMaskSelected);\n  const isDashboardRefreshing = useSelector((state) => state.dashboardState.isRefreshing);\n  const [state, setState] = useState([]);\n  const [error, setError] = useState('');\n  const [formData, setFormData] = useState({\n    inView: false });\n\n  const [ownState, setOwnState] = useState({});\n  const [inViewFirstTime, setInViewFirstTime] = useState(inView);\n  const inputRef = useRef(null);\n  const [target] = targets;\n  const { datasetId, column = {} } = target;\n  const { name: groupby } = column;\n  const hasDataSource = !!datasetId;\n  const [isLoading, setIsLoading] = useState(hasDataSource);\n  const [isRefreshing, setIsRefreshing] = useState(false);\n  const dispatch = useDispatch();\n  useEffect(() => {\n    if (!inViewFirstTime && inView) {\n      setInViewFirstTime(true);\n    }\n  }, [inView, inViewFirstTime, setInViewFirstTime]);\n  useEffect(() => {var _filter$dataMask;\n    if (!inViewFirstTime) {\n      return;\n    }\n    const newFormData = getFormData({\n      ...filter,\n      datasetId,\n      cascadingFilters,\n      groupby,\n      inputRef,\n      adhoc_filters,\n      time_range });\n\n    const filterOwnState = ((_filter$dataMask = filter.dataMask) == null ? void 0 : _filter$dataMask.ownState) || {};\n    // TODO: We should try to improve our useEffect hooks to depend more on\n    // granular information instead of big objects that require deep comparison.\n    const customizer = (objValue, othValue, key) => key === 'url_params' ? true : undefined;\n    if (!isRefreshing && (\n    !_isEqualWith(formData, newFormData, customizer) ||\n    !_isEqual(ownState, filterOwnState) ||\n    isDashboardRefreshing)) {\n      setFormData(newFormData);\n      setOwnState(filterOwnState);\n      if (!hasDataSource) {\n        return;\n      }\n      setIsRefreshing(true);\n      getChartDataRequest({\n        formData: newFormData,\n        force: false,\n        requestParams: { dashboardId: 0 },\n        ownState: filterOwnState }).\n\n      then(({ response, json }) => {\n        if (isFeatureEnabled(FeatureFlag.GLOBAL_ASYNC_QUERIES)) {\n          // deal with getChartDataRequest transforming the response data\n          const result = 'result' in json ? json.result[0] : json;\n          if (response.status === 200) {\n            setIsRefreshing(false);\n            setIsLoading(false);\n            setState([result]);\n          } else\n          if (response.status === 202) {\n            waitForAsyncData(result).\n            then((asyncResult) => {\n              setIsRefreshing(false);\n              setIsLoading(false);\n              setState(asyncResult);\n            }).\n            catch((error) => {\n              setError(error.message || error.error || t('Check configuration'));\n              setIsRefreshing(false);\n              setIsLoading(false);\n            });\n          } else\n          {\n            throw new Error(`Received unexpected response status (${response.status}) while fetching chart data`);\n          }\n        } else\n        {\n          setState(json.result);\n          setError('');\n          setIsRefreshing(false);\n          setIsLoading(false);\n        }\n      }).\n      catch((error) => {\n        setError(error.statusText);\n        setIsRefreshing(false);\n        setIsLoading(false);\n      });\n    }\n  }, [\n  inViewFirstTime,\n  cascadingFilters,\n  datasetId,\n  groupby,\n  JSON.stringify(filter),\n  hasDataSource,\n  isRefreshing,\n  isDashboardRefreshing]);\n\n  useEffect(() => {\n    if ((directPathToChild == null ? void 0 : directPathToChild[0]) === filter.id) {\n      // wait for Cascade Popover to open\n      const timeout = setTimeout(() => {var _inputRef$current;\n        inputRef == null ? void 0 : (_inputRef$current = inputRef.current) == null ? void 0 : _inputRef$current.focus();\n      }, 200);\n      return () => clearTimeout(timeout);\n    }\n    return undefined;\n  }, [inputRef, directPathToChild, filter.id]);\n  const setDataMask = (dataMask) => onFilterSelectionChange(filter, dataMask);\n  const setFocusedFilter = () => dispatchFocusAction(dispatch, id);\n  const unsetFocusedFilter = () => dispatchFocusAction(dispatch);\n  if (error) {\n    return ___EmotionJSX(BasicErrorAlert, { title: t('Cannot load filter'), body: error, level: \"error\" });\n  }\n  const isMissingRequiredValue = checkIsMissingRequiredValue(filter, (_filter$dataMask2 = filter.dataMask) == null ? void 0 : _filter$dataMask2.filterState);\n  const filterState = {\n    ...((_filter$dataMask3 = filter.dataMask) == null ? void 0 : _filter$dataMask3.filterState),\n    validateStatus: isMissingRequiredValue && 'error' };\n\n  return ___EmotionJSX(StyledDiv, null,\n  isLoading ? ___EmotionJSX(Loading, { position: \"inline-centered\" }) : ___EmotionJSX(SuperChart, { height: HEIGHT, width: \"100%\", formData: formData\n    // For charts that don't have datasource we need workaround for empty placeholder\n    , queriesData: hasDataSource ? state : [{ data: [{}] }], chartType: filterType, behaviors: [Behavior.NATIVE_FILTER], filterState: filterState, ownState: (_filter$dataMask4 = filter.dataMask) == null ? void 0 : _filter$dataMask4.ownState, enableNoResults: metadata == null ? void 0 : metadata.enableNoResults, isRefreshing: isRefreshing, hooks: { setDataMask, setFocusedFilter, unsetFocusedFilter } }));\n\n};\nexport default FilterValue;","map":null,"metadata":{},"sourceType":"module"}