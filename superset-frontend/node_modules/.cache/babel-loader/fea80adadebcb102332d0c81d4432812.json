{"ast":null,"code":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport {\nDASHBOARD_ROOT_ID,\nDASHBOARD_GRID_ID,\nNEW_COMPONENTS_SOURCE_ID,\nDASHBOARD_HEADER_ID } from\n'../util/constants';\nimport componentIsResizable from '../util/componentIsResizable';\nimport findParentId from '../util/findParentId';\nimport getComponentWidthFromDrop from '../util/getComponentWidthFromDrop';\nimport updateComponentParentsList from '../util/updateComponentParentsList';\nimport newComponentFactory from '../util/newComponentFactory';\nimport newEntitiesFromDrop from '../util/newEntitiesFromDrop';\nimport reorderItem from '../util/dnd-reorder';\nimport shouldWrapChildInRow from '../util/shouldWrapChildInRow';\nimport { ROW_TYPE, TAB_TYPE, TABS_TYPE } from '../util/componentTypes';\n\nimport {\nUPDATE_COMPONENTS,\nUPDATE_COMPONENTS_PARENTS_LIST,\nDELETE_COMPONENT,\nCREATE_COMPONENT,\nMOVE_COMPONENT,\nCREATE_TOP_LEVEL_TABS,\nDELETE_TOP_LEVEL_TABS,\nDASHBOARD_TITLE_CHANGED } from\n'../actions/dashboardLayout';\n\nimport { HYDRATE_DASHBOARD } from '../actions/hydrate';\n\nconst actionHandlers = {\n  [HYDRATE_DASHBOARD](state, action) {\n    return {\n      ...action.data.dashboardLayout.present };\n\n  },\n\n  [UPDATE_COMPONENTS](state, action) {\n    const {\n      payload: { nextComponents } } =\n    action;\n    return {\n      ...state,\n      ...nextComponents };\n\n  },\n\n  [DELETE_COMPONENT](state, action) {\n    const {\n      payload: { id, parentId } } =\n    action;\n\n    if (!parentId || !id || !state[id] || !state[parentId]) return state;\n\n    const nextComponents = { ...state };\n\n    function recursivelyDeleteChildren(componentId, componentParentId) {\n      // delete child and it's children\n      const component = nextComponents[componentId];\n      delete nextComponents[componentId];\n\n      const { children = [] } = component;\n      children.forEach((childId) => {\n        recursivelyDeleteChildren(childId, componentId);\n      });\n\n      const parent = nextComponents[componentParentId];\n      if (parent) {\n        // may have been deleted in another recursion\n        const componentIndex = (parent.children || []).indexOf(componentId);\n        if (componentIndex > -1) {\n          const nextChildren = [...parent.children];\n          nextChildren.splice(componentIndex, 1);\n          nextComponents[componentParentId] = {\n            ...parent,\n            children: nextChildren };\n\n        }\n      }\n    }\n\n    recursivelyDeleteChildren(id, parentId);\n    const nextParent = nextComponents[parentId];\n    if (nextParent.type === ROW_TYPE && nextParent.children.length === 0) {\n      const grandparentId = findParentId({\n        childId: parentId,\n        layout: nextComponents });\n\n      recursivelyDeleteChildren(parentId, grandparentId);\n    }\n\n    return nextComponents;\n  },\n\n  [CREATE_COMPONENT](state, action) {\n    const {\n      payload: { dropResult } } =\n    action;\n\n    const newEntities = newEntitiesFromDrop({ dropResult, layout: state });\n\n    return {\n      ...state,\n      ...newEntities };\n\n  },\n\n  [MOVE_COMPONENT](state, action) {\n    const {\n      payload: { dropResult } } =\n    action;\n    const { source, destination, dragging } = dropResult;\n\n    if (!source || !destination || !dragging) return state;\n\n    const nextEntities = reorderItem({\n      entitiesMap: state,\n      source,\n      destination });\n\n\n    if (componentIsResizable(nextEntities[dragging.id])) {\n      // update component width if it changed\n      const nextWidth =\n      getComponentWidthFromDrop({\n        dropResult,\n        layout: state }) ||\n      undefined; // don't set a 0 width\n      if ((nextEntities[dragging.id].meta || {}).width !== nextWidth) {\n        nextEntities[dragging.id] = {\n          ...nextEntities[dragging.id],\n          meta: {\n            ...nextEntities[dragging.id].meta,\n            width: nextWidth } };\n\n\n      }\n    }\n\n    // wrap the dragged component in a row depending on destination type\n    const wrapInRow = shouldWrapChildInRow({\n      parentType: destination.type,\n      childType: dragging.type });\n\n\n    if (wrapInRow) {\n      const destinationEntity = nextEntities[destination.id];\n      const destinationChildren = destinationEntity.children;\n      const newRow = newComponentFactory(ROW_TYPE);\n      newRow.children = [destinationChildren[destination.index]];\n      newRow.parents = (destinationEntity.parents || []).concat(destination.id);\n      destinationChildren[destination.index] = newRow.id;\n      nextEntities[newRow.id] = newRow;\n    }\n\n    return {\n      ...state,\n      ...nextEntities };\n\n  },\n\n  [CREATE_TOP_LEVEL_TABS](state, action) {\n    const {\n      payload: { dropResult } } =\n    action;\n    const { source, dragging } = dropResult;\n\n    // move children of current root to be children of the dragging tab\n    const rootComponent = state[DASHBOARD_ROOT_ID];\n    const topLevelId = rootComponent.children[0];\n    const topLevelComponent = state[topLevelId];\n\n    if (source.id !== NEW_COMPONENTS_SOURCE_ID) {\n      // component already exists\n      const draggingTabs = state[dragging.id];\n      const draggingTabId = draggingTabs.children[0];\n      const draggingTab = state[draggingTabId];\n\n      // move all children except the one that is dragging\n      const childrenToMove = [...topLevelComponent.children].filter(\n      (id) => id !== dragging.id);\n\n\n      return {\n        ...state,\n        [DASHBOARD_ROOT_ID]: {\n          ...rootComponent,\n          children: [dragging.id] },\n\n        [topLevelId]: {\n          ...topLevelComponent,\n          children: [] },\n\n        [draggingTabId]: {\n          ...draggingTab,\n          children: [...draggingTab.children, ...childrenToMove] } };\n\n\n    }\n\n    // create new component\n    const newEntities = newEntitiesFromDrop({ dropResult, layout: state });\n    const newEntitiesArray = Object.values(newEntities);\n    const tabComponent = newEntitiesArray.find(\n    (component) => component.type === TAB_TYPE);\n\n    const tabsComponent = newEntitiesArray.find(\n    (component) => component.type === TABS_TYPE);\n\n\n    tabComponent.children = [...topLevelComponent.children];\n    newEntities[topLevelId] = { ...topLevelComponent, children: [] };\n    newEntities[DASHBOARD_ROOT_ID] = {\n      ...rootComponent,\n      children: [tabsComponent.id] };\n\n\n    return {\n      ...state,\n      ...newEntities };\n\n  },\n\n  [DELETE_TOP_LEVEL_TABS](state) {\n    const rootComponent = state[DASHBOARD_ROOT_ID];\n    const topLevelId = rootComponent.children[0];\n    const topLevelTabs = state[topLevelId];\n\n    if (topLevelTabs.type !== TABS_TYPE) return state;\n\n    let childrenToMove = [];\n    const nextEntities = { ...state };\n\n    topLevelTabs.children.forEach((tabId) => {\n      const tabComponent = state[tabId];\n      childrenToMove = [...childrenToMove, ...tabComponent.children];\n      delete nextEntities[tabId];\n    });\n\n    delete nextEntities[topLevelId];\n\n    nextEntities[DASHBOARD_ROOT_ID] = {\n      ...rootComponent,\n      children: [DASHBOARD_GRID_ID] };\n\n\n    nextEntities[DASHBOARD_GRID_ID] = {\n      ...state[DASHBOARD_GRID_ID],\n      children: childrenToMove };\n\n\n    return nextEntities;\n  },\n\n  [UPDATE_COMPONENTS_PARENTS_LIST](state) {\n    const nextState = {\n      ...state };\n\n\n    updateComponentParentsList({\n      currentComponent: nextState[DASHBOARD_ROOT_ID],\n      layout: nextState });\n\n\n    return {\n      ...nextState };\n\n  },\n\n  [DASHBOARD_TITLE_CHANGED](state, action) {\n    return {\n      ...state,\n      [DASHBOARD_HEADER_ID]: {\n        ...state[DASHBOARD_HEADER_ID],\n        meta: {\n          ...state[DASHBOARD_HEADER_ID].meta,\n          text: action.text } } };\n\n\n\n  } };\n\n\nexport default function layoutReducer(state = {}, action) {\n  if (action.type in actionHandlers) {\n    const handler = actionHandlers[action.type];\n    return handler(state, action);\n  }\n\n  return state;\n}","map":null,"metadata":{},"sourceType":"module"}