"use strict";

exports.__esModule = true;
exports.default = void 0;

var _core = require("@superset-ui/core");

var _buildQuery = _interopRequireDefault(require("../buildQuery"));

var _controlPanel = _interopRequireDefault(require("./controlPanel"));

var _transformProps = _interopRequireDefault(require("../transformProps"));

var _thumbnail = _interopRequireDefault(require("./images/thumbnail.png"));

var _Area = _interopRequireDefault(require("./images/Area1.png"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const areaTransformProps = chartProps => (0, _transformProps.default)({ ...chartProps,
  formData: { ...chartProps.formData,
    area: true
  }
});

class EchartsAreaChartPlugin extends _core.ChartPlugin {
  /**
   * The constructor is used to pass relevant metadata and callbacks that get
   * registered in respective registries that are used throughout the library
   * and application. A more thorough description of each property is given in
   * the respective imported file.
   *
   * It is worth noting that `buildQuery` and is optional, and only needed for
   * advanced visualizations that require either post processing operations
   * (pivoting, rolling aggregations, sorting etc) or submitting multiple queries.
   */
  constructor() {
    super({
      buildQuery: _buildQuery.default,
      controlPanel: _controlPanel.default,
      loadChart: () => Promise.resolve().then(() => _interopRequireWildcard(require('../EchartsTimeseries'))),
      metadata: new _core.ChartMetadata({
        behaviors: [_core.Behavior.INTERACTIVE_CHART],
        category: (0, _core.t)('Evolution'),
        credits: ['https://echarts.apache.org'],
        description: (0, _core.t)('Time-series Area chart are similar to line chart in that they represent variables with the same scale, but area charts stack the metrics on top of each other. An area chart in Superset can be stream, stack, or expand.'),
        exampleGallery: [{
          url: _Area.default
        }],
        supportedAnnotationTypes: [_core.AnnotationType.Event, _core.AnnotationType.Formula, _core.AnnotationType.Interval, _core.AnnotationType.Timeseries],
        name: (0, _core.t)('Time-series Area Chart'),
        tags: [(0, _core.t)('ECharts'), (0, _core.t)('Predictive'), (0, _core.t)('Advanced-Analytics'), (0, _core.t)('Aesthetic'), (0, _core.t)('Time'), (0, _core.t)('Line'), (0, _core.t)('Transformable'), (0, _core.t)('Stacked'), (0, _core.t)('Popular')],
        thumbnail: _thumbnail.default
      }),
      transformProps: areaTransformProps
    });
  }

}

exports.default = EchartsAreaChartPlugin;