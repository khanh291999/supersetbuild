"use strict";

exports.__esModule = true;
exports.default = TableChart;

var _react = _interopRequireWildcard(require("react"));

var _d3Array = require("d3-array");

var _FaSort = require("@react-icons/all-files/fa/FaSort");

var _FaSortDown = require("@react-icons/all-files/fa/FaSortDown");

var _FaSortUp = require("@react-icons/all-files/fa/FaSortUp");

var _core = require("@superset-ui/core");

var _DataTable = _interopRequireDefault(require("./DataTable"));

var _Styles = _interopRequireDefault(require("./Styles"));

var _formatValue = require("./utils/formatValue");

var _consts = require("./consts");

var _externalAPIs = require("./DataTable/utils/externalAPIs");

var _react2 = require("@emotion/react");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

/**
 * Return sortType based on data type
 */
function getSortTypeByDataType(dataType) {
  if (dataType === _core.GenericDataType.TEMPORAL) {
    return 'datetime';
  }

  if (dataType === _core.GenericDataType.STRING) {
    return 'alphanumeric';
  }

  return 'basic';
}
/**
 * Cell background to render columns as horizontal bar chart
 */


function cellBar({
  value,
  valueRange,
  colorPositiveNegative = false,
  alignPositiveNegative
}) {
  const [minValue, maxValue] = valueRange;
  const r = colorPositiveNegative && value < 0 ? 150 : 0;

  if (alignPositiveNegative) {
    const perc = Math.abs(Math.round(value / maxValue * 100)); // The 0.01 to 0.001 is a workaround for what appears to be a
    // CSS rendering bug on flat, transparent colors

    return `linear-gradient(to right, rgba(${r},0,0,0.2), rgba(${r},0,0,0.2) ${perc}%, ` + `rgba(0,0,0,0.01) ${perc}%, rgba(0,0,0,0.001) 100%)`;
  }

  const posExtent = Math.abs(Math.max(maxValue, 0));
  const negExtent = Math.abs(Math.min(minValue, 0));
  const tot = posExtent + negExtent;
  const perc1 = Math.round(Math.min(negExtent + value, negExtent) / tot * 100);
  const perc2 = Math.round(Math.abs(value) / tot * 100); // The 0.01 to 0.001 is a workaround for what appears to be a
  // CSS rendering bug on flat, transparent colors

  return `linear-gradient(to right, rgba(0,0,0,0.01), rgba(0,0,0,0.001) ${perc1}%, ` + `rgba(${r},0,0,0.2) ${perc1}%, rgba(${r},0,0,0.2) ${perc1 + perc2}%, ` + `rgba(0,0,0,0.01) ${perc1 + perc2}%, rgba(0,0,0,0.001) 100%)`;
}

function SortIcon({
  column
}) {
  const {
    isSorted,
    isSortedDesc
  } = column;
  let sortIcon = (0, _react2.jsx)(_FaSort.FaSort, null);

  if (isSorted) {
    sortIcon = isSortedDesc ? (0, _react2.jsx)(_FaSortDown.FaSortDown, null) : (0, _react2.jsx)(_FaSortUp.FaSortUp, null);
  }

  return sortIcon;
}

function SearchInput({
  count,
  value,
  onChange
}) {
  return (0, _react2.jsx)("span", {
    className: "dt-global-filter"
  }, (0, _core.t)('Search'), ' ', (0, _react2.jsx)("input", {
    className: "form-control input-sm",
    placeholder: (0, _core.tn)('search.num_records', count),
    value: value,
    onChange: onChange
  }));
}

function SelectPageSize({
  options,
  current,
  onChange
}) {
  return (0, _react2.jsx)("span", {
    className: "dt-select-page-size form-inline"
  }, (0, _core.t)('page_size.show'), ' ', (0, _react2.jsx)("select", {
    className: "form-control input-sm",
    value: current,
    onBlur: () => {},
    onChange: e => {
      onChange(Number(e.target.value));
    }
  }, options.map(option => {
    const [size, text] = Array.isArray(option) ? option : [option, option];
    return (0, _react2.jsx)("option", {
      key: size,
      value: size
    }, text);
  })), ' ', (0, _core.t)('page_size.entries'));
}

function TableChart(props) {
  const {
    timeGrain,
    height,
    width,
    data,
    totals,
    isRawRecords,
    rowCount = 0,
    columns: columnsMeta,
    alignPositiveNegative: defaultAlignPN = false,
    colorPositiveNegative: defaultColorPN = false,
    includeSearch = false,
    pageSize = 0,
    serverPagination = false,
    serverPaginationData,
    setDataMask,
    showCellBars = true,
    emitFilter = false,
    sortDesc = false,
    filters,
    sticky = true,
    // whether to use sticky header
    columnColorFormatters
  } = props;
  const timestampFormatter = (0, _react.useCallback)(value => (0, _core.getTimeFormatterForGranularity)(timeGrain)(value), [timeGrain]);
  const handleChange = (0, _react.useCallback)(filters => {
    if (!emitFilter) {
      return;
    }

    const groupBy = Object.keys(filters);
    const groupByValues = Object.values(filters);
    const labelElements = [];
    groupBy.forEach(col => {
      const isTimestamp = col === _core.DTTM_ALIAS;
      const filterValues = (0, _core.ensureIsArray)(filters == null ? void 0 : filters[col]);

      if (filterValues.length) {
        const valueLabels = filterValues.map(value => isTimestamp ? timestampFormatter(value) : value);
        labelElements.push(`${valueLabels.join(', ')}`);
      }
    });
    setDataMask({
      extraFormData: {
        filters: groupBy.length === 0 ? [] : groupBy.map(col => {
          const val = (0, _core.ensureIsArray)(filters == null ? void 0 : filters[col]);
          if (!val.length) return {
            col,
            op: 'IS NULL'
          };
          return {
            col,
            op: 'IN',
            val: val.map(el => el instanceof Date ? el.getTime() : el),
            grain: col === _core.DTTM_ALIAS ? timeGrain : undefined
          };
        })
      },
      filterState: {
        label: labelElements.join(', '),
        value: groupByValues.length ? groupByValues : null,
        filters: filters && Object.keys(filters).length ? filters : null
      }
    });
  }, [emitFilter, setDataMask]); // only take relevant page size options

  const pageSizeOptions = (0, _react.useMemo)(() => {
    const getServerPagination = n => n <= rowCount;

    return _consts.PAGE_SIZE_OPTIONS.filter(([n]) => serverPagination ? getServerPagination(n) : n <= 2 * data.length);
  }, [data.length, rowCount, serverPagination]);
  const getValueRange = (0, _react.useCallback)(function getValueRange(key, alignPositiveNegative) {
    var _data$;

    if (typeof (data == null ? void 0 : (_data$ = data[0]) == null ? void 0 : _data$[key]) === 'number') {
      const nums = data.map(row => row[key]);
      return alignPositiveNegative ? [0, (0, _d3Array.max)(nums.map(Math.abs))] : (0, _d3Array.extent)(nums);
    }

    return null;
  }, [data]);
  const isActiveFilterValue = (0, _react.useCallback)(function isActiveFilterValue(key, val) {
    var _filters$key;

    return !!filters && ((_filters$key = filters[key]) == null ? void 0 : _filters$key.includes(val));
  }, [filters]);

  function getEmitTarget(col) {
    var _meta$config;

    const meta = columnsMeta == null ? void 0 : columnsMeta.find(x => x.key === col);
    return (meta == null ? void 0 : (_meta$config = meta.config) == null ? void 0 : _meta$config.emitTarget) || col;
  }

  const toggleFilter = (0, _react.useCallback)(function toggleFilter(key, val) {
    let updatedFilters = { ...(filters || {})
    };
    const target = getEmitTarget(key);

    if (filters && isActiveFilterValue(target, val)) {
      updatedFilters = {};
    } else {
      updatedFilters = {
        [target]: [val]
      };
    }

    if (Array.isArray(updatedFilters[target]) && updatedFilters[target].length === 0) {
      delete updatedFilters[target];
    }

    handleChange(updatedFilters);
  }, [filters, handleChange, isActiveFilterValue]);

  const getSharedStyle = column => {
    const {
      isNumeric,
      config = {}
    } = column;
    const textAlign = config.horizontalAlign ? config.horizontalAlign : isNumeric ? 'right' : 'left';
    return {
      textAlign
    };
  };

  const getColumnConfigs = (0, _react.useCallback)((column, i) => {
    const {
      key,
      label,
      isNumeric,
      dataType,
      isMetric,
      config = {}
    } = column;
    const isFilter = !isNumeric && emitFilter;
    const columnWidth = Number.isNaN(Number(config.columnWidth)) ? config.columnWidth : Number(config.columnWidth); // inline style for both th and td cell

    const sharedStyle = getSharedStyle(column);
    const alignPositiveNegative = config.alignPositiveNegative === undefined ? defaultAlignPN : config.alignPositiveNegative;
    const colorPositiveNegative = config.colorPositiveNegative === undefined ? defaultColorPN : config.colorPositiveNegative;
    const hasColumnColorFormatters = isNumeric && Array.isArray(columnColorFormatters) && columnColorFormatters.length > 0;
    const valueRange = !hasColumnColorFormatters && (config.showCellBars === undefined ? showCellBars : config.showCellBars) && (isMetric || isRawRecords) && getValueRange(key, alignPositiveNegative);
    let className = '';

    if (isFilter) {
      className += ' dt-is-filter';
    }

    return {
      id: String(i),
      // to allow duplicate column keys
      // must use custom accessor to allow `.` in column names
      // typing is incorrect in current version of `@types/react-table`
      // so we ask TS not to check.
      accessor: datum => datum[key],
      Cell: ({
        value
      }) => {
        const [isHtml, text] = (0, _formatValue.formatColumnValue)(column, value);
        const html = isHtml ? {
          __html: text
        } : undefined;
        let backgroundColor;

        if (hasColumnColorFormatters) {
          columnColorFormatters.filter(formatter => formatter.column === column.key).forEach(formatter => {
            const formatterResult = formatter.getColorFromValue(value);

            if (formatterResult) {
              backgroundColor = formatterResult;
            }
          });
        }

        const cellProps = {
          // show raw number in title in case of numeric values
          title: typeof value === 'number' ? String(value) : undefined,
          onClick: emitFilter && !valueRange ? () => toggleFilter(key, value) : undefined,
          className: [className, value == null ? 'dt-is-null' : '', isActiveFilterValue(key, value) ? ' dt-is-active-filter' : ''].join(' '),
          style: { ...sharedStyle,
            background: backgroundColor || (valueRange ? cellBar({
              value: value,
              valueRange,
              alignPositiveNegative,
              colorPositiveNegative
            }) : undefined)
          }
        };

        if (html) {
          // eslint-disable-next-line react/no-danger
          return (0, _react2.jsx)("td", _extends({}, cellProps, {
            dangerouslySetInnerHTML: html
          }));
        } // If cellProps renderes textContent already, then we don't have to
        // render `Cell`. This saves some time for large tables.


        return (0, _react2.jsx)("td", cellProps, text);
      },
      Header: ({
        column: col,
        onClick,
        style
      }) => (0, _react2.jsx)("th", {
        title: "Shift + Click to sort by multiple columns",
        className: [className, col.isSorted ? 'is-sorted' : ''].join(' '),
        style: { ...sharedStyle,
          ...style
        },
        onClick: onClick
      }, config.columnWidth ? // column width hint
      (0, _react2.jsx)("div", {
        style: {
          width: columnWidth,
          height: 0.01
        }
      }) : null, label, (0, _react2.jsx)(SortIcon, {
        column: col
      })),
      Footer: totals ? i === 0 ? (0, _react2.jsx)("th", null, (0, _core.t)('Totals')) : (0, _react2.jsx)("td", {
        style: sharedStyle
      }, (0, _react2.jsx)("strong", null, (0, _formatValue.formatColumnValue)(column, totals[key])[1])) : undefined,
      sortDescFirst: sortDesc,
      sortType: getSortTypeByDataType(dataType)
    };
  }, [defaultAlignPN, defaultColorPN, emitFilter, getValueRange, isActiveFilterValue, isRawRecords, showCellBars, sortDesc, toggleFilter, totals, columnColorFormatters]);
  const columns = (0, _react.useMemo)(() => columnsMeta.map(getColumnConfigs), [columnsMeta, getColumnConfigs]);

  const handleServerPaginationChange = (pageNumber, pageSize) => {
    (0, _externalAPIs.updateExternalFormData)(setDataMask, pageNumber, pageSize);
  };

  return (0, _react2.jsx)(_Styles.default, null, (0, _react2.jsx)(_DataTable.default, {
    columns: columns,
    data: data,
    rowCount: rowCount,
    tableClassName: "table table-striped table-condensed",
    pageSize: pageSize,
    serverPaginationData: serverPaginationData,
    pageSizeOptions: pageSizeOptions,
    width: width,
    height: height,
    serverPagination: serverPagination,
    onServerPaginationChange: handleServerPaginationChange // 9 page items in > 340px works well even for 100+ pages
    ,
    maxPageItemCount: width > 340 ? 9 : 7,
    noResults: filter => (0, _core.t)(filter ? 'No matching records found' : 'No records found'),
    searchInput: includeSearch && SearchInput,
    selectPageSize: pageSize !== null && SelectPageSize // not in use in Superset, but needed for unit tests
    ,
    sticky: sticky
  }));
}